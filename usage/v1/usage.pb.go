// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: usage.proto

package v1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// A UsageItem message contained usage tracking information for a tracked
// resource (usually deployment) in a specific time period.
type UsageItem struct {
	// System identifier of the usage item.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Kind of usage item
	Kind string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// Identification of the resource covered by this usage item
	Resource *UsageItem_Resource `protobuf:"bytes,4,opt,name=resource,proto3" json:"resource,omitempty"`
	// This usage item covers a time period that starts at this timestamp
	StartsAt *types.Timestamp `protobuf:"bytes,5,opt,name=starts_at,json=startsAt,proto3" json:"starts_at,omitempty"`
	// This usage item covers a time period that ends at this timestamp.
	// If the usage item has not yet ended, this field is is set to the current time.
	EndsAt *types.Timestamp `protobuf:"bytes,6,opt,name=ends_at,json=endsAt,proto3" json:"ends_at,omitempty"`
	// Set when this usage item has ended.
	HasEnded bool `protobuf:"varint,7,opt,name=has_ended,json=hasEnded,proto3" json:"has_ended,omitempty"`
	// Identifier of the tier the organization was using at the start of this usage period.
	TierId string `protobuf:"bytes,8,opt,name=tier_id,json=tierId,proto3" json:"tier_id,omitempty"`
	// Identifier of the invoice that includes this usage item.
	// The usage item must be ended when this field it set.
	InvoiceId string `protobuf:"bytes,9,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	// Amount of (computer) resources used by the resource covered by this usage item.
	// This field is only set when the usage item is of kind DeploymentSize.
	DeploymentSize *UsageItem_DeploymentSize `protobuf:"bytes,101,opt,name=deployment_size,json=deploymentSize,proto3" json:"deployment_size,omitempty"`
	// Amount of network traffic used by the resource covered by this usage item.
	// This field is only set when the usage item is of kind NetworkTransferSize.
	NetworkTransferSize *UsageItem_NetworkTransferSize `protobuf:"bytes,102,opt,name=network_transfer_size,json=networkTransferSize,proto3" json:"network_transfer_size,omitempty"`
	// Amount of backup related cloud storage used by the resource covered by this usage item.
	// This field is only set when the usage item is of kind BackupStorageSize.
	BackupStorageSize *UsageItem_BackupStorageSize `protobuf:"bytes,103,opt,name=backup_storage_size,json=backupStorageSize,proto3" json:"backup_storage_size,omitempty"`
	// Amount of audit log related resources used by the resource covered by this usage item.
	// This field is only set when the usage item is of kind AuditLogSize.
	AuditlogSize *UsageItem_AuditLogSize `protobuf:"bytes,104,opt,name=auditlog_size,json=auditlogSize,proto3" json:"auditlog_size,omitempty"`
	// Amount of audit log storage related resources used by the resource covered by this usage item.
	// This field is only set when the usage item is of kind AuditLogCloudSize.
	AuditlogStorageSize *UsageItem_AuditLogStorageSize `protobuf:"bytes,105,opt,name=auditlog_storage_size,json=auditlogStorageSize,proto3" json:"auditlog_storage_size,omitempty"`
	// Amount of cloud resources used by a given Notebook.
	// This field is only set when the usage item is of kind NotebookSize.
	NotebookSize *UsageItem_NotebookSize `protobuf:"bytes,106,opt,name=notebook_size,json=notebookSize,proto3" json:"notebook_size,omitempty"`
	// Amount of compute resources used by a given MLServices resource.
	// This field is only set when the usage item is of kind MLServicesSize.
	MlservicesSize       *UsageItem_MLServicesSize `protobuf:"bytes,107,opt,name=mlservices_size,json=mlservicesSize,proto3" json:"mlservices_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *UsageItem) Reset()         { *m = UsageItem{} }
func (m *UsageItem) String() string { return proto.CompactTextString(m) }
func (*UsageItem) ProtoMessage()    {}
func (*UsageItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0}
}
func (m *UsageItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem.Merge(m, src)
}
func (m *UsageItem) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem proto.InternalMessageInfo

func (m *UsageItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UsageItem) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *UsageItem) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *UsageItem) GetResource() *UsageItem_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *UsageItem) GetStartsAt() *types.Timestamp {
	if m != nil {
		return m.StartsAt
	}
	return nil
}

func (m *UsageItem) GetEndsAt() *types.Timestamp {
	if m != nil {
		return m.EndsAt
	}
	return nil
}

func (m *UsageItem) GetHasEnded() bool {
	if m != nil {
		return m.HasEnded
	}
	return false
}

func (m *UsageItem) GetTierId() string {
	if m != nil {
		return m.TierId
	}
	return ""
}

func (m *UsageItem) GetInvoiceId() string {
	if m != nil {
		return m.InvoiceId
	}
	return ""
}

func (m *UsageItem) GetDeploymentSize() *UsageItem_DeploymentSize {
	if m != nil {
		return m.DeploymentSize
	}
	return nil
}

func (m *UsageItem) GetNetworkTransferSize() *UsageItem_NetworkTransferSize {
	if m != nil {
		return m.NetworkTransferSize
	}
	return nil
}

func (m *UsageItem) GetBackupStorageSize() *UsageItem_BackupStorageSize {
	if m != nil {
		return m.BackupStorageSize
	}
	return nil
}

func (m *UsageItem) GetAuditlogSize() *UsageItem_AuditLogSize {
	if m != nil {
		return m.AuditlogSize
	}
	return nil
}

func (m *UsageItem) GetAuditlogStorageSize() *UsageItem_AuditLogStorageSize {
	if m != nil {
		return m.AuditlogStorageSize
	}
	return nil
}

func (m *UsageItem) GetNotebookSize() *UsageItem_NotebookSize {
	if m != nil {
		return m.NotebookSize
	}
	return nil
}

func (m *UsageItem) GetMlservicesSize() *UsageItem_MLServicesSize {
	if m != nil {
		return m.MlservicesSize
	}
	return nil
}

type UsageItem_Resource struct {
	// System identifier of the resource that this usage item covers.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of the resource that this usage item covers
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Kind of resource that this usage item covers.
	Kind string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// Human readable description of the resource that this usage item covers.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Identifier of the organization that owns the resource that this usage item covers.
	OrganizationId string `protobuf:"bytes,5,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	// Name of the organization that owns the resource that this usage item covers.
	OrganizationName string `protobuf:"bytes,6,opt,name=organization_name,json=organizationName,proto3" json:"organization_name,omitempty"`
	// Identifier of the project that owns the resource that this usage item covers.
	// This field is optional when the kind is AuditLogSize, depending if the audit log is for a deployment (set) or ArangoGraph Insights Platform (empty)
	ProjectId string `protobuf:"bytes,7,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Name of the project that owns the resource that this usage item covers.
	// This field is optional when the kind is AuditLogSize, depending if the audit log is for a deployment (set) or ArangoGraph Insights Platform (empty)
	ProjectName string `protobuf:"bytes,8,opt,name=project_name,json=projectName,proto3" json:"project_name,omitempty"`
	// Identifier of the deployment that owns the resource that this usage item covers.
	// This field is optional when the kind is AuditLogSize, depending if the audit log is for a deployment (set) or ArangoGraph Insights Platform (empty)
	DeploymentId string `protobuf:"bytes,9,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Name of the deployment that owns the resource that this usage item covers.
	// This field is optional when the kind is AuditLogSize, depending if the audit log is for a deployment (set) or ArangoGraph Insights Platform (empty)
	DeploymentName string `protobuf:"bytes,10,opt,name=deployment_name,json=deploymentName,proto3" json:"deployment_name,omitempty"`
	// Name of the deployment member that owns the resource that this usage item covers.
	// This field is only set when the usage item is specific for a member of the deployment (e.g. network transfer)
	DeploymentMemberName string `protobuf:"bytes,11,opt,name=deployment_member_name,json=deploymentMemberName,proto3" json:"deployment_member_name,omitempty"`
	// Identifier of the cloud provider that is used to run the deployment.
	// This field is optional when the kind is AuditLogSize, depending if the audit log is for a deployment (set) or ArangoGraph Insights Platform (empty)
	CloudProviderId string `protobuf:"bytes,12,opt,name=cloud_provider_id,json=cloudProviderId,proto3" json:"cloud_provider_id,omitempty"`
	// Identifier of the cloud region that is used to run the deployment.
	// This field is optional when the kind is AuditLogSize, depending if the audit log is for a deployment (set) or ArangoGraph Insights Platform (empty)
	CloudRegionId string `protobuf:"bytes,13,opt,name=cloud_region_id,json=cloudRegionId,proto3" json:"cloud_region_id,omitempty"`
	// Identifier of the support plan that is attached to the deployment.
	// This field is not filled-out when the kind is AuditLogSize
	SupportPlanId string `protobuf:"bytes,14,opt,name=support_plan_id,json=supportPlanId,proto3" json:"support_plan_id,omitempty"`
	// Model of the deployment
	// This field is not filled-out when the kind is AuditLogSize
	DeploymentModel string `protobuf:"bytes,15,opt,name=deployment_model,json=deploymentModel,proto3" json:"deployment_model,omitempty"`
	// Identifier of the PrepaidDeployment that this deployment is attached to (if any)
	PrepaidDeploymentId string `protobuf:"bytes,16,opt,name=prepaid_deployment_id,json=prepaidDeploymentId,proto3" json:"prepaid_deployment_id,omitempty"`
	// Timestamp when the prepaid_deployment starts (relevant when prepaid_deployment_id is set only)
	PrepaidDeploymentStartsAt *types.Timestamp `protobuf:"bytes,17,opt,name=prepaid_deployment_starts_at,json=prepaidDeploymentStartsAt,proto3" json:"prepaid_deployment_starts_at,omitempty"`
	// Timestamp when the prepaid_deployment ends (relevant when prepaid_deployment_id is set only)
	PrepaidDeploymentEndsAt *types.Timestamp `protobuf:"bytes,18,opt,name=prepaid_deployment_ends_at,json=prepaidDeploymentEndsAt,proto3" json:"prepaid_deployment_ends_at,omitempty"`
	// Identifiers of the credit bundles (if any) that were used to pay for this usage item.
	CreditBundleIds      []string `protobuf:"bytes,19,rep,name=credit_bundle_ids,json=creditBundleIds,proto3" json:"credit_bundle_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageItem_Resource) Reset()         { *m = UsageItem_Resource{} }
func (m *UsageItem_Resource) String() string { return proto.CompactTextString(m) }
func (*UsageItem_Resource) ProtoMessage()    {}
func (*UsageItem_Resource) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0, 0}
}
func (m *UsageItem_Resource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem_Resource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem_Resource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem_Resource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem_Resource.Merge(m, src)
}
func (m *UsageItem_Resource) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem_Resource) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem_Resource.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem_Resource proto.InternalMessageInfo

func (m *UsageItem_Resource) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *UsageItem_Resource) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *UsageItem_Resource) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *UsageItem_Resource) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *UsageItem_Resource) GetOrganizationId() string {
	if m != nil {
		return m.OrganizationId
	}
	return ""
}

func (m *UsageItem_Resource) GetOrganizationName() string {
	if m != nil {
		return m.OrganizationName
	}
	return ""
}

func (m *UsageItem_Resource) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *UsageItem_Resource) GetProjectName() string {
	if m != nil {
		return m.ProjectName
	}
	return ""
}

func (m *UsageItem_Resource) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *UsageItem_Resource) GetDeploymentName() string {
	if m != nil {
		return m.DeploymentName
	}
	return ""
}

func (m *UsageItem_Resource) GetDeploymentMemberName() string {
	if m != nil {
		return m.DeploymentMemberName
	}
	return ""
}

func (m *UsageItem_Resource) GetCloudProviderId() string {
	if m != nil {
		return m.CloudProviderId
	}
	return ""
}

func (m *UsageItem_Resource) GetCloudRegionId() string {
	if m != nil {
		return m.CloudRegionId
	}
	return ""
}

func (m *UsageItem_Resource) GetSupportPlanId() string {
	if m != nil {
		return m.SupportPlanId
	}
	return ""
}

func (m *UsageItem_Resource) GetDeploymentModel() string {
	if m != nil {
		return m.DeploymentModel
	}
	return ""
}

func (m *UsageItem_Resource) GetPrepaidDeploymentId() string {
	if m != nil {
		return m.PrepaidDeploymentId
	}
	return ""
}

func (m *UsageItem_Resource) GetPrepaidDeploymentStartsAt() *types.Timestamp {
	if m != nil {
		return m.PrepaidDeploymentStartsAt
	}
	return nil
}

func (m *UsageItem_Resource) GetPrepaidDeploymentEndsAt() *types.Timestamp {
	if m != nil {
		return m.PrepaidDeploymentEndsAt
	}
	return nil
}

func (m *UsageItem_Resource) GetCreditBundleIds() []string {
	if m != nil {
		return m.CreditBundleIds
	}
	return nil
}

// Amount of (computer) resources used by the resource covered by this usage item.
type UsageItem_DeploymentSize struct {
	// Number of coordinators of the deployment
	Coordinators int32 `protobuf:"varint,1,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Amount of memory (in GB) allocated for each coordinator.
	CoordinatorMemorySize int32 `protobuf:"varint,2,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Number of dbservers of the deployment
	Dbservers int32 `protobuf:"varint,11,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Amount of memory (in GB) allocated for each dbserver.
	DbserverMemorySize int32 `protobuf:"varint,12,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) allocated for each dbserver.
	DbserverDiskSize int32 `protobuf:"varint,13,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	// Number of agents of the deployment
	Agents int32 `protobuf:"varint,21,opt,name=agents,proto3" json:"agents,omitempty"`
	// Amount of memory (in GB) allocated for each agent.
	AgentMemorySize int32 `protobuf:"varint,22,opt,name=agent_memory_size,json=agentMemorySize,proto3" json:"agent_memory_size,omitempty"`
	// Amount of disk space (in GB) allocated for each agent.
	AgentDiskSize int32 `protobuf:"varint,23,opt,name=agent_disk_size,json=agentDiskSize,proto3" json:"agent_disk_size,omitempty"`
	// Identifier of the node-size used for this deployment (empty for flexible)
	NodeSizeId string `protobuf:"bytes,31,opt,name=node_size_id,json=nodeSizeId,proto3" json:"node_size_id,omitempty"`
	// Identifier of disk performance used for this deployment (if any).
	DiskPerformanceId string `protobuf:"bytes,32,opt,name=disk_performance_id,json=diskPerformanceId,proto3" json:"disk_performance_id,omitempty"`
	// List of identifiers of addons used by the deployment.
	AddonIds []string `protobuf:"bytes,41,rep,name=addon_ids,json=addonIds,proto3" json:"addon_ids,omitempty"`
	// IF true the deployment was in paused state
	IsPaused             bool     `protobuf:"varint,42,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageItem_DeploymentSize) Reset()         { *m = UsageItem_DeploymentSize{} }
func (m *UsageItem_DeploymentSize) String() string { return proto.CompactTextString(m) }
func (*UsageItem_DeploymentSize) ProtoMessage()    {}
func (*UsageItem_DeploymentSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0, 1}
}
func (m *UsageItem_DeploymentSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem_DeploymentSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem_DeploymentSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem_DeploymentSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem_DeploymentSize.Merge(m, src)
}
func (m *UsageItem_DeploymentSize) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem_DeploymentSize) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem_DeploymentSize.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem_DeploymentSize proto.InternalMessageInfo

func (m *UsageItem_DeploymentSize) GetCoordinators() int32 {
	if m != nil {
		return m.Coordinators
	}
	return 0
}

func (m *UsageItem_DeploymentSize) GetCoordinatorMemorySize() int32 {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return 0
}

func (m *UsageItem_DeploymentSize) GetDbservers() int32 {
	if m != nil {
		return m.Dbservers
	}
	return 0
}

func (m *UsageItem_DeploymentSize) GetDbserverMemorySize() int32 {
	if m != nil {
		return m.DbserverMemorySize
	}
	return 0
}

func (m *UsageItem_DeploymentSize) GetDbserverDiskSize() int32 {
	if m != nil {
		return m.DbserverDiskSize
	}
	return 0
}

func (m *UsageItem_DeploymentSize) GetAgents() int32 {
	if m != nil {
		return m.Agents
	}
	return 0
}

func (m *UsageItem_DeploymentSize) GetAgentMemorySize() int32 {
	if m != nil {
		return m.AgentMemorySize
	}
	return 0
}

func (m *UsageItem_DeploymentSize) GetAgentDiskSize() int32 {
	if m != nil {
		return m.AgentDiskSize
	}
	return 0
}

func (m *UsageItem_DeploymentSize) GetNodeSizeId() string {
	if m != nil {
		return m.NodeSizeId
	}
	return ""
}

func (m *UsageItem_DeploymentSize) GetDiskPerformanceId() string {
	if m != nil {
		return m.DiskPerformanceId
	}
	return ""
}

func (m *UsageItem_DeploymentSize) GetAddonIds() []string {
	if m != nil {
		return m.AddonIds
	}
	return nil
}

func (m *UsageItem_DeploymentSize) GetIsPaused() bool {
	if m != nil {
		return m.IsPaused
	}
	return false
}

// Amount of network traffic used by the resource covered by this usage item.
type UsageItem_NetworkTransferSize struct {
	// The destination (or source) the network traffic going to (or coming from)
	// Can be 'Internet' or 'InCluster'
	// An empty string means 'Internet'
	Destination string `protobuf:"bytes,1,opt,name=destination,proto3" json:"destination,omitempty"`
	// Total amount of network ingress traffic (in bytes) caused by the use of a deployment.
	// Destination 'Internet': This is traffic coming from the internet, so excluding inner cluster traffic
	// Destination 'InCluster': This is in-cluster traffic only
	// This is always excluding backup traffic (downloads).
	TotalTransferIngressSize int64 `protobuf:"varint,2,opt,name=total_transfer_ingress_size,json=totalTransferIngressSize,proto3" json:"total_transfer_ingress_size,omitempty"`
	// Total amount of network egress traffic (in bytes) caused by the use of a deployment.
	// Destination 'Internet': This is traffic going to the internet, so excluding inner cluster traffic
	// Destination 'InCluster': This is in-cluster traffic only
	// This is always excluding backup traffic (uploads).
	TotalTransferEgressSize int64    `protobuf:"varint,3,opt,name=total_transfer_egress_size,json=totalTransferEgressSize,proto3" json:"total_transfer_egress_size,omitempty"`
	XXX_NoUnkeyedLiteral    struct{} `json:"-"`
	XXX_unrecognized        []byte   `json:"-"`
	XXX_sizecache           int32    `json:"-"`
}

func (m *UsageItem_NetworkTransferSize) Reset()         { *m = UsageItem_NetworkTransferSize{} }
func (m *UsageItem_NetworkTransferSize) String() string { return proto.CompactTextString(m) }
func (*UsageItem_NetworkTransferSize) ProtoMessage()    {}
func (*UsageItem_NetworkTransferSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0, 2}
}
func (m *UsageItem_NetworkTransferSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem_NetworkTransferSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem_NetworkTransferSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem_NetworkTransferSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem_NetworkTransferSize.Merge(m, src)
}
func (m *UsageItem_NetworkTransferSize) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem_NetworkTransferSize) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem_NetworkTransferSize.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem_NetworkTransferSize proto.InternalMessageInfo

func (m *UsageItem_NetworkTransferSize) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *UsageItem_NetworkTransferSize) GetTotalTransferIngressSize() int64 {
	if m != nil {
		return m.TotalTransferIngressSize
	}
	return 0
}

func (m *UsageItem_NetworkTransferSize) GetTotalTransferEgressSize() int64 {
	if m != nil {
		return m.TotalTransferEgressSize
	}
	return 0
}

// Amount of backup related cloud storage used by the resource covered by this usage item.
type UsageItem_BackupStorageSize struct {
	// Amount of cloud storage (in bytes) used by backups of a deployment.
	CloudStorageSize     int64    `protobuf:"varint,1,opt,name=cloud_storage_size,json=cloudStorageSize,proto3" json:"cloud_storage_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageItem_BackupStorageSize) Reset()         { *m = UsageItem_BackupStorageSize{} }
func (m *UsageItem_BackupStorageSize) String() string { return proto.CompactTextString(m) }
func (*UsageItem_BackupStorageSize) ProtoMessage()    {}
func (*UsageItem_BackupStorageSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0, 3}
}
func (m *UsageItem_BackupStorageSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem_BackupStorageSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem_BackupStorageSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem_BackupStorageSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem_BackupStorageSize.Merge(m, src)
}
func (m *UsageItem_BackupStorageSize) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem_BackupStorageSize) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem_BackupStorageSize.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem_BackupStorageSize proto.InternalMessageInfo

func (m *UsageItem_BackupStorageSize) GetCloudStorageSize() int64 {
	if m != nil {
		return m.CloudStorageSize
	}
	return 0
}

// Amount of audit log related resources used by the resource covered by this usage item.
type UsageItem_AuditLogSize struct {
	// Type of destination.
	// Possible values are: "cloud", "https-post"
	DestinationType string `protobuf:"bytes,1,opt,name=destination_type,json=destinationType,proto3" json:"destination_type,omitempty"`
	// Number of events used by audit log.
	// This is the value of DestinationCounters.events (of the timespan covered by this usage item).
	EventCount int64 `protobuf:"varint,11,opt,name=event_count,json=eventCount,proto3" json:"event_count,omitempty"`
	// Number of bytes used by audit log.
	// This is the total of DestinationCounters.bytes_succeeded and bytes_failed (of the timespan covered by this usage item)
	// and depending on the destination type send to the cloud or used as the body of a https post request.
	EventSize int64 `protobuf:"varint,12,opt,name=event_size,json=eventSize,proto3" json:"event_size,omitempty"`
	// Number of https post invocations used by audit log.
	// This is the total of DestinationCounters.https_posts_succeeded and https_posts_failed (of the timespan covered by this usage item).
	// Set when destination_type is "https-post" only
	HttpsPostCount       int64    `protobuf:"varint,21,opt,name=https_post_count,json=httpsPostCount,proto3" json:"https_post_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageItem_AuditLogSize) Reset()         { *m = UsageItem_AuditLogSize{} }
func (m *UsageItem_AuditLogSize) String() string { return proto.CompactTextString(m) }
func (*UsageItem_AuditLogSize) ProtoMessage()    {}
func (*UsageItem_AuditLogSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0, 4}
}
func (m *UsageItem_AuditLogSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem_AuditLogSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem_AuditLogSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem_AuditLogSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem_AuditLogSize.Merge(m, src)
}
func (m *UsageItem_AuditLogSize) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem_AuditLogSize) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem_AuditLogSize.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem_AuditLogSize proto.InternalMessageInfo

func (m *UsageItem_AuditLogSize) GetDestinationType() string {
	if m != nil {
		return m.DestinationType
	}
	return ""
}

func (m *UsageItem_AuditLogSize) GetEventCount() int64 {
	if m != nil {
		return m.EventCount
	}
	return 0
}

func (m *UsageItem_AuditLogSize) GetEventSize() int64 {
	if m != nil {
		return m.EventSize
	}
	return 0
}

func (m *UsageItem_AuditLogSize) GetHttpsPostCount() int64 {
	if m != nil {
		return m.HttpsPostCount
	}
	return 0
}

// Amount of audit log storage related resources used by the resource covered by this usage item.
// When this usage type is used, the audit log destination_type is "cloud".
type UsageItem_AuditLogStorageSize struct {
	// Amount of cloud storage (in bytes) used by audit log.
	CloudStorageSize     int64    `protobuf:"varint,1,opt,name=cloud_storage_size,json=cloudStorageSize,proto3" json:"cloud_storage_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageItem_AuditLogStorageSize) Reset()         { *m = UsageItem_AuditLogStorageSize{} }
func (m *UsageItem_AuditLogStorageSize) String() string { return proto.CompactTextString(m) }
func (*UsageItem_AuditLogStorageSize) ProtoMessage()    {}
func (*UsageItem_AuditLogStorageSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0, 5}
}
func (m *UsageItem_AuditLogStorageSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem_AuditLogStorageSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem_AuditLogStorageSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem_AuditLogStorageSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem_AuditLogStorageSize.Merge(m, src)
}
func (m *UsageItem_AuditLogStorageSize) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem_AuditLogStorageSize) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem_AuditLogStorageSize.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem_AuditLogStorageSize proto.InternalMessageInfo

func (m *UsageItem_AuditLogStorageSize) GetCloudStorageSize() int64 {
	if m != nil {
		return m.CloudStorageSize
	}
	return 0
}

// Amount of cloud resources used by a given Notebook.
// This field is only set when the usage item is of kind NotebookSize.
type UsageItem_NotebookSize struct {
	// Amount of CPU units allocated to the notebook.
	// 1 CPU unit equals 1 physical / virtual CPU.
	CpuSize float32 `protobuf:"fixed32,1,opt,name=cpu_size,json=cpuSize,proto3" json:"cpu_size,omitempty"`
	// Amount of memory allocated to the notebook (in GiB).
	MemorySize int64 `protobuf:"varint,2,opt,name=memory_size,json=memorySize,proto3" json:"memory_size,omitempty"`
	// Size of the disk allocated to the notebook (in GiB).
	DiskSize int64 `protobuf:"varint,3,opt,name=disk_size,json=diskSize,proto3" json:"disk_size,omitempty"`
	// If the Notebook is paused (Hibernated phase).
	IsPaused bool `protobuf:"varint,4,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	// ID of the type of Notebook that is being used.
	NotebookModelId string `protobuf:"bytes,5,opt,name=notebook_model_id,json=notebookModelId,proto3" json:"notebook_model_id,omitempty"`
	// Amount of GPU units allocated to the notebook.
	// 1 GPU unit equals 1 physical / virtual GPU.
	GpuSize              float32  `protobuf:"fixed32,6,opt,name=gpu_size,json=gpuSize,proto3" json:"gpu_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageItem_NotebookSize) Reset()         { *m = UsageItem_NotebookSize{} }
func (m *UsageItem_NotebookSize) String() string { return proto.CompactTextString(m) }
func (*UsageItem_NotebookSize) ProtoMessage()    {}
func (*UsageItem_NotebookSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0, 6}
}
func (m *UsageItem_NotebookSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem_NotebookSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem_NotebookSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem_NotebookSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem_NotebookSize.Merge(m, src)
}
func (m *UsageItem_NotebookSize) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem_NotebookSize) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem_NotebookSize.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem_NotebookSize proto.InternalMessageInfo

func (m *UsageItem_NotebookSize) GetCpuSize() float32 {
	if m != nil {
		return m.CpuSize
	}
	return 0
}

func (m *UsageItem_NotebookSize) GetMemorySize() int64 {
	if m != nil {
		return m.MemorySize
	}
	return 0
}

func (m *UsageItem_NotebookSize) GetDiskSize() int64 {
	if m != nil {
		return m.DiskSize
	}
	return 0
}

func (m *UsageItem_NotebookSize) GetIsPaused() bool {
	if m != nil {
		return m.IsPaused
	}
	return false
}

func (m *UsageItem_NotebookSize) GetNotebookModelId() string {
	if m != nil {
		return m.NotebookModelId
	}
	return ""
}

func (m *UsageItem_NotebookSize) GetGpuSize() float32 {
	if m != nil {
		return m.GpuSize
	}
	return 0
}

// Amount of compute resources used by a given MLServices resource.
type UsageItem_MLServicesSize struct {
	// Number of training API servers.
	TrainingApis int32 `protobuf:"varint,1,opt,name=training_apis,json=trainingApis,proto3" json:"training_apis,omitempty"`
	// Amount of memory (in GB) allocated for each training API server.
	TrainingApiMemorySize int64 `protobuf:"varint,2,opt,name=training_api_memory_size,json=trainingApiMemorySize,proto3" json:"training_api_memory_size,omitempty"`
	// Amount of CPU units allocated to the training API server.
	// 1 CPU unit equals 1 physical / virtual CPU.
	TrainingApiCpuSize float32 `protobuf:"fixed32,3,opt,name=training_api_cpu_size,json=trainingApiCpuSize,proto3" json:"training_api_cpu_size,omitempty"`
	// Number of prediction API servers.
	PredictionApis int32 `protobuf:"varint,4,opt,name=prediction_apis,json=predictionApis,proto3" json:"prediction_apis,omitempty"`
	// Amount of memory (in GB) allocated for each prediction API server.
	PredictionApiMemorySize int64 `protobuf:"varint,5,opt,name=prediction_api_memory_size,json=predictionApiMemorySize,proto3" json:"prediction_api_memory_size,omitempty"`
	// Amount of CPU units allocated to the prediction API server.
	// 1 CPU unit equals 1 physical / virtual CPU.
	PredictionApiCpuSize float32 `protobuf:"fixed32,6,opt,name=prediction_api_cpu_size,json=predictionApiCpuSize,proto3" json:"prediction_api_cpu_size,omitempty"`
	// Number of projects API servers.
	ProjectsApis int32 `protobuf:"varint,7,opt,name=projects_apis,json=projectsApis,proto3" json:"projects_apis,omitempty"`
	// Amount of memory (in GB) allocated for each projects API server.
	ProjectsApiMemorySize int64 `protobuf:"varint,8,opt,name=projects_api_memory_size,json=projectsApiMemorySize,proto3" json:"projects_api_memory_size,omitempty"`
	// Amount of CPU units allocated to the projects API server.
	// 1 CPU unit equals 1 physical / virtual CPU.
	ProjectsApiCpuSize   float32  `protobuf:"fixed32,9,opt,name=projects_api_cpu_size,json=projectsApiCpuSize,proto3" json:"projects_api_cpu_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UsageItem_MLServicesSize) Reset()         { *m = UsageItem_MLServicesSize{} }
func (m *UsageItem_MLServicesSize) String() string { return proto.CompactTextString(m) }
func (*UsageItem_MLServicesSize) ProtoMessage()    {}
func (*UsageItem_MLServicesSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{0, 7}
}
func (m *UsageItem_MLServicesSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItem_MLServicesSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItem_MLServicesSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItem_MLServicesSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItem_MLServicesSize.Merge(m, src)
}
func (m *UsageItem_MLServicesSize) XXX_Size() int {
	return m.Size()
}
func (m *UsageItem_MLServicesSize) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItem_MLServicesSize.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItem_MLServicesSize proto.InternalMessageInfo

func (m *UsageItem_MLServicesSize) GetTrainingApis() int32 {
	if m != nil {
		return m.TrainingApis
	}
	return 0
}

func (m *UsageItem_MLServicesSize) GetTrainingApiMemorySize() int64 {
	if m != nil {
		return m.TrainingApiMemorySize
	}
	return 0
}

func (m *UsageItem_MLServicesSize) GetTrainingApiCpuSize() float32 {
	if m != nil {
		return m.TrainingApiCpuSize
	}
	return 0
}

func (m *UsageItem_MLServicesSize) GetPredictionApis() int32 {
	if m != nil {
		return m.PredictionApis
	}
	return 0
}

func (m *UsageItem_MLServicesSize) GetPredictionApiMemorySize() int64 {
	if m != nil {
		return m.PredictionApiMemorySize
	}
	return 0
}

func (m *UsageItem_MLServicesSize) GetPredictionApiCpuSize() float32 {
	if m != nil {
		return m.PredictionApiCpuSize
	}
	return 0
}

func (m *UsageItem_MLServicesSize) GetProjectsApis() int32 {
	if m != nil {
		return m.ProjectsApis
	}
	return 0
}

func (m *UsageItem_MLServicesSize) GetProjectsApiMemorySize() int64 {
	if m != nil {
		return m.ProjectsApiMemorySize
	}
	return 0
}

func (m *UsageItem_MLServicesSize) GetProjectsApiCpuSize() float32 {
	if m != nil {
		return m.ProjectsApiCpuSize
	}
	return 0
}

// List of UsageItems.
type UsageItemList struct {
	Items                []*UsageItem `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *UsageItemList) Reset()         { *m = UsageItemList{} }
func (m *UsageItemList) String() string { return proto.CompactTextString(m) }
func (*UsageItemList) ProtoMessage()    {}
func (*UsageItemList) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{1}
}
func (m *UsageItemList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageItemList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageItemList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageItemList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageItemList.Merge(m, src)
}
func (m *UsageItemList) XXX_Size() int {
	return m.Size()
}
func (m *UsageItemList) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageItemList.DiscardUnknown(m)
}

var xxx_messageInfo_UsageItemList proto.InternalMessageInfo

func (m *UsageItemList) GetItems() []*UsageItem {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request arguments for ListUsageItems
type ListUsageItemsRequest struct {
	// Request usage items for the organization with this id.
	// This is a required field.
	OrganizationId string `protobuf:"bytes,1,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	// Request usage items that overlaps in time with the time period that starts with this timestamp (inclusive).
	// This is a required field.
	From *types.Timestamp `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// Request usage items that overlaps in time with the time period that ends with this timestamp (exclusive).
	// This is a required field.
	To *types.Timestamp `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// Sort descending (new to old) on started_at field (default is ascending).
	SortDescending bool `protobuf:"varint,4,opt,name=sort_descending,json=sortDescending,proto3" json:"sort_descending,omitempty"`
	// Limit to usage items of this kind
	Kind string `protobuf:"bytes,5,opt,name=kind,proto3" json:"kind,omitempty"`
	// Standard list options
	// This is an optional field.
	Options *v1.ListOptions `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
	// Limit to usage items for the resource with this URL.
	// This is an optional field.
	ResourceUrl string `protobuf:"bytes,11,opt,name=resource_url,json=resourceUrl,proto3" json:"resource_url,omitempty"`
	// Limit to usage items for the resource with this kind.
	// This is an optional field.
	ResourceKind string `protobuf:"bytes,12,opt,name=resource_kind,json=resourceKind,proto3" json:"resource_kind,omitempty"`
	// Limit to usage items for the project with this id.
	// This is an optional field.
	ProjectId string `protobuf:"bytes,13,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Limit to usage items for the deployment with this id.
	// This is an optional field.
	DeploymentId string `protobuf:"bytes,14,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Limit to usage items for deployments with this node size.
	// This is an optional field.
	NodeSizeId string `protobuf:"bytes,15,opt,name=node_size_id,json=nodeSizeId,proto3" json:"node_size_id,omitempty"`
	// Limit to usage items for deployments in this region.
	// This is an optional field.
	RegionId string `protobuf:"bytes,16,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// If set, limit to usage items that have no invoice_id set.
	HasNoInvoiceId bool `protobuf:"varint,20,opt,name=has_no_invoice_id,json=hasNoInvoiceId,proto3" json:"has_no_invoice_id,omitempty"`
	// If set, limit to usage items that have an invoice_id set.
	HasInvoiceId bool `protobuf:"varint,21,opt,name=has_invoice_id,json=hasInvoiceId,proto3" json:"has_invoice_id,omitempty"`
	// If set, limit to usage items that have the invoice_id set to this specific value.
	// This is an optional field.
	InvoiceId string `protobuf:"bytes,22,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	// Request usage items that start at or after given timestamp.
	// This is an optional field.
	NotStartBefore       *types.Timestamp `protobuf:"bytes,23,opt,name=not_start_before,json=notStartBefore,proto3" json:"not_start_before,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListUsageItemsRequest) Reset()         { *m = ListUsageItemsRequest{} }
func (m *ListUsageItemsRequest) String() string { return proto.CompactTextString(m) }
func (*ListUsageItemsRequest) ProtoMessage()    {}
func (*ListUsageItemsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_fc9154f4fefb0f53, []int{2}
}
func (m *ListUsageItemsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListUsageItemsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListUsageItemsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListUsageItemsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListUsageItemsRequest.Merge(m, src)
}
func (m *ListUsageItemsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListUsageItemsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListUsageItemsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListUsageItemsRequest proto.InternalMessageInfo

func (m *ListUsageItemsRequest) GetOrganizationId() string {
	if m != nil {
		return m.OrganizationId
	}
	return ""
}

func (m *ListUsageItemsRequest) GetFrom() *types.Timestamp {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ListUsageItemsRequest) GetTo() *types.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListUsageItemsRequest) GetSortDescending() bool {
	if m != nil {
		return m.SortDescending
	}
	return false
}

func (m *ListUsageItemsRequest) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ListUsageItemsRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ListUsageItemsRequest) GetResourceUrl() string {
	if m != nil {
		return m.ResourceUrl
	}
	return ""
}

func (m *ListUsageItemsRequest) GetResourceKind() string {
	if m != nil {
		return m.ResourceKind
	}
	return ""
}

func (m *ListUsageItemsRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *ListUsageItemsRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *ListUsageItemsRequest) GetNodeSizeId() string {
	if m != nil {
		return m.NodeSizeId
	}
	return ""
}

func (m *ListUsageItemsRequest) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *ListUsageItemsRequest) GetHasNoInvoiceId() bool {
	if m != nil {
		return m.HasNoInvoiceId
	}
	return false
}

func (m *ListUsageItemsRequest) GetHasInvoiceId() bool {
	if m != nil {
		return m.HasInvoiceId
	}
	return false
}

func (m *ListUsageItemsRequest) GetInvoiceId() string {
	if m != nil {
		return m.InvoiceId
	}
	return ""
}

func (m *ListUsageItemsRequest) GetNotStartBefore() *types.Timestamp {
	if m != nil {
		return m.NotStartBefore
	}
	return nil
}

func init() {
	proto.RegisterType((*UsageItem)(nil), "arangodb.cloud.usage.v1.UsageItem")
	proto.RegisterType((*UsageItem_Resource)(nil), "arangodb.cloud.usage.v1.UsageItem.Resource")
	proto.RegisterType((*UsageItem_DeploymentSize)(nil), "arangodb.cloud.usage.v1.UsageItem.DeploymentSize")
	proto.RegisterType((*UsageItem_NetworkTransferSize)(nil), "arangodb.cloud.usage.v1.UsageItem.NetworkTransferSize")
	proto.RegisterType((*UsageItem_BackupStorageSize)(nil), "arangodb.cloud.usage.v1.UsageItem.BackupStorageSize")
	proto.RegisterType((*UsageItem_AuditLogSize)(nil), "arangodb.cloud.usage.v1.UsageItem.AuditLogSize")
	proto.RegisterType((*UsageItem_AuditLogStorageSize)(nil), "arangodb.cloud.usage.v1.UsageItem.AuditLogStorageSize")
	proto.RegisterType((*UsageItem_NotebookSize)(nil), "arangodb.cloud.usage.v1.UsageItem.NotebookSize")
	proto.RegisterType((*UsageItem_MLServicesSize)(nil), "arangodb.cloud.usage.v1.UsageItem.MLServicesSize")
	proto.RegisterType((*UsageItemList)(nil), "arangodb.cloud.usage.v1.UsageItemList")
	proto.RegisterType((*ListUsageItemsRequest)(nil), "arangodb.cloud.usage.v1.ListUsageItemsRequest")
}

func init() { proto.RegisterFile("usage.proto", fileDescriptor_fc9154f4fefb0f53) }

var fileDescriptor_fc9154f4fefb0f53 = []byte{
	// 1797 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x5b, 0x6f, 0x1c, 0x49,
	0x15, 0x66, 0x3c, 0xbe, 0xcc, 0x9c, 0xb9, 0xd8, 0x2e, 0x67, 0xec, 0xc9, 0x38, 0x24, 0x8e, 0x17,
	0xb2, 0x4e, 0x96, 0x9d, 0xc1, 0xde, 0x65, 0x03, 0x8a, 0xd0, 0xca, 0x89, 0xa3, 0xd5, 0x88, 0x24,
	0x58, 0x9d, 0x2c, 0x48, 0xe1, 0xa1, 0xd5, 0x33, 0x55, 0x6e, 0x57, 0x3c, 0xdd, 0xd5, 0x54, 0xd5,
	0x0c, 0x72, 0x10, 0x2f, 0xfc, 0x05, 0x24, 0x84, 0xc4, 0x23, 0x4f, 0xbc, 0xc2, 0x23, 0x7f, 0x00,
	0x89, 0x07, 0x90, 0xf8, 0x03, 0x28, 0xf0, 0x43, 0x50, 0x9d, 0xea, 0x4b, 0xf5, 0xd8, 0x89, 0x0d,
	0x6f, 0x53, 0xdf, 0xf9, 0xce, 0xa5, 0x2e, 0xe7, 0xd2, 0x03, 0x8d, 0xa9, 0x0a, 0x42, 0xd6, 0x4f,
	0xa4, 0xd0, 0x82, 0x6c, 0x05, 0x32, 0x88, 0x43, 0x41, 0x47, 0xfd, 0xf1, 0x44, 0x4c, 0x69, 0xdf,
	0xca, 0x66, 0xfb, 0xbd, 0xcd, 0xb1, 0x88, 0x22, 0x11, 0x0f, 0x66, 0xfb, 0x03, 0xfb, 0xcb, 0x2a,
	0xf4, 0x1e, 0x85, 0x5c, 0x9f, 0x4e, 0x47, 0xfd, 0xb1, 0x88, 0x06, 0xa1, 0x98, 0x04, 0x71, 0x38,
	0x40, 0xc1, 0x68, 0x7a, 0x32, 0x48, 0xf4, 0x79, 0xc2, 0xd4, 0x40, 0xf3, 0x88, 0x29, 0x1d, 0x44,
	0x49, 0xf1, 0x2b, 0x55, 0xbe, 0x15, 0x0a, 0x11, 0x4e, 0xd8, 0x20, 0x48, 0xf8, 0x20, 0x88, 0x63,
	0xa1, 0x03, 0xcd, 0x45, 0xac, 0xac, 0x74, 0xf7, 0xb7, 0xdb, 0x50, 0xff, 0xda, 0xf8, 0x1f, 0x6a,
	0x16, 0x91, 0x36, 0x2c, 0x70, 0xda, 0xad, 0xec, 0x54, 0xf6, 0xea, 0xde, 0x02, 0xa7, 0x64, 0x0d,
	0xaa, 0x53, 0x39, 0xe9, 0x2e, 0x20, 0x60, 0x7e, 0x12, 0x02, 0x8b, 0x67, 0x3c, 0xa6, 0xdd, 0x2a,
	0x42, 0xf8, 0x9b, 0x7c, 0x05, 0x35, 0xc9, 0x94, 0x98, 0xca, 0x31, 0xeb, 0x2e, 0xee, 0x54, 0xf6,
	0x1a, 0x07, 0x9f, 0xf4, 0xdf, 0xb3, 0xc5, 0x7e, 0xee, 0xab, 0xef, 0xa5, 0x2a, 0x5e, 0xae, 0x4c,
	0x1e, 0x42, 0x5d, 0xe9, 0x40, 0x6a, 0xe5, 0x07, 0xba, 0xbb, 0x84, 0x96, 0x7a, 0x7d, 0x1b, 0x7e,
	0x3f, 0xdb, 0x70, 0xff, 0x55, 0xb6, 0x3f, 0xaf, 0x66, 0xc9, 0x87, 0x9a, 0x7c, 0x06, 0x2b, 0x2c,
	0xa6, 0xa8, 0xb6, 0x7c, 0xa5, 0xda, 0xb2, 0xa1, 0x1e, 0x6a, 0xb2, 0x0d, 0xf5, 0xd3, 0x40, 0xf9,
	0x2c, 0xa6, 0x8c, 0x76, 0x57, 0x76, 0x2a, 0x7b, 0x35, 0xaf, 0x76, 0x1a, 0xa8, 0xa7, 0x66, 0x4d,
	0xb6, 0x60, 0x45, 0x73, 0x26, 0x7d, 0x4e, 0xbb, 0x35, 0xdc, 0xea, 0xb2, 0x59, 0x0e, 0x29, 0xf9,
	0x26, 0x00, 0x8f, 0x67, 0x82, 0x8f, 0x99, 0x91, 0xd5, 0x51, 0x56, 0x4f, 0x91, 0x21, 0x25, 0xaf,
	0x61, 0x95, 0xb2, 0x64, 0x22, 0xce, 0x23, 0x16, 0x6b, 0x5f, 0xf1, 0xb7, 0xac, 0xcb, 0x30, 0xa2,
	0xfd, 0x6b, 0x1c, 0xc9, 0x51, 0xae, 0xf9, 0x92, 0xbf, 0x65, 0x5e, 0x9b, 0x96, 0xd6, 0xe4, 0x0d,
	0x74, 0x62, 0xa6, 0x7f, 0x21, 0xe4, 0x99, 0xaf, 0x65, 0x10, 0xab, 0x13, 0x26, 0xad, 0x87, 0x13,
	0xf4, 0xf0, 0xc5, 0x35, 0x3c, 0xbc, 0xb0, 0xfa, 0xaf, 0x52, 0x75, 0x74, 0xb3, 0x11, 0x5f, 0x04,
	0x09, 0x85, 0x8d, 0x51, 0x30, 0x3e, 0x9b, 0x26, 0xbe, 0xd2, 0x42, 0x06, 0x21, 0xb3, 0x9e, 0x42,
	0xf4, 0xf4, 0xf9, 0x35, 0x3c, 0x3d, 0x46, 0xed, 0x97, 0x56, 0x19, 0xfd, 0xac, 0x8f, 0xe6, 0x21,
	0xf2, 0x0a, 0x5a, 0xc1, 0x94, 0x72, 0x3d, 0x11, 0xa1, 0xb5, 0x7f, 0x8a, 0xf6, 0x07, 0xd7, 0xb0,
	0x7f, 0x68, 0xf4, 0x9e, 0x89, 0x10, 0x4d, 0x37, 0x33, 0x2b, 0xd9, 0x39, 0x15, 0x56, 0xdd, 0xe8,
	0xf9, 0xb5, 0xcf, 0x29, 0xb7, 0xee, 0xc4, 0xbf, 0x91, 0x3b, 0x29, 0xef, 0x20, 0x16, 0x9a, 0x8d,
	0x84, 0x38, 0xb3, 0x3e, 0xde, 0x5c, 0x7b, 0x07, 0x2f, 0x52, 0x3d, 0xbb, 0x83, 0xd8, 0x59, 0x99,
	0x57, 0x14, 0x4d, 0x14, 0x93, 0x33, 0x3e, 0x66, 0xca, 0xda, 0x3d, 0xbb, 0xf6, 0x2b, 0x7a, 0xfe,
	0xec, 0x65, 0xaa, 0x69, 0x5f, 0x51, 0x61, 0xc9, 0xac, 0x7b, 0x7f, 0x59, 0x86, 0x5a, 0x96, 0x7b,
	0xff, 0x67, 0xc2, 0xef, 0x40, 0x83, 0x32, 0x35, 0x96, 0x3c, 0x31, 0xa5, 0x04, 0x73, 0xbe, 0xee,
	0xb9, 0x10, 0xf9, 0x18, 0x56, 0x85, 0x0c, 0x83, 0x98, 0xbf, 0xc5, 0x6a, 0x63, 0x52, 0x65, 0x09,
	0x59, 0x6d, 0x17, 0x1e, 0x52, 0xf2, 0x09, 0xac, 0x97, 0x88, 0x71, 0x10, 0x31, 0xcc, 0xe1, 0xba,
	0xb7, 0xe6, 0x0a, 0x5e, 0x04, 0x11, 0x33, 0xb9, 0x97, 0x48, 0xf1, 0x86, 0x8d, 0xb5, 0x31, 0xb8,
	0x62, 0x73, 0x2f, 0x45, 0x86, 0x94, 0xdc, 0x85, 0x66, 0x26, 0x46, 0x33, 0x36, 0x71, 0x1b, 0x29,
	0x86, 0x16, 0x3e, 0x82, 0x96, 0x93, 0x9e, 0x79, 0x02, 0x37, 0x0b, 0x70, 0x48, 0x4d, 0xf0, 0x0e,
	0x09, 0x4d, 0x81, 0x0d, 0xbe, 0x80, 0xd1, 0xda, 0xe7, 0xb0, 0xe9, 0x10, 0x23, 0x16, 0x8d, 0x98,
	0xb4, 0xfc, 0x06, 0xf2, 0x6f, 0x14, 0xd2, 0xe7, 0x28, 0x44, 0xad, 0x07, 0xb0, 0x8e, 0x77, 0xe7,
	0x27, 0x52, 0xcc, 0x38, 0xb5, 0x45, 0xa6, 0x89, 0x0a, 0xab, 0x28, 0x38, 0x4e, 0xf1, 0x21, 0x25,
	0xf7, 0xc0, 0x42, 0xbe, 0x64, 0x61, 0x7a, 0x8e, 0x2d, 0x64, 0xb6, 0x10, 0xf6, 0x10, 0xb5, 0x3c,
	0x35, 0x4d, 0x12, 0x21, 0xb5, 0x9f, 0x4c, 0x02, 0xe4, 0xb5, 0x2d, 0x2f, 0x85, 0x8f, 0x27, 0x81,
	0xe1, 0xdd, 0x87, 0x35, 0x37, 0x62, 0x41, 0xd9, 0xa4, 0xbb, 0x6a, 0x5d, 0x3b, 0xb1, 0x1a, 0x98,
	0x1c, 0x40, 0x27, 0x91, 0x2c, 0x09, 0x38, 0xf5, 0xcb, 0x47, 0xb6, 0x86, 0xfc, 0x8d, 0x54, 0x78,
	0xe4, 0x9e, 0xdc, 0xcf, 0xe0, 0xd6, 0x25, 0x3a, 0x45, 0x4d, 0x5f, 0xbf, 0xb2, 0x38, 0xdf, 0xbc,
	0x60, 0xf6, 0x65, 0x56, 0xe4, 0x7f, 0x0a, 0xbd, 0x4b, 0x8c, 0x67, 0x75, 0x9f, 0x5c, 0x69, 0x7a,
	0xeb, 0x82, 0xe9, 0xa7, 0xb6, 0x11, 0x98, 0x0b, 0x91, 0x8c, 0x72, 0xed, 0x8f, 0xa6, 0x31, 0x9d,
	0x98, 0xc2, 0xae, 0xba, 0x1b, 0x3b, 0x55, 0xbc, 0x10, 0x14, 0x3c, 0x46, 0x7c, 0x48, 0x55, 0xef,
	0x5d, 0x15, 0xda, 0xe5, 0x32, 0x4d, 0x76, 0xa1, 0x39, 0x16, 0x42, 0x52, 0x1e, 0x07, 0x5a, 0x48,
	0x85, 0xd9, 0xb4, 0xe4, 0x95, 0x30, 0xf2, 0x05, 0x6c, 0x39, 0x6b, 0xf3, 0x54, 0x84, 0x3c, 0xb7,
	0x89, 0xbd, 0x80, 0xf4, 0x8e, 0x23, 0x7e, 0x8e, 0x52, 0xb4, 0x7d, 0x0b, 0xea, 0x74, 0x64, 0xd2,
	0x97, 0x49, 0x85, 0x8f, 0x6a, 0xc9, 0x2b, 0x00, 0xf2, 0x5d, 0xb8, 0x91, 0x2d, 0x4a, 0x26, 0x9b,
	0x48, 0x24, 0x99, 0xcc, 0xb1, 0xf7, 0x1d, 0xc8, 0x51, 0x9f, 0x72, 0x95, 0xd6, 0xac, 0x16, 0xf2,
	0xd7, 0x32, 0xc9, 0x11, 0x57, 0xb6, 0x0c, 0x6d, 0xc2, 0x72, 0x10, 0xb2, 0x58, 0xab, 0x6e, 0x07,
	0x19, 0xe9, 0xca, 0x1c, 0x18, 0xfe, 0x2a, 0x39, 0xdd, 0x44, 0xca, 0x2a, 0x0a, 0x1c, 0x8f, 0xf7,
	0xc0, 0x42, 0x8e, 0xbb, 0x2d, 0x64, 0xb6, 0x10, 0xce, 0x7d, 0xed, 0x40, 0x33, 0x16, 0xd4, 0x16,
	0x6a, 0xf3, 0xca, 0xee, 0xe0, 0x2b, 0x03, 0x83, 0x19, 0xf9, 0x90, 0x92, 0x3e, 0x6c, 0xa0, 0x8d,
	0x84, 0xc9, 0x13, 0x21, 0xa3, 0x20, 0xb6, 0x2d, 0x78, 0x07, 0x89, 0xeb, 0x46, 0x74, 0x5c, 0x48,
	0x86, 0xd4, 0xf4, 0xf7, 0x80, 0x52, 0x4c, 0x1a, 0xd5, 0xbd, 0x8f, 0xd7, 0x59, 0x43, 0x60, 0x48,
	0x95, 0x11, 0x72, 0xe5, 0x27, 0xc1, 0x54, 0x31, 0xda, 0x7d, 0x60, 0x9b, 0x3f, 0x57, 0xc7, 0xb8,
	0xee, 0xfd, 0xb9, 0x02, 0x1b, 0x97, 0x74, 0xca, 0xb4, 0xee, 0x69, 0x73, 0x4b, 0xa6, 0xee, 0x55,
	0xf2, 0xba, 0x97, 0x41, 0xe4, 0x87, 0xb0, 0xad, 0x85, 0x0e, 0x26, 0x45, 0x83, 0xe6, 0x71, 0x28,
	0x99, 0x52, 0xc5, 0x5d, 0x57, 0xbd, 0x2e, 0x52, 0x32, 0xcb, 0x43, 0x4b, 0x40, 0x07, 0x8f, 0xa0,
	0x37, 0xa7, 0xce, 0x1c, 0xed, 0x2a, 0x6a, 0x6f, 0x95, 0xb4, 0x9f, 0xe6, 0xca, 0xbd, 0x43, 0x58,
	0xbf, 0xd0, 0x74, 0xcd, 0x85, 0xdb, 0x02, 0x52, 0x6a, 0x84, 0x15, 0xb4, 0xb4, 0x86, 0x12, 0x87,
	0xdd, 0xfb, 0x43, 0x05, 0x9a, 0x6e, 0x63, 0xb5, 0xf5, 0x22, 0xdf, 0x9e, 0x6f, 0x66, 0xcd, 0x74,
	0xdb, 0xab, 0x0e, 0xfe, 0xea, 0x3c, 0x61, 0xe4, 0x0e, 0x34, 0xd8, 0xcc, 0x5c, 0xf4, 0x58, 0x4c,
	0x63, 0x8d, 0x8f, 0xb5, 0xea, 0x01, 0x42, 0x4f, 0x0c, 0x62, 0xaa, 0xb7, 0x25, 0xe4, 0x6f, 0xb4,
	0xea, 0xd5, 0x11, 0x41, 0x57, 0x7b, 0xb0, 0x76, 0xaa, 0x75, 0xa2, 0xfc, 0x44, 0xa8, 0xcc, 0x48,
	0x07, 0x49, 0x6d, 0xc4, 0x8f, 0x85, 0xb2, 0x86, 0x7a, 0x4f, 0x60, 0xe3, 0x92, 0xfe, 0xfc, 0x3f,
	0x6e, 0xf5, 0x6f, 0x15, 0x68, 0xba, 0x1d, 0x98, 0xdc, 0x84, 0xda, 0x38, 0x99, 0x16, 0x4a, 0x0b,
	0xde, 0xca, 0x38, 0x99, 0xa2, 0xe8, 0x0e, 0x34, 0xe6, 0x33, 0xb6, 0xea, 0x41, 0x54, 0x3c, 0xf2,
	0x6d, 0xa8, 0x17, 0xcf, 0xdb, 0x5e, 0x53, 0x8d, 0x66, 0x2f, 0xbb, 0xf4, 0xd4, 0x16, 0xcb, 0x4f,
	0xcd, 0xa4, 0x52, 0x3e, 0x3f, 0x60, 0x39, 0x2e, 0x5a, 0xe5, 0x6a, 0x26, 0xc0, 0x7a, 0x3c, 0xa4,
	0x26, 0xc2, 0x30, 0x8b, 0x70, 0xd9, 0x46, 0x18, 0xda, 0x08, 0x7b, 0x7f, 0xaf, 0x42, 0xbb, 0xdc,
	0xf7, 0x4d, 0xab, 0xd3, 0x32, 0xe0, 0x31, 0x8f, 0x43, 0x3f, 0x48, 0x78, 0x5e, 0x97, 0x32, 0xf0,
	0x30, 0xe1, 0x8a, 0x3c, 0x84, 0xae, 0x4b, 0xf2, 0x2f, 0x6e, 0xb3, 0xe3, 0xf0, 0x9d, 0xb4, 0xde,
	0x87, 0x4e, 0x49, 0x31, 0x3f, 0xba, 0x2a, 0x06, 0x46, 0x1c, 0xad, 0x27, 0xe9, 0x29, 0x7e, 0x0c,
	0xab, 0x89, 0xa9, 0xa6, 0x63, 0x7c, 0x4a, 0x18, 0xd2, 0x22, 0x86, 0xd4, 0x2e, 0x60, 0x0c, 0xea,
	0x11, 0x16, 0x7a, 0x87, 0x58, 0x0a, 0x6b, 0xc9, 0x66, 0x41, 0x49, 0xc7, 0x09, 0xec, 0x7b, 0xb0,
	0x35, 0xa7, 0x3c, 0x2e, 0x9f, 0xd9, 0x8d, 0x92, 0x66, 0x16, 0xdc, 0x47, 0xd0, 0x4a, 0xe7, 0x04,
	0x65, 0x43, 0x5b, 0xb1, 0xa7, 0x95, 0x81, 0xd9, 0x69, 0xb9, 0xa4, 0x52, 0x58, 0x35, 0x7b, 0x5a,
	0x0e, 0xbf, 0x7c, 0x5a, 0x25, 0xc5, 0x3c, 0xa4, 0xba, 0x3d, 0x2d, 0x47, 0x2b, 0x0d, 0x68, 0x77,
	0x08, 0xad, 0x7c, 0xa4, 0x7b, 0xc6, 0x95, 0x26, 0xdf, 0x87, 0x25, 0xae, 0x59, 0x64, 0xee, 0xb1,
	0xba, 0xd7, 0x38, 0xd8, 0xbd, 0x7a, 0x12, 0xf4, 0xac, 0xc2, 0xee, 0xef, 0x97, 0xa0, 0x63, 0x4c,
	0xe4, 0x02, 0xe5, 0xb1, 0x9f, 0x4f, 0x99, 0xd2, 0x97, 0x8d, 0x69, 0x95, 0x4b, 0xc7, 0xb4, 0x3e,
	0x2c, 0x9e, 0x48, 0x11, 0xe1, 0x9b, 0xf8, 0x70, 0x97, 0x45, 0x1e, 0x79, 0x00, 0x0b, 0x5a, 0xe0,
	0x5b, 0xf8, 0x30, 0x7b, 0x41, 0x0b, 0x13, 0x84, 0x32, 0x83, 0x8b, 0x99, 0x1f, 0x59, 0x4c, 0x79,
	0x1c, 0xa6, 0x59, 0xd2, 0x36, 0xf0, 0x51, 0x8e, 0xe6, 0xa3, 0xe8, 0x92, 0x33, 0x8a, 0x7e, 0x09,
	0x2b, 0x02, 0x47, 0x4e, 0x85, 0x33, 0x5a, 0xe3, 0xe0, 0xdb, 0xf3, 0xe7, 0x92, 0x7e, 0x49, 0xcf,
	0xf6, 0xfb, 0xe6, 0x0c, 0x7e, 0x6c, 0xc9, 0x5e, 0xa6, 0x65, 0x86, 0xc6, 0xec, 0xfb, 0xd3, 0x37,
	0xa3, 0xaf, 0x9d, 0xdc, 0x1a, 0x19, 0xf6, 0xb5, 0x9c, 0x98, 0xb7, 0x91, 0x53, 0x30, 0x00, 0x3b,
	0xac, 0xe5, 0x7a, 0x3f, 0x32, 0x81, 0x94, 0x67, 0xd3, 0xd6, 0xfc, 0x6c, 0x7a, 0x61, 0xf0, 0x6c,
	0x5f, 0x32, 0x78, 0xce, 0xf7, 0xc0, 0xd5, 0x0b, 0x3d, 0x70, 0x1b, 0xea, 0xc5, 0x24, 0x68, 0x07,
	0xb1, 0x9a, 0xcc, 0x86, 0xc0, 0xfb, 0xb0, 0x6e, 0x3e, 0x68, 0x63, 0xe1, 0x3b, 0x5f, 0xa8, 0x37,
	0xec, 0x51, 0x9e, 0x06, 0xea, 0x85, 0x18, 0xe6, 0x9f, 0xa9, 0xdf, 0x02, 0x83, 0xb8, 0xbc, 0x0e,
	0xf2, 0x9a, 0xa7, 0x81, 0x2a, 0x58, 0xe5, 0x6f, 0xdd, 0xcd, 0xf9, 0x6f, 0xdd, 0x23, 0x58, 0x8b,
	0x45, 0x3a, 0xde, 0xf9, 0x23, 0x76, 0x22, 0xa4, 0xed, 0xed, 0x1f, 0xbe, 0xf2, 0x76, 0x2c, 0xec,
	0x4c, 0xf7, 0x18, 0x35, 0x0e, 0xfe, 0xb4, 0x00, 0x4d, 0x7c, 0x99, 0x69, 0xf5, 0x22, 0x33, 0x68,
	0x7d, 0xc5, 0xf4, 0xe1, 0xf1, 0xf0, 0x27, 0x4c, 0x2a, 0xd3, 0x54, 0xef, 0xbc, 0xff, 0x4a, 0x9f,
	0x46, 0x89, 0x3e, 0xef, 0xdd, 0x7d, 0x3f, 0x21, 0xb5, 0xb1, 0x7b, 0xf7, 0xd7, 0xff, 0xfc, 0xcf,
	0x6f, 0x16, 0xb6, 0xc9, 0x4d, 0xfc, 0x1f, 0x04, 0x73, 0x65, 0x30, 0xdb, 0x37, 0x8b, 0x4f, 0x67,
	0xa9, 0x9b, 0x3f, 0x56, 0xa0, 0x5d, 0x4e, 0x13, 0xd2, 0x7f, 0x6f, 0x92, 0x5d, 0x9a, 0x4f, 0xbd,
	0x7b, 0x57, 0x27, 0xa5, 0x51, 0xdc, 0xfd, 0x12, 0xa3, 0xf9, 0x01, 0x79, 0x58, 0x8e, 0xc6, 0x4d,
	0xba, 0xc1, 0x2f, 0xe7, 0x32, 0xf3, 0x57, 0x96, 0x87, 0x29, 0xfd, 0xf8, 0xd1, 0x5f, 0xdf, 0xdd,
	0xae, 0xfc, 0xe3, 0xdd, 0xed, 0xca, 0xbf, 0xde, 0xdd, 0xae, 0xfc, 0xee, 0xdf, 0xb7, 0xbf, 0xf1,
	0xfa, 0xbe, 0xf3, 0x1f, 0x51, 0x16, 0xc4, 0xa7, 0x51, 0x10, 0x07, 0x21, 0xa3, 0xc6, 0x8b, 0xca,
	0xdd, 0x8c, 0x96, 0xf1, 0x56, 0x3e, 0xfb, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1c, 0x66, 0x37,
	0x12, 0x95, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UsageServiceClient is the client API for UsageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UsageServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// Fetch all UsageItem resources in the organization identified by the given
	// organization ID that match the given criteria.
	// Required permissions:
	// - usage.usageitem.list on the organization identified by the given organization ID
	ListUsageItems(ctx context.Context, in *ListUsageItemsRequest, opts ...grpc.CallOption) (*UsageItemList, error)
}

type usageServiceClient struct {
	cc *grpc.ClientConn
}

func NewUsageServiceClient(cc *grpc.ClientConn) UsageServiceClient {
	return &usageServiceClient{cc}
}

func (c *usageServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.usage.v1.UsageService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usageServiceClient) ListUsageItems(ctx context.Context, in *ListUsageItemsRequest, opts ...grpc.CallOption) (*UsageItemList, error) {
	out := new(UsageItemList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.usage.v1.UsageService/ListUsageItems", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UsageServiceServer is the server API for UsageService service.
type UsageServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// Fetch all UsageItem resources in the organization identified by the given
	// organization ID that match the given criteria.
	// Required permissions:
	// - usage.usageitem.list on the organization identified by the given organization ID
	ListUsageItems(context.Context, *ListUsageItemsRequest) (*UsageItemList, error)
}

// UnimplementedUsageServiceServer can be embedded to have forward compatible implementations.
type UnimplementedUsageServiceServer struct {
}

func (*UnimplementedUsageServiceServer) GetAPIVersion(ctx context.Context, req *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedUsageServiceServer) ListUsageItems(ctx context.Context, req *ListUsageItemsRequest) (*UsageItemList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsageItems not implemented")
}

func RegisterUsageServiceServer(s *grpc.Server, srv UsageServiceServer) {
	s.RegisterService(&_UsageService_serviceDesc, srv)
}

func _UsageService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.usage.v1.UsageService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _UsageService_ListUsageItems_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsageItemsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsageServiceServer).ListUsageItems(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.usage.v1.UsageService/ListUsageItems",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsageServiceServer).ListUsageItems(ctx, req.(*ListUsageItemsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UsageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.usage.v1.UsageService",
	HandlerType: (*UsageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _UsageService_GetAPIVersion_Handler,
		},
		{
			MethodName: "ListUsageItems",
			Handler:    _UsageService_ListUsageItems_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "usage.proto",
}

func (m *UsageItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MlservicesSize != nil {
		{
			size, err := m.MlservicesSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xda
	}
	if m.NotebookSize != nil {
		{
			size, err := m.NotebookSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd2
	}
	if m.AuditlogStorageSize != nil {
		{
			size, err := m.AuditlogStorageSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xca
	}
	if m.AuditlogSize != nil {
		{
			size, err := m.AuditlogSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc2
	}
	if m.BackupStorageSize != nil {
		{
			size, err := m.BackupStorageSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	if m.NetworkTransferSize != nil {
		{
			size, err := m.NetworkTransferSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	if m.DeploymentSize != nil {
		{
			size, err := m.DeploymentSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if len(m.InvoiceId) > 0 {
		i -= len(m.InvoiceId)
		copy(dAtA[i:], m.InvoiceId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.InvoiceId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.TierId) > 0 {
		i -= len(m.TierId)
		copy(dAtA[i:], m.TierId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.TierId)))
		i--
		dAtA[i] = 0x42
	}
	if m.HasEnded {
		i--
		if m.HasEnded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.EndsAt != nil {
		{
			size, err := m.EndsAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.StartsAt != nil {
		{
			size, err := m.StartsAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Resource != nil {
		{
			size, err := m.Resource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem_Resource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem_Resource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem_Resource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CreditBundleIds) > 0 {
		for iNdEx := len(m.CreditBundleIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CreditBundleIds[iNdEx])
			copy(dAtA[i:], m.CreditBundleIds[iNdEx])
			i = encodeVarintUsage(dAtA, i, uint64(len(m.CreditBundleIds[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.PrepaidDeploymentEndsAt != nil {
		{
			size, err := m.PrepaidDeploymentEndsAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.PrepaidDeploymentStartsAt != nil {
		{
			size, err := m.PrepaidDeploymentStartsAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.PrepaidDeploymentId) > 0 {
		i -= len(m.PrepaidDeploymentId)
		copy(dAtA[i:], m.PrepaidDeploymentId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.PrepaidDeploymentId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.DeploymentModel) > 0 {
		i -= len(m.DeploymentModel)
		copy(dAtA[i:], m.DeploymentModel)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.DeploymentModel)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.SupportPlanId) > 0 {
		i -= len(m.SupportPlanId)
		copy(dAtA[i:], m.SupportPlanId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.SupportPlanId)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.CloudRegionId) > 0 {
		i -= len(m.CloudRegionId)
		copy(dAtA[i:], m.CloudRegionId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.CloudRegionId)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.CloudProviderId) > 0 {
		i -= len(m.CloudProviderId)
		copy(dAtA[i:], m.CloudProviderId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.CloudProviderId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.DeploymentMemberName) > 0 {
		i -= len(m.DeploymentMemberName)
		copy(dAtA[i:], m.DeploymentMemberName)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.DeploymentMemberName)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.DeploymentName) > 0 {
		i -= len(m.DeploymentName)
		copy(dAtA[i:], m.DeploymentName)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.DeploymentName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ProjectName) > 0 {
		i -= len(m.ProjectName)
		copy(dAtA[i:], m.ProjectName)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.ProjectName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OrganizationName) > 0 {
		i -= len(m.OrganizationName)
		copy(dAtA[i:], m.OrganizationName)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.OrganizationName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OrganizationId) > 0 {
		i -= len(m.OrganizationId)
		copy(dAtA[i:], m.OrganizationId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.OrganizationId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem_DeploymentSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem_DeploymentSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem_DeploymentSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsPaused {
		i--
		if m.IsPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if len(m.AddonIds) > 0 {
		for iNdEx := len(m.AddonIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddonIds[iNdEx])
			copy(dAtA[i:], m.AddonIds[iNdEx])
			i = encodeVarintUsage(dAtA, i, uint64(len(m.AddonIds[iNdEx])))
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xca
		}
	}
	if len(m.DiskPerformanceId) > 0 {
		i -= len(m.DiskPerformanceId)
		copy(dAtA[i:], m.DiskPerformanceId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.DiskPerformanceId)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.NodeSizeId) > 0 {
		i -= len(m.NodeSizeId)
		copy(dAtA[i:], m.NodeSizeId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.NodeSizeId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.AgentDiskSize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.AgentDiskSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.AgentMemorySize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.AgentMemorySize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Agents != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.Agents))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.DbserverDiskSize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.DbserverDiskSize))
		i--
		dAtA[i] = 0x68
	}
	if m.DbserverMemorySize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.DbserverMemorySize))
		i--
		dAtA[i] = 0x60
	}
	if m.Dbservers != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.Dbservers))
		i--
		dAtA[i] = 0x58
	}
	if m.CoordinatorMemorySize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.CoordinatorMemorySize))
		i--
		dAtA[i] = 0x10
	}
	if m.Coordinators != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.Coordinators))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem_NetworkTransferSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem_NetworkTransferSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem_NetworkTransferSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TotalTransferEgressSize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.TotalTransferEgressSize))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalTransferIngressSize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.TotalTransferIngressSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Destination) > 0 {
		i -= len(m.Destination)
		copy(dAtA[i:], m.Destination)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Destination)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem_BackupStorageSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem_BackupStorageSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem_BackupStorageSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CloudStorageSize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.CloudStorageSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem_AuditLogSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem_AuditLogSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem_AuditLogSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HttpsPostCount != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.HttpsPostCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.EventSize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.EventSize))
		i--
		dAtA[i] = 0x60
	}
	if m.EventCount != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.EventCount))
		i--
		dAtA[i] = 0x58
	}
	if len(m.DestinationType) > 0 {
		i -= len(m.DestinationType)
		copy(dAtA[i:], m.DestinationType)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.DestinationType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem_AuditLogStorageSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem_AuditLogStorageSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem_AuditLogStorageSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CloudStorageSize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.CloudStorageSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem_NotebookSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem_NotebookSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem_NotebookSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GpuSize != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GpuSize))))
		i--
		dAtA[i] = 0x35
	}
	if len(m.NotebookModelId) > 0 {
		i -= len(m.NotebookModelId)
		copy(dAtA[i:], m.NotebookModelId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.NotebookModelId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.IsPaused {
		i--
		if m.IsPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DiskSize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.DiskSize))
		i--
		dAtA[i] = 0x18
	}
	if m.MemorySize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.MemorySize))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuSize != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CpuSize))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *UsageItem_MLServicesSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItem_MLServicesSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItem_MLServicesSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ProjectsApiCpuSize != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ProjectsApiCpuSize))))
		i--
		dAtA[i] = 0x4d
	}
	if m.ProjectsApiMemorySize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.ProjectsApiMemorySize))
		i--
		dAtA[i] = 0x40
	}
	if m.ProjectsApis != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.ProjectsApis))
		i--
		dAtA[i] = 0x38
	}
	if m.PredictionApiCpuSize != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PredictionApiCpuSize))))
		i--
		dAtA[i] = 0x35
	}
	if m.PredictionApiMemorySize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.PredictionApiMemorySize))
		i--
		dAtA[i] = 0x28
	}
	if m.PredictionApis != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.PredictionApis))
		i--
		dAtA[i] = 0x20
	}
	if m.TrainingApiCpuSize != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.TrainingApiCpuSize))))
		i--
		dAtA[i] = 0x1d
	}
	if m.TrainingApiMemorySize != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.TrainingApiMemorySize))
		i--
		dAtA[i] = 0x10
	}
	if m.TrainingApis != 0 {
		i = encodeVarintUsage(dAtA, i, uint64(m.TrainingApis))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UsageItemList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageItemList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageItemList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintUsage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListUsageItemsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListUsageItemsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListUsageItemsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NotStartBefore != nil {
		{
			size, err := m.NotStartBefore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.InvoiceId) > 0 {
		i -= len(m.InvoiceId)
		copy(dAtA[i:], m.InvoiceId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.InvoiceId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.HasInvoiceId {
		i--
		if m.HasInvoiceId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.HasNoInvoiceId {
		i--
		if m.HasNoInvoiceId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.NodeSizeId) > 0 {
		i -= len(m.NodeSizeId)
		copy(dAtA[i:], m.NodeSizeId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.NodeSizeId)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.ResourceKind) > 0 {
		i -= len(m.ResourceKind)
		copy(dAtA[i:], m.ResourceKind)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.ResourceKind)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.ResourceUrl) > 0 {
		i -= len(m.ResourceUrl)
		copy(dAtA[i:], m.ResourceUrl)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.ResourceUrl)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SortDescending {
		i--
		if m.SortDescending {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintUsage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrganizationId) > 0 {
		i -= len(m.OrganizationId)
		copy(dAtA[i:], m.OrganizationId)
		i = encodeVarintUsage(dAtA, i, uint64(len(m.OrganizationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintUsage(dAtA []byte, offset int, v uint64) int {
	offset -= sovUsage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UsageItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.StartsAt != nil {
		l = m.StartsAt.Size()
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.EndsAt != nil {
		l = m.EndsAt.Size()
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.HasEnded {
		n += 2
	}
	l = len(m.TierId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.InvoiceId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.DeploymentSize != nil {
		l = m.DeploymentSize.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.NetworkTransferSize != nil {
		l = m.NetworkTransferSize.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.BackupStorageSize != nil {
		l = m.BackupStorageSize.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.AuditlogSize != nil {
		l = m.AuditlogSize.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.AuditlogStorageSize != nil {
		l = m.AuditlogStorageSize.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.NotebookSize != nil {
		l = m.NotebookSize.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.MlservicesSize != nil {
		l = m.MlservicesSize.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItem_Resource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.OrganizationId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.OrganizationName)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.ProjectName)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.DeploymentName)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.DeploymentMemberName)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.CloudProviderId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.CloudRegionId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.SupportPlanId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.DeploymentModel)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.PrepaidDeploymentId)
	if l > 0 {
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.PrepaidDeploymentStartsAt != nil {
		l = m.PrepaidDeploymentStartsAt.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.PrepaidDeploymentEndsAt != nil {
		l = m.PrepaidDeploymentEndsAt.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if len(m.CreditBundleIds) > 0 {
		for _, s := range m.CreditBundleIds {
			l = len(s)
			n += 2 + l + sovUsage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItem_DeploymentSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coordinators != 0 {
		n += 1 + sovUsage(uint64(m.Coordinators))
	}
	if m.CoordinatorMemorySize != 0 {
		n += 1 + sovUsage(uint64(m.CoordinatorMemorySize))
	}
	if m.Dbservers != 0 {
		n += 1 + sovUsage(uint64(m.Dbservers))
	}
	if m.DbserverMemorySize != 0 {
		n += 1 + sovUsage(uint64(m.DbserverMemorySize))
	}
	if m.DbserverDiskSize != 0 {
		n += 1 + sovUsage(uint64(m.DbserverDiskSize))
	}
	if m.Agents != 0 {
		n += 2 + sovUsage(uint64(m.Agents))
	}
	if m.AgentMemorySize != 0 {
		n += 2 + sovUsage(uint64(m.AgentMemorySize))
	}
	if m.AgentDiskSize != 0 {
		n += 2 + sovUsage(uint64(m.AgentDiskSize))
	}
	l = len(m.NodeSizeId)
	if l > 0 {
		n += 2 + l + sovUsage(uint64(l))
	}
	l = len(m.DiskPerformanceId)
	if l > 0 {
		n += 2 + l + sovUsage(uint64(l))
	}
	if len(m.AddonIds) > 0 {
		for _, s := range m.AddonIds {
			l = len(s)
			n += 2 + l + sovUsage(uint64(l))
		}
	}
	if m.IsPaused {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItem_NetworkTransferSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destination)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.TotalTransferIngressSize != 0 {
		n += 1 + sovUsage(uint64(m.TotalTransferIngressSize))
	}
	if m.TotalTransferEgressSize != 0 {
		n += 1 + sovUsage(uint64(m.TotalTransferEgressSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItem_BackupStorageSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudStorageSize != 0 {
		n += 1 + sovUsage(uint64(m.CloudStorageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItem_AuditLogSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestinationType)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.EventCount != 0 {
		n += 1 + sovUsage(uint64(m.EventCount))
	}
	if m.EventSize != 0 {
		n += 1 + sovUsage(uint64(m.EventSize))
	}
	if m.HttpsPostCount != 0 {
		n += 2 + sovUsage(uint64(m.HttpsPostCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItem_AuditLogStorageSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CloudStorageSize != 0 {
		n += 1 + sovUsage(uint64(m.CloudStorageSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItem_NotebookSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuSize != 0 {
		n += 5
	}
	if m.MemorySize != 0 {
		n += 1 + sovUsage(uint64(m.MemorySize))
	}
	if m.DiskSize != 0 {
		n += 1 + sovUsage(uint64(m.DiskSize))
	}
	if m.IsPaused {
		n += 2
	}
	l = len(m.NotebookModelId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.GpuSize != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItem_MLServicesSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrainingApis != 0 {
		n += 1 + sovUsage(uint64(m.TrainingApis))
	}
	if m.TrainingApiMemorySize != 0 {
		n += 1 + sovUsage(uint64(m.TrainingApiMemorySize))
	}
	if m.TrainingApiCpuSize != 0 {
		n += 5
	}
	if m.PredictionApis != 0 {
		n += 1 + sovUsage(uint64(m.PredictionApis))
	}
	if m.PredictionApiMemorySize != 0 {
		n += 1 + sovUsage(uint64(m.PredictionApiMemorySize))
	}
	if m.PredictionApiCpuSize != 0 {
		n += 5
	}
	if m.ProjectsApis != 0 {
		n += 1 + sovUsage(uint64(m.ProjectsApis))
	}
	if m.ProjectsApiMemorySize != 0 {
		n += 1 + sovUsage(uint64(m.ProjectsApiMemorySize))
	}
	if m.ProjectsApiCpuSize != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UsageItemList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovUsage(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListUsageItemsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrganizationId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.SortDescending {
		n += 2
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.ResourceUrl)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.ResourceKind)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.NodeSizeId)
	if l > 0 {
		n += 1 + l + sovUsage(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.HasNoInvoiceId {
		n += 3
	}
	if m.HasInvoiceId {
		n += 3
	}
	l = len(m.InvoiceId)
	if l > 0 {
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.NotStartBefore != nil {
		l = m.NotStartBefore.Size()
		n += 2 + l + sovUsage(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovUsage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozUsage(x uint64) (n int) {
	return sovUsage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UsageItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &UsageItem_Resource{}
			}
			if err := m.Resource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartsAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartsAt == nil {
				m.StartsAt = &types.Timestamp{}
			}
			if err := m.StartsAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndsAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndsAt == nil {
				m.EndsAt = &types.Timestamp{}
			}
			if err := m.EndsAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasEnded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasEnded = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TierId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TierId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeploymentSize == nil {
				m.DeploymentSize = &UsageItem_DeploymentSize{}
			}
			if err := m.DeploymentSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkTransferSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NetworkTransferSize == nil {
				m.NetworkTransferSize = &UsageItem_NetworkTransferSize{}
			}
			if err := m.NetworkTransferSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupStorageSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackupStorageSize == nil {
				m.BackupStorageSize = &UsageItem_BackupStorageSize{}
			}
			if err := m.BackupStorageSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditlogSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuditlogSize == nil {
				m.AuditlogSize = &UsageItem_AuditLogSize{}
			}
			if err := m.AuditlogSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditlogStorageSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuditlogStorageSize == nil {
				m.AuditlogStorageSize = &UsageItem_AuditLogStorageSize{}
			}
			if err := m.AuditlogStorageSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotebookSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotebookSize == nil {
				m.NotebookSize = &UsageItem_NotebookSize{}
			}
			if err := m.NotebookSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MlservicesSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MlservicesSize == nil {
				m.MlservicesSize = &UsageItem_MLServicesSize{}
			}
			if err := m.MlservicesSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem_Resource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Resource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Resource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentMemberName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentMemberName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudRegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudRegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportPlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportPlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepaidDeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentStartsAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepaidDeploymentStartsAt == nil {
				m.PrepaidDeploymentStartsAt = &types.Timestamp{}
			}
			if err := m.PrepaidDeploymentStartsAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentEndsAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepaidDeploymentEndsAt == nil {
				m.PrepaidDeploymentEndsAt = &types.Timestamp{}
			}
			if err := m.PrepaidDeploymentEndsAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditBundleIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditBundleIds = append(m.CreditBundleIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem_DeploymentSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			m.Coordinators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coordinators |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			m.CoordinatorMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoordinatorMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			m.Dbservers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dbservers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			m.DbserverMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			m.DbserverDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agents", wireType)
			}
			m.Agents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Agents |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentMemorySize", wireType)
			}
			m.AgentMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentDiskSize", wireType)
			}
			m.AgentDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSizeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeSizeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskPerformanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskPerformanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddonIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddonIds = append(m.AddonIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPaused = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem_NetworkTransferSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkTransferSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkTransferSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destination", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destination = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTransferIngressSize", wireType)
			}
			m.TotalTransferIngressSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTransferIngressSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalTransferEgressSize", wireType)
			}
			m.TotalTransferEgressSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalTransferEgressSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem_BackupStorageSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupStorageSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupStorageSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudStorageSize", wireType)
			}
			m.CloudStorageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudStorageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem_AuditLogSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventCount", wireType)
			}
			m.EventCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventSize", wireType)
			}
			m.EventSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EventSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsPostCount", wireType)
			}
			m.HttpsPostCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HttpsPostCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem_AuditLogStorageSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogStorageSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogStorageSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudStorageSize", wireType)
			}
			m.CloudStorageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CloudStorageSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem_NotebookSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NotebookSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NotebookSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CpuSize = float32(math.Float32frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySize", wireType)
			}
			m.MemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSize", wireType)
			}
			m.DiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPaused = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotebookModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotebookModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GpuSize = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItem_MLServicesSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLServicesSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLServicesSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingApis", wireType)
			}
			m.TrainingApis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingApis |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingApiMemorySize", wireType)
			}
			m.TrainingApiMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrainingApiMemorySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrainingApiCpuSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.TrainingApiCpuSize = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictionApis", wireType)
			}
			m.PredictionApis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PredictionApis |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictionApiMemorySize", wireType)
			}
			m.PredictionApiMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PredictionApiMemorySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredictionApiCpuSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PredictionApiCpuSize = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectsApis", wireType)
			}
			m.ProjectsApis = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectsApis |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectsApiMemorySize", wireType)
			}
			m.ProjectsApiMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProjectsApiMemorySize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectsApiCpuSize", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ProjectsApiCpuSize = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageItemList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageItemList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageItemList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &UsageItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUsageItemsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUsageItemsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUsageItemsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &types.Timestamp{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &types.Timestamp{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SortDescending", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SortDescending = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceKind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSizeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeSizeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasNoInvoiceId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasNoInvoiceId = bool(v != 0)
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasInvoiceId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasInvoiceId = bool(v != 0)
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotStartBefore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthUsage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthUsage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NotStartBefore == nil {
				m.NotStartBefore = &types.Timestamp{}
			}
			if err := m.NotStartBefore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipUsage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthUsage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipUsage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowUsage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowUsage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthUsage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupUsage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthUsage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthUsage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowUsage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupUsage = fmt.Errorf("proto: unexpected end of group")
)
