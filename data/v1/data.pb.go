// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: data.proto

package v1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	v1 "github.com/arangodb-managed/apis/common/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// RotateDeploymentServerRequest request for rotating out servers for a deployment
type RotateDeploymentServerRequest struct {
	// The id of the deployment this server belongs to.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// The id of the server to rotate out.
	ServerId             string   `protobuf:"bytes,2,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RotateDeploymentServerRequest) Reset()         { *m = RotateDeploymentServerRequest{} }
func (m *RotateDeploymentServerRequest) String() string { return proto.CompactTextString(m) }
func (*RotateDeploymentServerRequest) ProtoMessage()    {}
func (*RotateDeploymentServerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{0}
}
func (m *RotateDeploymentServerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RotateDeploymentServerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RotateDeploymentServerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RotateDeploymentServerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RotateDeploymentServerRequest.Merge(m, src)
}
func (m *RotateDeploymentServerRequest) XXX_Size() int {
	return m.Size()
}
func (m *RotateDeploymentServerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RotateDeploymentServerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RotateDeploymentServerRequest proto.InternalMessageInfo

func (m *RotateDeploymentServerRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *RotateDeploymentServerRequest) GetServerId() string {
	if m != nil {
		return m.ServerId
	}
	return ""
}

// CreateTestDatabaseResponse will contain the json formatted output of the create operation
type CreateTestDatabaseResponse struct {
	// Name of the created database
	DbName string `protobuf:"bytes,1,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	// Username of the created user
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	// Password of the created user
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	// Hostname of the database
	Hostname string `protobuf:"bytes,4,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// Port of the database
	Port                 string   `protobuf:"bytes,5,opt,name=port,proto3" json:"port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateTestDatabaseResponse) Reset()         { *m = CreateTestDatabaseResponse{} }
func (m *CreateTestDatabaseResponse) String() string { return proto.CompactTextString(m) }
func (*CreateTestDatabaseResponse) ProtoMessage()    {}
func (*CreateTestDatabaseResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{1}
}
func (m *CreateTestDatabaseResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTestDatabaseResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTestDatabaseResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTestDatabaseResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTestDatabaseResponse.Merge(m, src)
}
func (m *CreateTestDatabaseResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateTestDatabaseResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTestDatabaseResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTestDatabaseResponse proto.InternalMessageInfo

func (m *CreateTestDatabaseResponse) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *CreateTestDatabaseResponse) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CreateTestDatabaseResponse) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *CreateTestDatabaseResponse) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *CreateTestDatabaseResponse) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

// Request arguments for CreateTestDatabase
type CreateTestDatabaseRequest struct {
	// The id of the deployment
	DeploymentId         string   `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateTestDatabaseRequest) Reset()         { *m = CreateTestDatabaseRequest{} }
func (m *CreateTestDatabaseRequest) String() string { return proto.CompactTextString(m) }
func (*CreateTestDatabaseRequest) ProtoMessage()    {}
func (*CreateTestDatabaseRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{2}
}
func (m *CreateTestDatabaseRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateTestDatabaseRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateTestDatabaseRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateTestDatabaseRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateTestDatabaseRequest.Merge(m, src)
}
func (m *CreateTestDatabaseRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateTestDatabaseRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateTestDatabaseRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateTestDatabaseRequest proto.InternalMessageInfo

func (m *CreateTestDatabaseRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

// RebalanceDeploymentShardsRequest request for rebalancing shards for a deployment
type RebalanceDeploymentShardsRequest struct {
	// The id of the deployment
	DeploymentId         string   `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RebalanceDeploymentShardsRequest) Reset()         { *m = RebalanceDeploymentShardsRequest{} }
func (m *RebalanceDeploymentShardsRequest) String() string { return proto.CompactTextString(m) }
func (*RebalanceDeploymentShardsRequest) ProtoMessage()    {}
func (*RebalanceDeploymentShardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{3}
}
func (m *RebalanceDeploymentShardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RebalanceDeploymentShardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RebalanceDeploymentShardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RebalanceDeploymentShardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RebalanceDeploymentShardsRequest.Merge(m, src)
}
func (m *RebalanceDeploymentShardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *RebalanceDeploymentShardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RebalanceDeploymentShardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RebalanceDeploymentShardsRequest proto.InternalMessageInfo

func (m *RebalanceDeploymentShardsRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

// A Deployment is represents one deployment of an ArangoDB cluster.
type Deployment struct {
	// System identifier of the deployment.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	// This is a read-only value.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// Name of the deployment
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the deployment
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Identifier of the project that owns this deployment.
	// After creation, this value cannot be changed.
	ProjectId string `protobuf:"bytes,5,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of the region in which the deployment is created.
	// After creation, this value cannot be changed.
	RegionId string `protobuf:"bytes,6,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// The creation timestamp of the deployment
	// This is a read-only value.
	CreatedAt *types.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The deletion timestamp of the deployment
	// This is a read-only value.
	DeletedAt *types.Timestamp `protobuf:"bytes,8,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Set when this deployment is deleted.
	// This is a read-only value.
	IsDeleted bool `protobuf:"varint,9,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// Optional identifier of the support plan selected for this deployment.
	// After creation, this value cannot be changed.
	// If no support plan identifier is set, the default support plan is used.
	SupportPlanId string `protobuf:"bytes,10,opt,name=support_plan_id,json=supportPlanId,proto3" json:"support_plan_id,omitempty"`
	// Identifier of the user who created this deployment.
	// This is a read-only value.
	CreatedById string `protobuf:"bytes,11,opt,name=created_by_id,json=createdById,proto3" json:"created_by_id,omitempty"`
	// This field must be set to the identifier of the current Terms&Conditions
	// when creating a deployment.
	// If the tier of the organization does not require a non-empty Terms&Condition
	// identifier, this field may be left empty.
	// This is a read-only value after creation.
	AcceptedTermsAndConditionsId string `protobuf:"bytes,12,opt,name=accepted_terms_and_conditions_id,json=acceptedTermsAndConditionsId,proto3" json:"accepted_terms_and_conditions_id,omitempty"`
	// If set, this deployment cannot be deleted.
	// To delete, first update the with locked set to false.
	Locked bool `protobuf:"varint,13,opt,name=locked,proto3" json:"locked,omitempty"`
	// Indicates that this deployment is paused.
	// Use the data.ResumeDeployment method to resume (aka unpause) the deployment.
	// This is a read-only value.
	IsPaused bool `protobuf:"varint,20,opt,name=is_paused,json=isPaused,proto3" json:"is_paused,omitempty"`
	// The last paused timestamp of the deployment.
	// This is the timestamp that is_paused is transitioned from unset to set.
	// This is a read-only value.
	LastPausedAt *types.Timestamp `protobuf:"bytes,21,opt,name=last_paused_at,json=lastPausedAt,proto3" json:"last_paused_at,omitempty"`
	// The last resumed  timestamp of the deployment.
	// This is the timestamp that is_paused is transitioned from set to unset.
	// This is a read-only value.
	LastResumedAt *types.Timestamp `protobuf:"bytes,22,opt,name=last_resumed_at,json=lastResumedAt,proto3" json:"last_resumed_at,omitempty"`
	// Identifier of the prepaid deployment that this deployment is attached to (if any).
	// This is a read-only value.
	PrepaidDeploymentId string `protobuf:"bytes,23,opt,name=prepaid_deployment_id,json=prepaidDeploymentId,proto3" json:"prepaid_deployment_id,omitempty"`
	// If set, authentication for Foxx requests is disabled.
	// Be default this field is not set for new deployments.
	DisableFoxxAuthentication bool `protobuf:"varint,24,opt,name=disable_foxx_authentication,json=disableFoxxAuthentication,proto3" json:"disable_foxx_authentication,omitempty"`
	// When the prepaid deployments starts (relevant when prepaid_deployment_id is set only)
	// This is a read-only value
	PrepaidDeploymentStartsAt *types.Timestamp `protobuf:"bytes,25,opt,name=prepaid_deployment_starts_at,json=prepaidDeploymentStartsAt,proto3" json:"prepaid_deployment_starts_at,omitempty"`
	// When the prepaid deployments ends (relevant when prepaid_deployment_id is set only)
	// This is a read-only value
	PrepaidDeploymentEndsAt *types.Timestamp `protobuf:"bytes,26,opt,name=prepaid_deployment_ends_at,json=prepaidDeploymentEndsAt,proto3" json:"prepaid_deployment_ends_at,omitempty"`
	// Whenever deployment can be updated to new values from prepaid deployment
	// This is a read-only value
	IsPrepaidDeploymentUpdateAvailable bool `protobuf:"varint,27,opt,name=is_prepaid_deployment_update_available,json=isPrepaidDeploymentUpdateAvailable,proto3" json:"is_prepaid_deployment_update_available,omitempty"`
	// Set if the deployment use a private endpoint.
	// This is a read-only value after creation.
	// If set during creation a private endpoint service will be created.
	PrivateEndpoint bool `protobuf:"varint,30,opt,name=private_endpoint,json=privateEndpoint,proto3" json:"private_endpoint,omitempty"`
	// ArangoDB version to use for this deployment.
	// See Version.version.
	// If you change this value to a higher version,
	// the deployment will be upgraded.
	// If you change this value to a lower patch value,
	// the deployment will be downgraded.
	// Any attempt to change to a lower minor or major version
	// is considered an invalid request.
	// Any attempt to change to a version that is not in the
	// list of available versions is considered an invalid request.
	Version string `protobuf:"bytes,101,opt,name=version,proto3" json:"version,omitempty"`
	// If set, this deployment will be upgraded to the ArangoDB release with the
	// version as listed in this field.
	ReplaceVersionBy *ReplaceVersionBy `protobuf:"bytes,104,opt,name=replace_version_by,json=replaceVersionBy,proto3" json:"replace_version_by,omitempty"`
	// If set, it is recommended to upgrade to the ArangoDB release with the
	// version as listed in this field.
	UpgradeRecommendation *UpgradeVersionRecommendation `protobuf:"bytes,105,opt,name=upgrade_recommendation,json=upgradeRecommendation,proto3" json:"upgrade_recommendation,omitempty"`
	Certificates          *Deployment_CertificateSpec   `protobuf:"bytes,102,opt,name=certificates,proto3" json:"certificates,omitempty"`
	Servers               *Deployment_ServersSpec       `protobuf:"bytes,103,opt,name=servers,proto3" json:"servers,omitempty"`
	// Optional identifier of IP allowlist to use for this deployment.
	IpallowlistId string                `protobuf:"bytes,109,opt,name=ipallowlist_id,json=ipallowlistId,proto3" json:"ipallowlist_id,omitempty"`
	Model         *Deployment_ModelSpec `protobuf:"bytes,106,opt,name=model,proto3" json:"model,omitempty"`
	// If provided, dataclusterd will use this custom image tag instead of the configured one for a given version.
	// Further, ImagePullPolicy will be set to Always.
	// This field can only be set by selected organizations.
	CustomImage string `protobuf:"bytes,107,opt,name=custom_image,json=customImage,proto3" json:"custom_image,omitempty"`
	// Optional identifier of IAM provider to use for this deployment.
	IamproviderId string             `protobuf:"bytes,108,opt,name=iamprovider_id,json=iamproviderId,proto3" json:"iamprovider_id,omitempty"`
	Status        *Deployment_Status `protobuf:"bytes,201,opt,name=status,proto3" json:"status,omitempty"`
	// Detailed size of the deployment
	// This is a read-only field.
	Size_      *DeploymentSize        `protobuf:"bytes,202,opt,name=size,proto3" json:"size,omitempty"`
	Expiration *Deployment_Expiration `protobuf:"bytes,301,opt,name=expiration,proto3" json:"expiration,omitempty"`
	// Information about a backup restore.
	// If this field is set the deployment will be restored to that backup.
	// This is a read-only field. To set this field please use the backup service RestoreBackup method.
	BackupRestore *Deployment_BackupRestoreSpec `protobuf:"bytes,401,opt,name=backup_restore,json=backupRestore,proto3" json:"backup_restore,omitempty"`
	// Recommendations made for deployments using the "oneshard" or "sharded" model.
	DeploymentRecommendations []*DeploymentSizeRecommendation `protobuf:"bytes,501,rep,name=deployment_recommendations,json=deploymentRecommendations,proto3" json:"deployment_recommendations,omitempty"`
	// Set if this deployment is a clone and should be handled differently. After bootstrapping a clone
	// needs a restore operation.
	// This is a read-only property
	IsClone bool `protobuf:"varint,600,opt,name=is_clone,json=isClone,proto3" json:"is_clone,omitempty"`
	// The ID of the backup to restore this clone deployment from.
	// This is a read-only property
	CloneBackupId string `protobuf:"bytes,601,opt,name=clone_backup_id,json=cloneBackupId,proto3" json:"clone_backup_id,omitempty"`
	// Email addresses that notifications related to the deployment should be sent to.
	NotificationEmailAddresses []string `protobuf:"bytes,610,rep,name=notification_email_addresses,json=notificationEmailAddresses,proto3" json:"notification_email_addresses,omitempty"`
	XXX_NoUnkeyedLiteral       struct{} `json:"-"`
	XXX_unrecognized           []byte   `json:"-"`
	XXX_sizecache              int32    `json:"-"`
}

func (m *Deployment) Reset()         { *m = Deployment{} }
func (m *Deployment) String() string { return proto.CompactTextString(m) }
func (*Deployment) ProtoMessage()    {}
func (*Deployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4}
}
func (m *Deployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment.Merge(m, src)
}
func (m *Deployment) XXX_Size() int {
	return m.Size()
}
func (m *Deployment) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment proto.InternalMessageInfo

func (m *Deployment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Deployment) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *Deployment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Deployment) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Deployment) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *Deployment) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *Deployment) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Deployment) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *Deployment) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *Deployment) GetSupportPlanId() string {
	if m != nil {
		return m.SupportPlanId
	}
	return ""
}

func (m *Deployment) GetCreatedById() string {
	if m != nil {
		return m.CreatedById
	}
	return ""
}

func (m *Deployment) GetAcceptedTermsAndConditionsId() string {
	if m != nil {
		return m.AcceptedTermsAndConditionsId
	}
	return ""
}

func (m *Deployment) GetLocked() bool {
	if m != nil {
		return m.Locked
	}
	return false
}

func (m *Deployment) GetIsPaused() bool {
	if m != nil {
		return m.IsPaused
	}
	return false
}

func (m *Deployment) GetLastPausedAt() *types.Timestamp {
	if m != nil {
		return m.LastPausedAt
	}
	return nil
}

func (m *Deployment) GetLastResumedAt() *types.Timestamp {
	if m != nil {
		return m.LastResumedAt
	}
	return nil
}

func (m *Deployment) GetPrepaidDeploymentId() string {
	if m != nil {
		return m.PrepaidDeploymentId
	}
	return ""
}

func (m *Deployment) GetDisableFoxxAuthentication() bool {
	if m != nil {
		return m.DisableFoxxAuthentication
	}
	return false
}

func (m *Deployment) GetPrepaidDeploymentStartsAt() *types.Timestamp {
	if m != nil {
		return m.PrepaidDeploymentStartsAt
	}
	return nil
}

func (m *Deployment) GetPrepaidDeploymentEndsAt() *types.Timestamp {
	if m != nil {
		return m.PrepaidDeploymentEndsAt
	}
	return nil
}

func (m *Deployment) GetIsPrepaidDeploymentUpdateAvailable() bool {
	if m != nil {
		return m.IsPrepaidDeploymentUpdateAvailable
	}
	return false
}

func (m *Deployment) GetPrivateEndpoint() bool {
	if m != nil {
		return m.PrivateEndpoint
	}
	return false
}

func (m *Deployment) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Deployment) GetReplaceVersionBy() *ReplaceVersionBy {
	if m != nil {
		return m.ReplaceVersionBy
	}
	return nil
}

func (m *Deployment) GetUpgradeRecommendation() *UpgradeVersionRecommendation {
	if m != nil {
		return m.UpgradeRecommendation
	}
	return nil
}

func (m *Deployment) GetCertificates() *Deployment_CertificateSpec {
	if m != nil {
		return m.Certificates
	}
	return nil
}

func (m *Deployment) GetServers() *Deployment_ServersSpec {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *Deployment) GetIpallowlistId() string {
	if m != nil {
		return m.IpallowlistId
	}
	return ""
}

func (m *Deployment) GetModel() *Deployment_ModelSpec {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *Deployment) GetCustomImage() string {
	if m != nil {
		return m.CustomImage
	}
	return ""
}

func (m *Deployment) GetIamproviderId() string {
	if m != nil {
		return m.IamproviderId
	}
	return ""
}

func (m *Deployment) GetStatus() *Deployment_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Deployment) GetSize_() *DeploymentSize {
	if m != nil {
		return m.Size_
	}
	return nil
}

func (m *Deployment) GetExpiration() *Deployment_Expiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *Deployment) GetBackupRestore() *Deployment_BackupRestoreSpec {
	if m != nil {
		return m.BackupRestore
	}
	return nil
}

func (m *Deployment) GetDeploymentRecommendations() []*DeploymentSizeRecommendation {
	if m != nil {
		return m.DeploymentRecommendations
	}
	return nil
}

func (m *Deployment) GetIsClone() bool {
	if m != nil {
		return m.IsClone
	}
	return false
}

func (m *Deployment) GetCloneBackupId() string {
	if m != nil {
		return m.CloneBackupId
	}
	return ""
}

func (m *Deployment) GetNotificationEmailAddresses() []string {
	if m != nil {
		return m.NotificationEmailAddresses
	}
	return nil
}

type Deployment_CertificateSpec struct {
	// Identifier of the CACertificate used to sign TLS certificates for the deployment.
	// If you change this value after the creation of the deployment a complete
	// rotation of the deployment is required, which will result in some downtime.
	CaCertificateId string `protobuf:"bytes,1,opt,name=ca_certificate_id,json=caCertificateId,proto3" json:"ca_certificate_id,omitempty"`
	// Zero or more DNS names to include in the TLS certificate of the deployment.
	AlternateDnsNames    []string `protobuf:"bytes,2,rep,name=alternate_dns_names,json=alternateDnsNames,proto3" json:"alternate_dns_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_CertificateSpec) Reset()         { *m = Deployment_CertificateSpec{} }
func (m *Deployment_CertificateSpec) String() string { return proto.CompactTextString(m) }
func (*Deployment_CertificateSpec) ProtoMessage()    {}
func (*Deployment_CertificateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4, 0}
}
func (m *Deployment_CertificateSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_CertificateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_CertificateSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_CertificateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_CertificateSpec.Merge(m, src)
}
func (m *Deployment_CertificateSpec) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_CertificateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_CertificateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_CertificateSpec proto.InternalMessageInfo

func (m *Deployment_CertificateSpec) GetCaCertificateId() string {
	if m != nil {
		return m.CaCertificateId
	}
	return ""
}

func (m *Deployment_CertificateSpec) GetAlternateDnsNames() []string {
	if m != nil {
		return m.AlternateDnsNames
	}
	return nil
}

type Deployment_ServersSpec struct {
	// Number of coordinators of the deployment
	// This field is automatically set unless the flexible model is used.
	Coordinators int32 `protobuf:"varint,1,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Amount of memory (in GB) to allocate for coordinators.
	// This field is automatically set unless the flexible model is used.
	CoordinatorMemorySize int32 `protobuf:"varint,2,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Custom command line arguments passed to all coordinators.
	// This field is ignored set unless the flexible model is used.
	CoordinatorArgs []string `protobuf:"bytes,3,rep,name=coordinator_args,json=coordinatorArgs,proto3" json:"coordinator_args,omitempty"`
	// Number of dbservers of the deployment
	// This field is automatically set unless the flexible model is used.
	Dbservers int32 `protobuf:"varint,11,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Amount of memory (in GB) to allocate for dbservers.
	// This field is automatically set unless the flexible model is used.
	DbserverMemorySize int32 `protobuf:"varint,12,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for dbservers.
	// This field is automatically set unless the flexible model is used.
	DbserverDiskSize int32 `protobuf:"varint,13,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	// Custom command line arguments passed to all dbservers.
	// This field is ignored set unless the flexible model is used.
	DbserverArgs []string `protobuf:"bytes,14,rep,name=dbserver_args,json=dbserverArgs,proto3" json:"dbserver_args,omitempty"`
	// The minimum number of dbservers based on the highest replication factor
	// defined by all databases and all collections.
	MinimumDbserversCount int32    `protobuf:"varint,15,opt,name=minimum_dbservers_count,json=minimumDbserversCount,proto3" json:"minimum_dbservers_count,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *Deployment_ServersSpec) Reset()         { *m = Deployment_ServersSpec{} }
func (m *Deployment_ServersSpec) String() string { return proto.CompactTextString(m) }
func (*Deployment_ServersSpec) ProtoMessage()    {}
func (*Deployment_ServersSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4, 1}
}
func (m *Deployment_ServersSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_ServersSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_ServersSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_ServersSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_ServersSpec.Merge(m, src)
}
func (m *Deployment_ServersSpec) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_ServersSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_ServersSpec.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_ServersSpec proto.InternalMessageInfo

func (m *Deployment_ServersSpec) GetCoordinators() int32 {
	if m != nil {
		return m.Coordinators
	}
	return 0
}

func (m *Deployment_ServersSpec) GetCoordinatorMemorySize() int32 {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return 0
}

func (m *Deployment_ServersSpec) GetCoordinatorArgs() []string {
	if m != nil {
		return m.CoordinatorArgs
	}
	return nil
}

func (m *Deployment_ServersSpec) GetDbservers() int32 {
	if m != nil {
		return m.Dbservers
	}
	return 0
}

func (m *Deployment_ServersSpec) GetDbserverMemorySize() int32 {
	if m != nil {
		return m.DbserverMemorySize
	}
	return 0
}

func (m *Deployment_ServersSpec) GetDbserverDiskSize() int32 {
	if m != nil {
		return m.DbserverDiskSize
	}
	return 0
}

func (m *Deployment_ServersSpec) GetDbserverArgs() []string {
	if m != nil {
		return m.DbserverArgs
	}
	return nil
}

func (m *Deployment_ServersSpec) GetMinimumDbserversCount() int32 {
	if m != nil {
		return m.MinimumDbserversCount
	}
	return 0
}

type Deployment_ModelSpec struct {
	// Type of model being used
	Model string `protobuf:"bytes,1,opt,name=model,proto3" json:"model,omitempty"`
	// Size of nodes being used
	// This field is ignored set in case the flexible model is used.
	NodeSizeId string `protobuf:"bytes,2,opt,name=node_size_id,json=nodeSizeId,proto3" json:"node_size_id,omitempty"`
	// Number of nodes being used
	// This field is ignored set in case the flexible model is used.
	NodeCount int32 `protobuf:"varint,3,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Amount of disk space per node (in GB)
	// This field is ignored set in case the flexible model is used.
	NodeDiskSize         int32    `protobuf:"varint,4,opt,name=node_disk_size,json=nodeDiskSize,proto3" json:"node_disk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_ModelSpec) Reset()         { *m = Deployment_ModelSpec{} }
func (m *Deployment_ModelSpec) String() string { return proto.CompactTextString(m) }
func (*Deployment_ModelSpec) ProtoMessage()    {}
func (*Deployment_ModelSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4, 2}
}
func (m *Deployment_ModelSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_ModelSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_ModelSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_ModelSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_ModelSpec.Merge(m, src)
}
func (m *Deployment_ModelSpec) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_ModelSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_ModelSpec.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_ModelSpec proto.InternalMessageInfo

func (m *Deployment_ModelSpec) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *Deployment_ModelSpec) GetNodeSizeId() string {
	if m != nil {
		return m.NodeSizeId
	}
	return ""
}

func (m *Deployment_ModelSpec) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *Deployment_ModelSpec) GetNodeDiskSize() int32 {
	if m != nil {
		return m.NodeDiskSize
	}
	return 0
}

// Status of a single server (of the ArangoDB cluster)
type Deployment_ServerStatus struct {
	// ID of the server
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Type of server (agent|coordinator|dbserver)
	Type string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// Human readable description of the status of the deployment.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// The creation timestamp of the server
	CreatedAt *types.Timestamp `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Set once the server is ready
	Ready bool `protobuf:"varint,5,opt,name=ready,proto3" json:"ready,omitempty"`
	// Set once the server has been known to be a member of the cluster
	MemberOfCluster bool `protobuf:"varint,6,opt,name=member_of_cluster,json=memberOfCluster,proto3" json:"member_of_cluster,omitempty"`
	// Set if the server is in a failed state
	// Every server is always in 1 (and only 1) of these states: failed/creating/ok/bad/upgrading.
	Failed bool `protobuf:"varint,7,opt,name=failed,proto3" json:"failed,omitempty"`
	// Set if the server is still being created
	// Every server is always in 1 (and only 1) of these states: failed/creating/ok/bad/upgrading.
	Creating bool `protobuf:"varint,8,opt,name=creating,proto3" json:"creating,omitempty"`
	// Set if the server is in the ok state.
	// Every server is always in 1 (and only 1) of these states: failed/creating/ok/bad/upgrading.
	Ok bool `protobuf:"varint,9,opt,name=ok,proto3" json:"ok,omitempty"`
	// Set if the server is in the bad state.
	// Every server is always in 1 (and only 1) of these states: failed/creating/ok/bad/upgrading.
	Bad bool `protobuf:"varint,14,opt,name=bad,proto3" json:"bad,omitempty"`
	// Set if the server is still being upgraded
	// Every server is always in 1 (and only 1) of these states: failed/creating/ok/bad/upgrading.
	Upgrading bool `protobuf:"varint,10,opt,name=upgrading,proto3" json:"upgrading,omitempty"`
	// Latest known ArangoDB version used by this server.
	// Initially this field is empty.
	Version string `protobuf:"bytes,11,opt,name=version,proto3" json:"version,omitempty"`
	// The last started timestamp of the server
	LastStartedAt *types.Timestamp `protobuf:"bytes,12,opt,name=last_started_at,json=lastStartedAt,proto3" json:"last_started_at,omitempty"`
	// If set, a rotation of this server has been requested.
	RotationPending bool `protobuf:"varint,13,opt,name=rotation_pending,json=rotationPending,proto3" json:"rotation_pending,omitempty"`
	// If set, this server reports that it can be deleted.
	CanBeDeleted bool `protobuf:"varint,15,opt,name=can_be_deleted,json=canBeDeleted,proto3" json:"can_be_deleted,omitempty"`
	// If set, this server is leader in its type (currently applies only to agents).
	IsLeader bool `protobuf:"varint,16,opt,name=is_leader,json=isLeader,proto3" json:"is_leader,omitempty"`
	// Information about the data volume used to store the data
	DataVolumeInfo *DataVolumeInfo `protobuf:"bytes,20,opt,name=data_volume_info,json=dataVolumeInfo,proto3" json:"data_volume_info,omitempty"`
	// Recent number of restarts
	RecentRestarts int32 `protobuf:"varint,30,opt,name=recent_restarts,json=recentRestarts,proto3" json:"recent_restarts,omitempty"`
	// Last known memory usage in bytes
	LastMemoryUsage int64 `protobuf:"varint,31,opt,name=last_memory_usage,json=lastMemoryUsage,proto3" json:"last_memory_usage,omitempty"`
	// Last known CPU usage in vCPU units
	LastCpuUsage float32 `protobuf:"fixed32,32,opt,name=last_cpu_usage,json=lastCpuUsage,proto3" json:"last_cpu_usage,omitempty"`
	// Last known memory limit in bytes
	LastMemoryLimit int64 `protobuf:"varint,33,opt,name=last_memory_limit,json=lastMemoryLimit,proto3" json:"last_memory_limit,omitempty"`
	// Last known CPU limit in vCPU units
	LastCpuLimit         float32  `protobuf:"fixed32,34,opt,name=last_cpu_limit,json=lastCpuLimit,proto3" json:"last_cpu_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_ServerStatus) Reset()         { *m = Deployment_ServerStatus{} }
func (m *Deployment_ServerStatus) String() string { return proto.CompactTextString(m) }
func (*Deployment_ServerStatus) ProtoMessage()    {}
func (*Deployment_ServerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4, 3}
}
func (m *Deployment_ServerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_ServerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_ServerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_ServerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_ServerStatus.Merge(m, src)
}
func (m *Deployment_ServerStatus) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_ServerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_ServerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_ServerStatus proto.InternalMessageInfo

func (m *Deployment_ServerStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Deployment_ServerStatus) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Deployment_ServerStatus) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Deployment_ServerStatus) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Deployment_ServerStatus) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *Deployment_ServerStatus) GetMemberOfCluster() bool {
	if m != nil {
		return m.MemberOfCluster
	}
	return false
}

func (m *Deployment_ServerStatus) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *Deployment_ServerStatus) GetCreating() bool {
	if m != nil {
		return m.Creating
	}
	return false
}

func (m *Deployment_ServerStatus) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *Deployment_ServerStatus) GetBad() bool {
	if m != nil {
		return m.Bad
	}
	return false
}

func (m *Deployment_ServerStatus) GetUpgrading() bool {
	if m != nil {
		return m.Upgrading
	}
	return false
}

func (m *Deployment_ServerStatus) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Deployment_ServerStatus) GetLastStartedAt() *types.Timestamp {
	if m != nil {
		return m.LastStartedAt
	}
	return nil
}

func (m *Deployment_ServerStatus) GetRotationPending() bool {
	if m != nil {
		return m.RotationPending
	}
	return false
}

func (m *Deployment_ServerStatus) GetCanBeDeleted() bool {
	if m != nil {
		return m.CanBeDeleted
	}
	return false
}

func (m *Deployment_ServerStatus) GetIsLeader() bool {
	if m != nil {
		return m.IsLeader
	}
	return false
}

func (m *Deployment_ServerStatus) GetDataVolumeInfo() *DataVolumeInfo {
	if m != nil {
		return m.DataVolumeInfo
	}
	return nil
}

func (m *Deployment_ServerStatus) GetRecentRestarts() int32 {
	if m != nil {
		return m.RecentRestarts
	}
	return 0
}

func (m *Deployment_ServerStatus) GetLastMemoryUsage() int64 {
	if m != nil {
		return m.LastMemoryUsage
	}
	return 0
}

func (m *Deployment_ServerStatus) GetLastCpuUsage() float32 {
	if m != nil {
		return m.LastCpuUsage
	}
	return 0
}

func (m *Deployment_ServerStatus) GetLastMemoryLimit() int64 {
	if m != nil {
		return m.LastMemoryLimit
	}
	return 0
}

func (m *Deployment_ServerStatus) GetLastCpuLimit() float32 {
	if m != nil {
		return m.LastCpuLimit
	}
	return 0
}

// Status of the deployment
// All members of this field are read-only.
type Deployment_Status struct {
	// Endpoint URL used to reach the deployment
	// This value will be empty during the creation of the deployment.
	// This field always contains the URL of the low port (8529) of the
	// deployment.
	// If a certificate with well known certificate is used, this
	// port is using the well known certificate.
	// Otherwise this port is using the self-signed certificate.
	// This endpoint is recommended for human-to-database connections.
	Endpoint string `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Human readable description of the status of the deployment.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Set once the deployment has been created.
	Created bool `protobuf:"varint,3,opt,name=created,proto3" json:"created,omitempty"`
	// Set if the deployment is ready to be used.
	// If the deployment has downtime (e.g. because of changing a CA certificate)
	// this will go to false until the downtime is over.
	Ready bool `protobuf:"varint,4,opt,name=ready,proto3" json:"ready,omitempty"`
	// Set if the deployment is being upgraded.
	Upgrading bool `protobuf:"varint,5,opt,name=upgrading,proto3" json:"upgrading,omitempty"`
	// Versions of running servers
	ServerVersions []string `protobuf:"bytes,6,rep,name=server_versions,json=serverVersions,proto3" json:"server_versions,omitempty"`
	// Status of individual servers of the deployment
	Servers []*Deployment_ServerStatus `protobuf:"bytes,7,rep,name=servers,proto3" json:"servers,omitempty"`
	// Set if the ready boolean is transitioned to true for the very first time.
	BootstrappedAt *types.Timestamp `protobuf:"bytes,8,opt,name=bootstrapped_at,json=bootstrappedAt,proto3" json:"bootstrapped_at,omitempty"`
	// Set if bootstrapped_at has a value, otherwise false.
	Bootstrapped bool `protobuf:"varint,9,opt,name=bootstrapped,proto3" json:"bootstrapped,omitempty"`
	// Endpoint URL used to reach the deployment on the port that uses
	// the self-signed certificate.
	// This endpoint is recommended for machine-to-database connections.
	EndpointSelfSigned string `protobuf:"bytes,10,opt,name=endpoint_self_signed,json=endpointSelfSigned,proto3" json:"endpoint_self_signed,omitempty"`
	// The status of backup restore (if applicable).
	// This field will be set to empty if a new revision of the spec is available
	BackupRestoreStatus *Deployment_BackupRestoreStatus `protobuf:"bytes,100,opt,name=backup_restore_status,json=backupRestoreStatus,proto3" json:"backup_restore_status,omitempty"`
	// The total size of all backups in the external source (in bytes)
	TotalBackupSizeBytes int64 `protobuf:"varint,101,opt,name=total_backup_size_bytes,json=totalBackupSizeBytes,proto3" json:"total_backup_size_bytes,omitempty"`
	// Set if there is any backup currently uploading data to the external source
	BackupUploadInProgress bool     `protobuf:"varint,102,opt,name=backup_upload_in_progress,json=backupUploadInProgress,proto3" json:"backup_upload_in_progress,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *Deployment_Status) Reset()         { *m = Deployment_Status{} }
func (m *Deployment_Status) String() string { return proto.CompactTextString(m) }
func (*Deployment_Status) ProtoMessage()    {}
func (*Deployment_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4, 4}
}
func (m *Deployment_Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_Status.Merge(m, src)
}
func (m *Deployment_Status) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_Status.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_Status proto.InternalMessageInfo

func (m *Deployment_Status) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Deployment_Status) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Deployment_Status) GetCreated() bool {
	if m != nil {
		return m.Created
	}
	return false
}

func (m *Deployment_Status) GetReady() bool {
	if m != nil {
		return m.Ready
	}
	return false
}

func (m *Deployment_Status) GetUpgrading() bool {
	if m != nil {
		return m.Upgrading
	}
	return false
}

func (m *Deployment_Status) GetServerVersions() []string {
	if m != nil {
		return m.ServerVersions
	}
	return nil
}

func (m *Deployment_Status) GetServers() []*Deployment_ServerStatus {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *Deployment_Status) GetBootstrappedAt() *types.Timestamp {
	if m != nil {
		return m.BootstrappedAt
	}
	return nil
}

func (m *Deployment_Status) GetBootstrapped() bool {
	if m != nil {
		return m.Bootstrapped
	}
	return false
}

func (m *Deployment_Status) GetEndpointSelfSigned() string {
	if m != nil {
		return m.EndpointSelfSigned
	}
	return ""
}

func (m *Deployment_Status) GetBackupRestoreStatus() *Deployment_BackupRestoreStatus {
	if m != nil {
		return m.BackupRestoreStatus
	}
	return nil
}

func (m *Deployment_Status) GetTotalBackupSizeBytes() int64 {
	if m != nil {
		return m.TotalBackupSizeBytes
	}
	return 0
}

func (m *Deployment_Status) GetBackupUploadInProgress() bool {
	if m != nil {
		return m.BackupUploadInProgress
	}
	return false
}

// The status of backup restore
// All members of this message are read-only.
type Deployment_BackupRestoreStatus struct {
	// The revision of the used BackupRestoreSpec
	Revision int32 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// Set if the deployment is preparing or restoring a backup
	Restoring bool `protobuf:"varint,10,opt,name=restoring,proto3" json:"restoring,omitempty"`
	// Status of the restore backup operation.
	// Enum of the following values: "<empty>|Preparing|Restoring|Restored|Failed"
	Status string `protobuf:"bytes,11,opt,name=status,proto3" json:"status,omitempty"`
	// Failure reason of the backup restore (if applicable)
	FailureReason        string   `protobuf:"bytes,12,opt,name=failure_reason,json=failureReason,proto3" json:"failure_reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_BackupRestoreStatus) Reset()         { *m = Deployment_BackupRestoreStatus{} }
func (m *Deployment_BackupRestoreStatus) String() string { return proto.CompactTextString(m) }
func (*Deployment_BackupRestoreStatus) ProtoMessage()    {}
func (*Deployment_BackupRestoreStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4, 5}
}
func (m *Deployment_BackupRestoreStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_BackupRestoreStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_BackupRestoreStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_BackupRestoreStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_BackupRestoreStatus.Merge(m, src)
}
func (m *Deployment_BackupRestoreStatus) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_BackupRestoreStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_BackupRestoreStatus.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_BackupRestoreStatus proto.InternalMessageInfo

func (m *Deployment_BackupRestoreStatus) GetRevision() int32 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *Deployment_BackupRestoreStatus) GetRestoring() bool {
	if m != nil {
		return m.Restoring
	}
	return false
}

func (m *Deployment_BackupRestoreStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Deployment_BackupRestoreStatus) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

// Expiration of the deployment.
// All members of this message are read-only.
type Deployment_Expiration struct {
	// The expiration timestamp of the deployment
	// If not set, the deployment will not expire.
	ExpiresAt *types.Timestamp `protobuf:"bytes,1,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	// Human readable reason for why the deployment expires (or does not expire).
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	// The timestamp of when the last "this deployment will expire at" email was
	// send.
	// If not set, no such email has been send.
	LastWarningEmailSendAt *types.Timestamp `protobuf:"bytes,3,opt,name=last_warning_email_send_at,json=lastWarningEmailSendAt,proto3" json:"last_warning_email_send_at,omitempty"`
	// List of email addresses to which the last warning email has been send.
	// Not set when no such email has been send.
	LastWarningEmailSendTo []string `protobuf:"bytes,4,rep,name=last_warning_email_send_to,json=lastWarningEmailSendTo,proto3" json:"last_warning_email_send_to,omitempty"`
	XXX_NoUnkeyedLiteral   struct{} `json:"-"`
	XXX_unrecognized       []byte   `json:"-"`
	XXX_sizecache          int32    `json:"-"`
}

func (m *Deployment_Expiration) Reset()         { *m = Deployment_Expiration{} }
func (m *Deployment_Expiration) String() string { return proto.CompactTextString(m) }
func (*Deployment_Expiration) ProtoMessage()    {}
func (*Deployment_Expiration) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4, 6}
}
func (m *Deployment_Expiration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_Expiration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_Expiration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_Expiration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_Expiration.Merge(m, src)
}
func (m *Deployment_Expiration) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_Expiration) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_Expiration.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_Expiration proto.InternalMessageInfo

func (m *Deployment_Expiration) GetExpiresAt() *types.Timestamp {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

func (m *Deployment_Expiration) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *Deployment_Expiration) GetLastWarningEmailSendAt() *types.Timestamp {
	if m != nil {
		return m.LastWarningEmailSendAt
	}
	return nil
}

func (m *Deployment_Expiration) GetLastWarningEmailSendTo() []string {
	if m != nil {
		return m.LastWarningEmailSendTo
	}
	return nil
}

// Information about a backup restore.
// All members of this message are read-only.
type Deployment_BackupRestoreSpec struct {
	// The revision of this BackupRestoreSpec
	Revision int32 `protobuf:"varint,1,opt,name=revision,proto3" json:"revision,omitempty"`
	// The timestamp of when the last revision has been updated.
	LastUpdatedAt *types.Timestamp `protobuf:"bytes,2,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at,omitempty"`
	// Identifier of a backup to restore to.
	BackupId             string   `protobuf:"bytes,10,opt,name=backup_id,json=backupId,proto3" json:"backup_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Deployment_BackupRestoreSpec) Reset()         { *m = Deployment_BackupRestoreSpec{} }
func (m *Deployment_BackupRestoreSpec) String() string { return proto.CompactTextString(m) }
func (*Deployment_BackupRestoreSpec) ProtoMessage()    {}
func (*Deployment_BackupRestoreSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{4, 7}
}
func (m *Deployment_BackupRestoreSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deployment_BackupRestoreSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deployment_BackupRestoreSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deployment_BackupRestoreSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deployment_BackupRestoreSpec.Merge(m, src)
}
func (m *Deployment_BackupRestoreSpec) XXX_Size() int {
	return m.Size()
}
func (m *Deployment_BackupRestoreSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_Deployment_BackupRestoreSpec.DiscardUnknown(m)
}

var xxx_messageInfo_Deployment_BackupRestoreSpec proto.InternalMessageInfo

func (m *Deployment_BackupRestoreSpec) GetRevision() int32 {
	if m != nil {
		return m.Revision
	}
	return 0
}

func (m *Deployment_BackupRestoreSpec) GetLastUpdatedAt() *types.Timestamp {
	if m != nil {
		return m.LastUpdatedAt
	}
	return nil
}

func (m *Deployment_BackupRestoreSpec) GetBackupId() string {
	if m != nil {
		return m.BackupId
	}
	return ""
}

// NodeSize specifies the size constraints of different data nodes.
type NodeSize struct {
	// System identifier of the node size
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable name of the node size
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Amount of memory (in GB) that is available on this size of node.
	MemorySize int32 `protobuf:"varint,3,opt,name=memory_size,json=memorySize,proto3" json:"memory_size,omitempty"`
	// Minimum amount of disk (in GB) that is available on this size of node.
	MinDiskSize int32 `protobuf:"varint,4,opt,name=min_disk_size,json=minDiskSize,proto3" json:"min_disk_size,omitempty"`
	// Maximum amount of disk (in GB) that is available on this size of node.
	MaxDiskSize int32 `protobuf:"varint,5,opt,name=max_disk_size,json=maxDiskSize,proto3" json:"max_disk_size,omitempty"`
	// CPU size that is available on this size of node (e.g. standard or high).
	CpuSize string `protobuf:"bytes,6,opt,name=cpu_size,json=cpuSize,proto3" json:"cpu_size,omitempty"`
	// If set, contains list of possible disk sizes (in GB) for the node.
	// In that case, this field overrides the min_disk_size & max_disk_size fields.
	DiskSizes            []int32  `protobuf:"varint,7,rep,packed,name=disk_sizes,json=diskSizes,proto3" json:"disk_sizes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeSize) Reset()         { *m = NodeSize{} }
func (m *NodeSize) String() string { return proto.CompactTextString(m) }
func (*NodeSize) ProtoMessage()    {}
func (*NodeSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{5}
}
func (m *NodeSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeSize.Merge(m, src)
}
func (m *NodeSize) XXX_Size() int {
	return m.Size()
}
func (m *NodeSize) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeSize.DiscardUnknown(m)
}

var xxx_messageInfo_NodeSize proto.InternalMessageInfo

func (m *NodeSize) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeSize) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeSize) GetMemorySize() int32 {
	if m != nil {
		return m.MemorySize
	}
	return 0
}

func (m *NodeSize) GetMinDiskSize() int32 {
	if m != nil {
		return m.MinDiskSize
	}
	return 0
}

func (m *NodeSize) GetMaxDiskSize() int32 {
	if m != nil {
		return m.MaxDiskSize
	}
	return 0
}

func (m *NodeSize) GetCpuSize() string {
	if m != nil {
		return m.CpuSize
	}
	return ""
}

func (m *NodeSize) GetDiskSizes() []int32 {
	if m != nil {
		return m.DiskSizes
	}
	return nil
}

// List of node sizes.
type NodeSizeList struct {
	Items                []*NodeSize `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *NodeSizeList) Reset()         { *m = NodeSizeList{} }
func (m *NodeSizeList) String() string { return proto.CompactTextString(m) }
func (*NodeSizeList) ProtoMessage()    {}
func (*NodeSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{6}
}
func (m *NodeSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeSizeList.Merge(m, src)
}
func (m *NodeSizeList) XXX_Size() int {
	return m.Size()
}
func (m *NodeSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_NodeSizeList proto.InternalMessageInfo

func (m *NodeSizeList) GetItems() []*NodeSize {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request arguments for ListNodeSizes
type NodeSizesRequest struct {
	// Identifier of project that will own a deployment.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of a region in which a deployment will be created.
	RegionId string `protobuf:"bytes,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// If set, project_id & region_id will be taken from this deployment.
	// This also causes the node_size used by this deployment to be included
	// in the result, if it it would not match for new deployments.
	DeploymentId string `protobuf:"bytes,3,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Identifier of a model of a new deployment will be created.
	// If set, all node sizes available for this model will be returned,
	// otherwise only node sizes that have no restrictions on model will be returned.
	Model                string   `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeSizesRequest) Reset()         { *m = NodeSizesRequest{} }
func (m *NodeSizesRequest) String() string { return proto.CompactTextString(m) }
func (*NodeSizesRequest) ProtoMessage()    {}
func (*NodeSizesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{7}
}
func (m *NodeSizesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeSizesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeSizesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeSizesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeSizesRequest.Merge(m, src)
}
func (m *NodeSizesRequest) XXX_Size() int {
	return m.Size()
}
func (m *NodeSizesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeSizesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_NodeSizesRequest proto.InternalMessageInfo

func (m *NodeSizesRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *NodeSizesRequest) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *NodeSizesRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *NodeSizesRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

// DeploymentModel specifies the a specific model of deploying
// arangodb clusters.
type DeploymentModel struct {
	// System identifier of the model (e.g. oneshard)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable name of the model (e.g. One shard)
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentModel) Reset()         { *m = DeploymentModel{} }
func (m *DeploymentModel) String() string { return proto.CompactTextString(m) }
func (*DeploymentModel) ProtoMessage()    {}
func (*DeploymentModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{8}
}
func (m *DeploymentModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentModel.Merge(m, src)
}
func (m *DeploymentModel) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentModel) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentModel.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentModel proto.InternalMessageInfo

func (m *DeploymentModel) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DeploymentModel) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// List of deployment models.
type DeploymentModelList struct {
	Items                []*DeploymentModel `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DeploymentModelList) Reset()         { *m = DeploymentModelList{} }
func (m *DeploymentModelList) String() string { return proto.CompactTextString(m) }
func (*DeploymentModelList) ProtoMessage()    {}
func (*DeploymentModelList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{9}
}
func (m *DeploymentModelList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentModelList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentModelList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentModelList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentModelList.Merge(m, src)
}
func (m *DeploymentModelList) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentModelList) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentModelList.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentModelList proto.InternalMessageInfo

func (m *DeploymentModelList) GetItems() []*DeploymentModel {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request arguments for ListDeploymentModels
type ListDeploymentModelsRequest struct {
	// Identifier of project that will own a deployment.
	ProjectId            string   `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDeploymentModelsRequest) Reset()         { *m = ListDeploymentModelsRequest{} }
func (m *ListDeploymentModelsRequest) String() string { return proto.CompactTextString(m) }
func (*ListDeploymentModelsRequest) ProtoMessage()    {}
func (*ListDeploymentModelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{10}
}
func (m *ListDeploymentModelsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDeploymentModelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDeploymentModelsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDeploymentModelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDeploymentModelsRequest.Merge(m, src)
}
func (m *ListDeploymentModelsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListDeploymentModelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDeploymentModelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDeploymentModelsRequest proto.InternalMessageInfo

func (m *ListDeploymentModelsRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

// CPUSize specifies the a specific level of CPU for a node.
type CPUSize struct {
	// System identifier of the size (e.g. standard)
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human readable name of the size (e.g. Standard)
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CPUSize) Reset()         { *m = CPUSize{} }
func (m *CPUSize) String() string { return proto.CompactTextString(m) }
func (*CPUSize) ProtoMessage()    {}
func (*CPUSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{11}
}
func (m *CPUSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUSize.Merge(m, src)
}
func (m *CPUSize) XXX_Size() int {
	return m.Size()
}
func (m *CPUSize) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUSize.DiscardUnknown(m)
}

var xxx_messageInfo_CPUSize proto.InternalMessageInfo

func (m *CPUSize) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *CPUSize) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// List of CPU sizes.
type CPUSizeList struct {
	Items                []*CPUSize `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CPUSizeList) Reset()         { *m = CPUSizeList{} }
func (m *CPUSizeList) String() string { return proto.CompactTextString(m) }
func (*CPUSizeList) ProtoMessage()    {}
func (*CPUSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{12}
}
func (m *CPUSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CPUSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CPUSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CPUSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CPUSizeList.Merge(m, src)
}
func (m *CPUSizeList) XXX_Size() int {
	return m.Size()
}
func (m *CPUSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_CPUSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_CPUSizeList proto.InternalMessageInfo

func (m *CPUSizeList) GetItems() []*CPUSize {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request arguments for ListCPUSizes
type ListCPUSizesRequest struct {
	// Identifier of project that will own a deployment.
	ProjectId            string   `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListCPUSizesRequest) Reset()         { *m = ListCPUSizesRequest{} }
func (m *ListCPUSizesRequest) String() string { return proto.CompactTextString(m) }
func (*ListCPUSizesRequest) ProtoMessage()    {}
func (*ListCPUSizesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{13}
}
func (m *ListCPUSizesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCPUSizesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCPUSizesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCPUSizesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCPUSizesRequest.Merge(m, src)
}
func (m *ListCPUSizesRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCPUSizesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCPUSizesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCPUSizesRequest proto.InternalMessageInfo

func (m *ListCPUSizesRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

// Request arguments for GetDeploymentCredentials
type DeploymentCredentialsRequest struct {
	// Identifier of deployment to request credentials for.
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// Reason for requesting the credentials
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentCredentialsRequest) Reset()         { *m = DeploymentCredentialsRequest{} }
func (m *DeploymentCredentialsRequest) String() string { return proto.CompactTextString(m) }
func (*DeploymentCredentialsRequest) ProtoMessage()    {}
func (*DeploymentCredentialsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{14}
}
func (m *DeploymentCredentialsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentCredentialsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentCredentialsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentCredentialsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentCredentialsRequest.Merge(m, src)
}
func (m *DeploymentCredentialsRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentCredentialsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentCredentialsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentCredentialsRequest proto.InternalMessageInfo

func (m *DeploymentCredentialsRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *DeploymentCredentialsRequest) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// Result for GetDeploymentCredentials
type DeploymentCredentials struct {
	// Name of the user for which credentials were asked.
	// Default to username of root user.
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Password of the user for which credentials were asked.
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentCredentials) Reset()         { *m = DeploymentCredentials{} }
func (m *DeploymentCredentials) String() string { return proto.CompactTextString(m) }
func (*DeploymentCredentials) ProtoMessage()    {}
func (*DeploymentCredentials) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{15}
}
func (m *DeploymentCredentials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentCredentials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentCredentials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentCredentials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentCredentials.Merge(m, src)
}
func (m *DeploymentCredentials) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentCredentials) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentCredentials.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentCredentials proto.InternalMessageInfo

func (m *DeploymentCredentials) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *DeploymentCredentials) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

// List of Deployments.
type DeploymentList struct {
	// Actual deployments
	Items []*Deployment `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// Budget for deployments
	Budget               *v1.Budget `protobuf:"bytes,2,opt,name=budget,proto3" json:"budget,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DeploymentList) Reset()         { *m = DeploymentList{} }
func (m *DeploymentList) String() string { return proto.CompactTextString(m) }
func (*DeploymentList) ProtoMessage()    {}
func (*DeploymentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{16}
}
func (m *DeploymentList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentList.Merge(m, src)
}
func (m *DeploymentList) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentList) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentList.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentList proto.InternalMessageInfo

func (m *DeploymentList) GetItems() []*Deployment {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *DeploymentList) GetBudget() *v1.Budget {
	if m != nil {
		return m.Budget
	}
	return nil
}

// Version of an ArangoDB release
type Version struct {
	// Version in the format of major.minor.patch
	// Format details can be found at: https://semver.org/
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// If set, deployments using this version will be upgraded to the ArangoDB release with the
	// version as listed in this message.
	ReplaceBy *ReplaceVersionBy `protobuf:"bytes,2,opt,name=replace_by,json=replaceBy,proto3" json:"replace_by,omitempty"`
	// If set, deployments using this version are recommend to be upgraded to the ArangoDB release with the
	// version as listed in this message.
	UpgradeRecommendation *UpgradeVersionRecommendation `protobuf:"bytes,3,opt,name=upgrade_recommendation,json=upgradeRecommendation,proto3" json:"upgrade_recommendation,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}                      `json:"-"`
	XXX_unrecognized      []byte                        `json:"-"`
	XXX_sizecache         int32                         `json:"-"`
}

func (m *Version) Reset()         { *m = Version{} }
func (m *Version) String() string { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()    {}
func (*Version) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{17}
}
func (m *Version) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Version) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Version.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Version) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Version.Merge(m, src)
}
func (m *Version) XXX_Size() int {
	return m.Size()
}
func (m *Version) XXX_DiscardUnknown() {
	xxx_messageInfo_Version.DiscardUnknown(m)
}

var xxx_messageInfo_Version proto.InternalMessageInfo

func (m *Version) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Version) GetReplaceBy() *ReplaceVersionBy {
	if m != nil {
		return m.ReplaceBy
	}
	return nil
}

func (m *Version) GetUpgradeRecommendation() *UpgradeVersionRecommendation {
	if m != nil {
		return m.UpgradeRecommendation
	}
	return nil
}

// ReplaceVersionBy holds replacement instructions.
type ReplaceVersionBy struct {
	// The version of the ArangoDB release that it will be upgraded to.
	// Version in the format of major.minor.patch
	// Format details can be found at: https://semver.org/
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Human readable reason why this version will be replaced.
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplaceVersionBy) Reset()         { *m = ReplaceVersionBy{} }
func (m *ReplaceVersionBy) String() string { return proto.CompactTextString(m) }
func (*ReplaceVersionBy) ProtoMessage()    {}
func (*ReplaceVersionBy) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{18}
}
func (m *ReplaceVersionBy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplaceVersionBy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplaceVersionBy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplaceVersionBy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplaceVersionBy.Merge(m, src)
}
func (m *ReplaceVersionBy) XXX_Size() int {
	return m.Size()
}
func (m *ReplaceVersionBy) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplaceVersionBy.DiscardUnknown(m)
}

var xxx_messageInfo_ReplaceVersionBy proto.InternalMessageInfo

func (m *ReplaceVersionBy) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ReplaceVersionBy) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// UpgradeVersionRecommendation holds a recommendation for updating this version.
type UpgradeVersionRecommendation struct {
	// The version of the ArangoDB release that it it is recommend to upgraded to.
	// Version in the format of major.minor.patch
	// Format details can be found at: https://semver.org/
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Human readable reason why this version should be upgraded.
	Reason               string   `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpgradeVersionRecommendation) Reset()         { *m = UpgradeVersionRecommendation{} }
func (m *UpgradeVersionRecommendation) String() string { return proto.CompactTextString(m) }
func (*UpgradeVersionRecommendation) ProtoMessage()    {}
func (*UpgradeVersionRecommendation) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{19}
}
func (m *UpgradeVersionRecommendation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeVersionRecommendation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeVersionRecommendation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeVersionRecommendation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeVersionRecommendation.Merge(m, src)
}
func (m *UpgradeVersionRecommendation) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeVersionRecommendation) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeVersionRecommendation.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeVersionRecommendation proto.InternalMessageInfo

func (m *UpgradeVersionRecommendation) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *UpgradeVersionRecommendation) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// List of Versions.
type VersionList struct {
	Items                []*Version `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *VersionList) Reset()         { *m = VersionList{} }
func (m *VersionList) String() string { return proto.CompactTextString(m) }
func (*VersionList) ProtoMessage()    {}
func (*VersionList) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{20}
}
func (m *VersionList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VersionList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VersionList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VersionList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VersionList.Merge(m, src)
}
func (m *VersionList) XXX_Size() int {
	return m.Size()
}
func (m *VersionList) XXX_DiscardUnknown() {
	xxx_messageInfo_VersionList.DiscardUnknown(m)
}

var xxx_messageInfo_VersionList proto.InternalMessageInfo

func (m *VersionList) GetItems() []*Version {
	if m != nil {
		return m.Items
	}
	return nil
}

// Request arguments for ListVersions.
type ListVersionsRequest struct {
	// Common list options
	Options *v1.ListOptions `protobuf:"bytes,1,opt,name=options,proto3" json:"options,omitempty"`
	// If set, the result includes all versions for that are available for the
	// organization identified by this ID.
	// If not set, only versions are returned that are available to all organizations.
	OrganizationId string `protobuf:"bytes,2,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	// If set, only versions will be returned that are safe to upgrade to from this version.
	CurrentVersion       string   `protobuf:"bytes,3,opt,name=current_version,json=currentVersion,proto3" json:"current_version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListVersionsRequest) Reset()         { *m = ListVersionsRequest{} }
func (m *ListVersionsRequest) String() string { return proto.CompactTextString(m) }
func (*ListVersionsRequest) ProtoMessage()    {}
func (*ListVersionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{21}
}
func (m *ListVersionsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListVersionsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListVersionsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListVersionsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListVersionsRequest.Merge(m, src)
}
func (m *ListVersionsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListVersionsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListVersionsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListVersionsRequest proto.InternalMessageInfo

func (m *ListVersionsRequest) GetOptions() *v1.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

func (m *ListVersionsRequest) GetOrganizationId() string {
	if m != nil {
		return m.OrganizationId
	}
	return ""
}

func (m *ListVersionsRequest) GetCurrentVersion() string {
	if m != nil {
		return m.CurrentVersion
	}
	return ""
}

// Request arguments for ListServersSpecLimits
type ServersSpecLimitsRequest struct {
	// Identifier of project that will own a deployment.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of a region in which a deployment will be created.
	RegionId string `protobuf:"bytes,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// Optional identifier of a deployment for which compatible server specifications are request.
	DeploymentId         string   `protobuf:"bytes,3,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServersSpecLimitsRequest) Reset()         { *m = ServersSpecLimitsRequest{} }
func (m *ServersSpecLimitsRequest) String() string { return proto.CompactTextString(m) }
func (*ServersSpecLimitsRequest) ProtoMessage()    {}
func (*ServersSpecLimitsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{22}
}
func (m *ServersSpecLimitsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecLimitsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecLimitsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecLimitsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecLimitsRequest.Merge(m, src)
}
func (m *ServersSpecLimitsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecLimitsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecLimitsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecLimitsRequest proto.InternalMessageInfo

func (m *ServersSpecLimitsRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *ServersSpecLimitsRequest) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *ServersSpecLimitsRequest) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

// Limits of allowed values for fields of Deployment.ServersSpec.
type ServersSpecLimits struct {
	// Limits for the number of coordinators of the deployment
	Coordinators *ServersSpecLimits_Limits `protobuf:"bytes,1,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Possible values for the amount of memory (in GB) to allocate
	// for coordinators.
	CoordinatorMemorySize *ServersSpecLimits_Limits `protobuf:"bytes,2,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Limits for the number of dbservers of the deployment
	Dbservers *ServersSpecLimits_Limits `protobuf:"bytes,11,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Possible values for the amount of memory (in GB) to allocate
	// for dbservers.
	DbserverMemorySize *ServersSpecLimits_Limits `protobuf:"bytes,12,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for dbservers.
	DbserverDiskSize *ServersSpecLimits_Limits `protobuf:"bytes,13,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	// Possible values for the amount of memory (in GB) to allocate
	// for pairs of coordinator, dbserver.
	NodeMemorySize *ServersSpecLimits_Limits `protobuf:"bytes,21,opt,name=node_memory_size,json=nodeMemorySize,proto3" json:"node_memory_size,omitempty"`
	// Possible values for the number of nodes.
	// Value must be min/max (not using allowed_values)
	NodeCount            *ServersSpecLimits_Limits `protobuf:"bytes,22,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ServersSpecLimits) Reset()         { *m = ServersSpecLimits{} }
func (m *ServersSpecLimits) String() string { return proto.CompactTextString(m) }
func (*ServersSpecLimits) ProtoMessage()    {}
func (*ServersSpecLimits) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{23}
}
func (m *ServersSpecLimits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecLimits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecLimits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecLimits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecLimits.Merge(m, src)
}
func (m *ServersSpecLimits) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecLimits) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecLimits.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecLimits proto.InternalMessageInfo

func (m *ServersSpecLimits) GetCoordinators() *ServersSpecLimits_Limits {
	if m != nil {
		return m.Coordinators
	}
	return nil
}

func (m *ServersSpecLimits) GetCoordinatorMemorySize() *ServersSpecLimits_Limits {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return nil
}

func (m *ServersSpecLimits) GetDbservers() *ServersSpecLimits_Limits {
	if m != nil {
		return m.Dbservers
	}
	return nil
}

func (m *ServersSpecLimits) GetDbserverMemorySize() *ServersSpecLimits_Limits {
	if m != nil {
		return m.DbserverMemorySize
	}
	return nil
}

func (m *ServersSpecLimits) GetDbserverDiskSize() *ServersSpecLimits_Limits {
	if m != nil {
		return m.DbserverDiskSize
	}
	return nil
}

func (m *ServersSpecLimits) GetNodeMemorySize() *ServersSpecLimits_Limits {
	if m != nil {
		return m.NodeMemorySize
	}
	return nil
}

func (m *ServersSpecLimits) GetNodeCount() *ServersSpecLimits_Limits {
	if m != nil {
		return m.NodeCount
	}
	return nil
}

type ServersSpecLimits_Limits struct {
	// Minimum value
	Min int32 `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	// Maximum value
	Max int32 `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	// Set of allowed values.
	// If this field is non-empty, only one of these values
	// is allowed.
	AllowedValues        []int32  `protobuf:"varint,3,rep,packed,name=allowed_values,json=allowedValues,proto3" json:"allowed_values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServersSpecLimits_Limits) Reset()         { *m = ServersSpecLimits_Limits{} }
func (m *ServersSpecLimits_Limits) String() string { return proto.CompactTextString(m) }
func (*ServersSpecLimits_Limits) ProtoMessage()    {}
func (*ServersSpecLimits_Limits) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{23, 0}
}
func (m *ServersSpecLimits_Limits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServersSpecLimits_Limits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServersSpecLimits_Limits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServersSpecLimits_Limits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServersSpecLimits_Limits.Merge(m, src)
}
func (m *ServersSpecLimits_Limits) XXX_Size() int {
	return m.Size()
}
func (m *ServersSpecLimits_Limits) XXX_DiscardUnknown() {
	xxx_messageInfo_ServersSpecLimits_Limits.DiscardUnknown(m)
}

var xxx_messageInfo_ServersSpecLimits_Limits proto.InternalMessageInfo

func (m *ServersSpecLimits_Limits) GetMin() int32 {
	if m != nil {
		return m.Min
	}
	return 0
}

func (m *ServersSpecLimits_Limits) GetMax() int32 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *ServersSpecLimits_Limits) GetAllowedValues() []int32 {
	if m != nil {
		return m.AllowedValues
	}
	return nil
}

// Request arguments for CalculateDeploymentSize
type CalculateDeploymentSizeRequest struct {
	// Number of coordinators of the deployment
	// This field is ignored unless model is "flexible".
	Coordinators int32 `protobuf:"varint,1,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Amount of memory (in GB) to allocate for each coordinator.
	// This field is ignored unless model is "flexible".
	CoordinatorMemorySize int32 `protobuf:"varint,2,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Number of dbservers of the deployment
	// This field is ignored unless model is "flexible".
	Dbservers int32 `protobuf:"varint,11,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Amount of memory (in GB) to allocate for each dbserver.
	// This field is ignored unless model is "flexible".
	DbserverMemorySize int32 `protobuf:"varint,12,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for each dbserver.
	// This field is ignored unless model is "flexible".
	DbserverDiskSize int32 `protobuf:"varint,13,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	// Type of model being used
	Model string `protobuf:"bytes,21,opt,name=model,proto3" json:"model,omitempty"`
	// Size of nodes being used
	NodeSizeId string `protobuf:"bytes,22,opt,name=node_size_id,json=nodeSizeId,proto3" json:"node_size_id,omitempty"`
	// Number of nodes being used
	NodeCount int32 `protobuf:"varint,23,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Amount of disk space per node (in GB)
	NodeDiskSize int32 `protobuf:"varint,34,opt,name=node_disk_size,json=nodeDiskSize,proto3" json:"node_disk_size,omitempty"`
	// ID of region in which the deployment will be created.
	RegionId             string   `protobuf:"bytes,50,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CalculateDeploymentSizeRequest) Reset()         { *m = CalculateDeploymentSizeRequest{} }
func (m *CalculateDeploymentSizeRequest) String() string { return proto.CompactTextString(m) }
func (*CalculateDeploymentSizeRequest) ProtoMessage()    {}
func (*CalculateDeploymentSizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{24}
}
func (m *CalculateDeploymentSizeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalculateDeploymentSizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalculateDeploymentSizeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalculateDeploymentSizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalculateDeploymentSizeRequest.Merge(m, src)
}
func (m *CalculateDeploymentSizeRequest) XXX_Size() int {
	return m.Size()
}
func (m *CalculateDeploymentSizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CalculateDeploymentSizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CalculateDeploymentSizeRequest proto.InternalMessageInfo

func (m *CalculateDeploymentSizeRequest) GetCoordinators() int32 {
	if m != nil {
		return m.Coordinators
	}
	return 0
}

func (m *CalculateDeploymentSizeRequest) GetCoordinatorMemorySize() int32 {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return 0
}

func (m *CalculateDeploymentSizeRequest) GetDbservers() int32 {
	if m != nil {
		return m.Dbservers
	}
	return 0
}

func (m *CalculateDeploymentSizeRequest) GetDbserverMemorySize() int32 {
	if m != nil {
		return m.DbserverMemorySize
	}
	return 0
}

func (m *CalculateDeploymentSizeRequest) GetDbserverDiskSize() int32 {
	if m != nil {
		return m.DbserverDiskSize
	}
	return 0
}

func (m *CalculateDeploymentSizeRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *CalculateDeploymentSizeRequest) GetNodeSizeId() string {
	if m != nil {
		return m.NodeSizeId
	}
	return ""
}

func (m *CalculateDeploymentSizeRequest) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *CalculateDeploymentSizeRequest) GetNodeDiskSize() int32 {
	if m != nil {
		return m.NodeDiskSize
	}
	return 0
}

func (m *CalculateDeploymentSizeRequest) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

// Result of CalculateDeploymentSize
type DeploymentSize struct {
	// Number of agents
	Agents int32 `protobuf:"varint,1,opt,name=agents,proto3" json:"agents,omitempty"`
	// Amount of memory (in GB) to allocate for each agent.
	AgentMemorySize int32 `protobuf:"varint,2,opt,name=agent_memory_size,json=agentMemorySize,proto3" json:"agent_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for each agent.
	AgentDiskSize int32 `protobuf:"varint,3,opt,name=agent_disk_size,json=agentDiskSize,proto3" json:"agent_disk_size,omitempty"`
	// Total (combined) amount of memory (in GB) used by all servers (agents, coordinators & dbservers)
	TotalMemorySize int32 `protobuf:"varint,11,opt,name=total_memory_size,json=totalMemorySize,proto3" json:"total_memory_size,omitempty"`
	// Total (combined) amount of disk space (in GB) used by all servers (agents & dbservers)
	TotalDiskSize int32 `protobuf:"varint,12,opt,name=total_disk_size,json=totalDiskSize,proto3" json:"total_disk_size,omitempty"`
	// Number of coordinators
	Coordinators int32 `protobuf:"varint,21,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Amount of memory (in GB) to allocate for each coordinator.
	CoordinatorMemorySize int32 `protobuf:"varint,22,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Number of dbservers
	Dbservers int32 `protobuf:"varint,31,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Amount of memory (in GB) to allocate for each dbserver.
	DbserverMemorySize int32 `protobuf:"varint,32,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for each dbserver.
	DbserverDiskSize     int32    `protobuf:"varint,33,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentSize) Reset()         { *m = DeploymentSize{} }
func (m *DeploymentSize) String() string { return proto.CompactTextString(m) }
func (*DeploymentSize) ProtoMessage()    {}
func (*DeploymentSize) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{25}
}
func (m *DeploymentSize) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentSize) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentSize.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentSize) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentSize.Merge(m, src)
}
func (m *DeploymentSize) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentSize) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentSize.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentSize proto.InternalMessageInfo

func (m *DeploymentSize) GetAgents() int32 {
	if m != nil {
		return m.Agents
	}
	return 0
}

func (m *DeploymentSize) GetAgentMemorySize() int32 {
	if m != nil {
		return m.AgentMemorySize
	}
	return 0
}

func (m *DeploymentSize) GetAgentDiskSize() int32 {
	if m != nil {
		return m.AgentDiskSize
	}
	return 0
}

func (m *DeploymentSize) GetTotalMemorySize() int32 {
	if m != nil {
		return m.TotalMemorySize
	}
	return 0
}

func (m *DeploymentSize) GetTotalDiskSize() int32 {
	if m != nil {
		return m.TotalDiskSize
	}
	return 0
}

func (m *DeploymentSize) GetCoordinators() int32 {
	if m != nil {
		return m.Coordinators
	}
	return 0
}

func (m *DeploymentSize) GetCoordinatorMemorySize() int32 {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return 0
}

func (m *DeploymentSize) GetDbservers() int32 {
	if m != nil {
		return m.Dbservers
	}
	return 0
}

func (m *DeploymentSize) GetDbserverMemorySize() int32 {
	if m != nil {
		return m.DbserverMemorySize
	}
	return 0
}

func (m *DeploymentSize) GetDbserverDiskSize() int32 {
	if m != nil {
		return m.DbserverDiskSize
	}
	return 0
}

// Request arguments for RecommendDeploymentSize.
type DeploymentSizeRequest struct {
	// Size of entire dataset (on disk) in GB.
	// Required field.
	// Must be >= 1.
	DatasetSize int32 `protobuf:"varint,1,opt,name=dataset_size,json=datasetSize,proto3" json:"dataset_size,omitempty"`
	// Primary use case for the database
	// Possible values:
	// - GRAPH
	// - DOCUMENT
	// - MULTIMODEL
	// - KEYVALUE
	Usecase string `protobuf:"bytes,2,opt,name=usecase,proto3" json:"usecase,omitempty"`
	// Customer preferred model
	Model string `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
	// File format on dataset
	// Possible values:
	// - JSON
	// - CSV
	FileFormat string `protobuf:"bytes,4,opt,name=file_format,json=fileFormat,proto3" json:"file_format,omitempty"`
	// Number of documents in the entire dataset (in case of JSON).
	// Number of rows in the entire dataset (in case of CSV).
	NumberOfDocuments int64 `protobuf:"varint,5,opt,name=number_of_documents,json=numberOfDocuments,proto3" json:"number_of_documents,omitempty"`
	// Largest number of columns of the dataset (in case of CSV).
	NumberOfColumns int32 `protobuf:"varint,6,opt,name=number_of_columns,json=numberOfColumns,proto3" json:"number_of_columns,omitempty"`
	// Percentage of dataset_size that is considered "hot"
	// Must be >= 0.0 and <= 1.0
	WorkingSetPercentage float32 `protobuf:"fixed32,7,opt,name=working_set_percentage,json=workingSetPercentage,proto3" json:"working_set_percentage,omitempty"`
	// Percentage of operations that are READ
	// Must be >= 0.0 and <= 1.0
	AccessReadPercentage float32 `protobuf:"fixed32,8,opt,name=access_read_percentage,json=accessReadPercentage,proto3" json:"access_read_percentage,omitempty"`
	// Percentage of operations that are CREATE
	// Must be >= 0.0 and <= 1.0
	AccessCreatePercentage float32 `protobuf:"fixed32,9,opt,name=access_create_percentage,json=accessCreatePercentage,proto3" json:"access_create_percentage,omitempty"`
	// Percentage of operations that are UPDATE
	// Must be >= 0.0 and <= 1.0
	AccessUpdatePercentage float32 `protobuf:"fixed32,10,opt,name=access_update_percentage,json=accessUpdatePercentage,proto3" json:"access_update_percentage,omitempty"`
	// Increase factor of the dataset_size in 1 year.
	GrowthRate float32 `protobuf:"fixed32,11,opt,name=growth_rate,json=growthRate,proto3" json:"growth_rate,omitempty"`
	// Desired number of replicas.
	// Must be >= 3 and <= 5
	ReplicationFactor int32 `protobuf:"varint,12,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	// Identifier of project to request a recommendation in
	ProjectId string `protobuf:"bytes,21,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of region to request a recommendation in
	RegionId             string   `protobuf:"bytes,22,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentSizeRequest) Reset()         { *m = DeploymentSizeRequest{} }
func (m *DeploymentSizeRequest) String() string { return proto.CompactTextString(m) }
func (*DeploymentSizeRequest) ProtoMessage()    {}
func (*DeploymentSizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{26}
}
func (m *DeploymentSizeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentSizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentSizeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentSizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentSizeRequest.Merge(m, src)
}
func (m *DeploymentSizeRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentSizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentSizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentSizeRequest proto.InternalMessageInfo

func (m *DeploymentSizeRequest) GetDatasetSize() int32 {
	if m != nil {
		return m.DatasetSize
	}
	return 0
}

func (m *DeploymentSizeRequest) GetUsecase() string {
	if m != nil {
		return m.Usecase
	}
	return ""
}

func (m *DeploymentSizeRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *DeploymentSizeRequest) GetFileFormat() string {
	if m != nil {
		return m.FileFormat
	}
	return ""
}

func (m *DeploymentSizeRequest) GetNumberOfDocuments() int64 {
	if m != nil {
		return m.NumberOfDocuments
	}
	return 0
}

func (m *DeploymentSizeRequest) GetNumberOfColumns() int32 {
	if m != nil {
		return m.NumberOfColumns
	}
	return 0
}

func (m *DeploymentSizeRequest) GetWorkingSetPercentage() float32 {
	if m != nil {
		return m.WorkingSetPercentage
	}
	return 0
}

func (m *DeploymentSizeRequest) GetAccessReadPercentage() float32 {
	if m != nil {
		return m.AccessReadPercentage
	}
	return 0
}

func (m *DeploymentSizeRequest) GetAccessCreatePercentage() float32 {
	if m != nil {
		return m.AccessCreatePercentage
	}
	return 0
}

func (m *DeploymentSizeRequest) GetAccessUpdatePercentage() float32 {
	if m != nil {
		return m.AccessUpdatePercentage
	}
	return 0
}

func (m *DeploymentSizeRequest) GetGrowthRate() float32 {
	if m != nil {
		return m.GrowthRate
	}
	return 0
}

func (m *DeploymentSizeRequest) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *DeploymentSizeRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *DeploymentSizeRequest) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

// Response of RecommendDeploymentSize.
type DeploymentSizeRecommendation struct {
	// Request that resulted in this recommendation.
	Request *DeploymentSizeRequest `protobuf:"bytes,1,opt,name=request,proto3" json:"request,omitempty"`
	// Time when the recommendation was made.
	CreatedAt *types.Timestamp `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Amount of memory space per node (in GB) being recommended
	NodeMemorySize int32 `protobuf:"varint,11,opt,name=node_memory_size,json=nodeMemorySize,proto3" json:"node_memory_size,omitempty"`
	// Amount of disk space per node (in GB) being recommended
	NodeDiskSize int32 `protobuf:"varint,12,opt,name=node_disk_size,json=nodeDiskSize,proto3" json:"node_disk_size,omitempty"`
	// Number of nodes being recommended
	NodeCount int32 `protobuf:"varint,13,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// If set, this recommendation does not fit in
	// the callers quota.
	ExceedsQuota bool `protobuf:"varint,21,opt,name=exceeds_quota,json=exceedsQuota,proto3" json:"exceeds_quota,omitempty"`
	// If set, this recommendation does not fit in
	// the Oasis platform.
	ExceedsPlatform      bool     `protobuf:"varint,22,opt,name=exceeds_platform,json=exceedsPlatform,proto3" json:"exceeds_platform,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentSizeRecommendation) Reset()         { *m = DeploymentSizeRecommendation{} }
func (m *DeploymentSizeRecommendation) String() string { return proto.CompactTextString(m) }
func (*DeploymentSizeRecommendation) ProtoMessage()    {}
func (*DeploymentSizeRecommendation) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{27}
}
func (m *DeploymentSizeRecommendation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentSizeRecommendation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentSizeRecommendation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentSizeRecommendation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentSizeRecommendation.Merge(m, src)
}
func (m *DeploymentSizeRecommendation) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentSizeRecommendation) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentSizeRecommendation.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentSizeRecommendation proto.InternalMessageInfo

func (m *DeploymentSizeRecommendation) GetRequest() *DeploymentSizeRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DeploymentSizeRecommendation) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *DeploymentSizeRecommendation) GetNodeMemorySize() int32 {
	if m != nil {
		return m.NodeMemorySize
	}
	return 0
}

func (m *DeploymentSizeRecommendation) GetNodeDiskSize() int32 {
	if m != nil {
		return m.NodeDiskSize
	}
	return 0
}

func (m *DeploymentSizeRecommendation) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *DeploymentSizeRecommendation) GetExceedsQuota() bool {
	if m != nil {
		return m.ExceedsQuota
	}
	return false
}

func (m *DeploymentSizeRecommendation) GetExceedsPlatform() bool {
	if m != nil {
		return m.ExceedsPlatform
	}
	return false
}

// DataVolumeInfo provides information about a data volume
type DataVolumeInfo struct {
	// The total number of bytes of the data volume.
	TotalBytes int64 `protobuf:"varint,1,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// The number of bytes used on the data volume.
	UsedBytes int64 `protobuf:"varint,2,opt,name=used_bytes,json=usedBytes,proto3" json:"used_bytes,omitempty"`
	// The number of bytes available on the data volume.
	AvailableBytes int64 `protobuf:"varint,3,opt,name=available_bytes,json=availableBytes,proto3" json:"available_bytes,omitempty"`
	// The total number of inodes of the data volume.
	TotalInodes int64 `protobuf:"varint,4,opt,name=total_inodes,json=totalInodes,proto3" json:"total_inodes,omitempty"`
	// The number of inodes used on the data volume.
	UsedInodes int64 `protobuf:"varint,5,opt,name=used_inodes,json=usedInodes,proto3" json:"used_inodes,omitempty"`
	// The number of inodes available on the data volume.
	AvailableInodes int64 `protobuf:"varint,6,opt,name=available_inodes,json=availableInodes,proto3" json:"available_inodes,omitempty"`
	// When this info has been measused
	MeasuredAt           *types.Timestamp `protobuf:"bytes,10,opt,name=measured_at,json=measuredAt,proto3" json:"measured_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DataVolumeInfo) Reset()         { *m = DataVolumeInfo{} }
func (m *DataVolumeInfo) String() string { return proto.CompactTextString(m) }
func (*DataVolumeInfo) ProtoMessage()    {}
func (*DataVolumeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{28}
}
func (m *DataVolumeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataVolumeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataVolumeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataVolumeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataVolumeInfo.Merge(m, src)
}
func (m *DataVolumeInfo) XXX_Size() int {
	return m.Size()
}
func (m *DataVolumeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DataVolumeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DataVolumeInfo proto.InternalMessageInfo

func (m *DataVolumeInfo) GetTotalBytes() int64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *DataVolumeInfo) GetUsedBytes() int64 {
	if m != nil {
		return m.UsedBytes
	}
	return 0
}

func (m *DataVolumeInfo) GetAvailableBytes() int64 {
	if m != nil {
		return m.AvailableBytes
	}
	return 0
}

func (m *DataVolumeInfo) GetTotalInodes() int64 {
	if m != nil {
		return m.TotalInodes
	}
	return 0
}

func (m *DataVolumeInfo) GetUsedInodes() int64 {
	if m != nil {
		return m.UsedInodes
	}
	return 0
}

func (m *DataVolumeInfo) GetAvailableInodes() int64 {
	if m != nil {
		return m.AvailableInodes
	}
	return 0
}

func (m *DataVolumeInfo) GetMeasuredAt() *types.Timestamp {
	if m != nil {
		return m.MeasuredAt
	}
	return nil
}

// Instructions for connecting a driver to a deployment
type ConnectDriverInstructions struct {
	// Per driver instructions for connecting to a deployment
	Drivers              []*ConnectDriverInstructions_DriverInstructions `protobuf:"bytes,1,rep,name=drivers,proto3" json:"drivers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *ConnectDriverInstructions) Reset()         { *m = ConnectDriverInstructions{} }
func (m *ConnectDriverInstructions) String() string { return proto.CompactTextString(m) }
func (*ConnectDriverInstructions) ProtoMessage()    {}
func (*ConnectDriverInstructions) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{29}
}
func (m *ConnectDriverInstructions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectDriverInstructions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectDriverInstructions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectDriverInstructions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectDriverInstructions.Merge(m, src)
}
func (m *ConnectDriverInstructions) XXX_Size() int {
	return m.Size()
}
func (m *ConnectDriverInstructions) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectDriverInstructions.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectDriverInstructions proto.InternalMessageInfo

func (m *ConnectDriverInstructions) GetDrivers() []*ConnectDriverInstructions_DriverInstructions {
	if m != nil {
		return m.Drivers
	}
	return nil
}

// Instructions for a specific driver
type ConnectDriverInstructions_DriverInstructions struct {
	// Human readable name of the driver.
	// E.g. "ArangoDB Go driver"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Lines of code
	Code []string `protobuf:"bytes,2,rep,name=code,proto3" json:"code,omitempty"`
	// Human readable remarks
	Remarks []string `protobuf:"bytes,3,rep,name=remarks,proto3" json:"remarks,omitempty"`
	// URL for getting more information on the driver.
	DriverUrl            string   `protobuf:"bytes,4,opt,name=driver_url,json=driverUrl,proto3" json:"driver_url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConnectDriverInstructions_DriverInstructions) Reset() {
	*m = ConnectDriverInstructions_DriverInstructions{}
}
func (m *ConnectDriverInstructions_DriverInstructions) String() string {
	return proto.CompactTextString(m)
}
func (*ConnectDriverInstructions_DriverInstructions) ProtoMessage() {}
func (*ConnectDriverInstructions_DriverInstructions) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{29, 0}
}
func (m *ConnectDriverInstructions_DriverInstructions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConnectDriverInstructions_DriverInstructions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConnectDriverInstructions_DriverInstructions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConnectDriverInstructions_DriverInstructions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectDriverInstructions_DriverInstructions.Merge(m, src)
}
func (m *ConnectDriverInstructions_DriverInstructions) XXX_Size() int {
	return m.Size()
}
func (m *ConnectDriverInstructions_DriverInstructions) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectDriverInstructions_DriverInstructions.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectDriverInstructions_DriverInstructions proto.InternalMessageInfo

func (m *ConnectDriverInstructions_DriverInstructions) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConnectDriverInstructions_DriverInstructions) GetCode() []string {
	if m != nil {
		return m.Code
	}
	return nil
}

func (m *ConnectDriverInstructions_DriverInstructions) GetRemarks() []string {
	if m != nil {
		return m.Remarks
	}
	return nil
}

func (m *ConnectDriverInstructions_DriverInstructions) GetDriverUrl() string {
	if m != nil {
		return m.DriverUrl
	}
	return ""
}

// Instructions for importing data into a deployment
type ImportDataInstructions struct {
	// Lines of code to run arangorestore
	ImportDump []string `protobuf:"bytes,2,rep,name=import_dump,json=importDump,proto3" json:"import_dump,omitempty"`
	// Lines of code to run arangoimport with json file format
	ArangoImportJson []string `protobuf:"bytes,3,rep,name=arango_import_json,json=arangoImportJson,proto3" json:"arango_import_json,omitempty"`
	// Lines of code to run arangoimport with csv file format
	ArangoImportCsv []string `protobuf:"bytes,4,rep,name=arango_import_csv,json=arangoImportCsv,proto3" json:"arango_import_csv,omitempty"`
	// Lines of code to run arangoimport with tsv file format
	ArangoImportTsv      []string `protobuf:"bytes,5,rep,name=arango_import_tsv,json=arangoImportTsv,proto3" json:"arango_import_tsv,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImportDataInstructions) Reset()         { *m = ImportDataInstructions{} }
func (m *ImportDataInstructions) String() string { return proto.CompactTextString(m) }
func (*ImportDataInstructions) ProtoMessage()    {}
func (*ImportDataInstructions) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{30}
}
func (m *ImportDataInstructions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImportDataInstructions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImportDataInstructions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImportDataInstructions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImportDataInstructions.Merge(m, src)
}
func (m *ImportDataInstructions) XXX_Size() int {
	return m.Size()
}
func (m *ImportDataInstructions) XXX_DiscardUnknown() {
	xxx_messageInfo_ImportDataInstructions.DiscardUnknown(m)
}

var xxx_messageInfo_ImportDataInstructions proto.InternalMessageInfo

func (m *ImportDataInstructions) GetImportDump() []string {
	if m != nil {
		return m.ImportDump
	}
	return nil
}

func (m *ImportDataInstructions) GetArangoImportJson() []string {
	if m != nil {
		return m.ArangoImportJson
	}
	return nil
}

func (m *ImportDataInstructions) GetArangoImportCsv() []string {
	if m != nil {
		return m.ArangoImportCsv
	}
	return nil
}

func (m *ImportDataInstructions) GetArangoImportTsv() []string {
	if m != nil {
		return m.ArangoImportTsv
	}
	return nil
}

// Arguments for requesting a price a deployment of given properties.
type DeploymentPriceRequest struct {
	// Identifier of organization containing the deployment.
	OrganizationId string `protobuf:"bytes,1,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	// Identifier of project containing the deployment.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of the support plan of the deployment.
	SupportPlanId string `protobuf:"bytes,3,opt,name=support_plan_id,json=supportPlanId,proto3" json:"support_plan_id,omitempty"`
	// Identifier of the cloud provider of the deployment.
	CloudProviderId string `protobuf:"bytes,4,opt,name=cloud_provider_id,json=cloudProviderId,proto3" json:"cloud_provider_id,omitempty"`
	// Identifier of the cloud region of the deployment.
	CloudRegionId string `protobuf:"bytes,5,opt,name=cloud_region_id,json=cloudRegionId,proto3" json:"cloud_region_id,omitempty"`
	// Model of the deployment.
	Model string `protobuf:"bytes,6,opt,name=model,proto3" json:"model,omitempty"`
	// Node size use for deployments
	NodeSizeId string `protobuf:"bytes,7,opt,name=node_size_id,json=nodeSizeId,proto3" json:"node_size_id,omitempty"`
	// Number of nodes being used
	// This field is ignored if model is "flexible".
	NodeCount int32 `protobuf:"varint,8,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Amount of disk space per node (in GB)
	// This field is ignored if model is "flexible".
	NodeDiskSize int32 `protobuf:"varint,9,opt,name=node_disk_size,json=nodeDiskSize,proto3" json:"node_disk_size,omitempty"`
	// Number of coordinators of the deployment
	// This field is ignored unless model is "flexible".
	Coordinators int32 `protobuf:"varint,10,opt,name=coordinators,proto3" json:"coordinators,omitempty"`
	// Amount of memory (in GB) to allocate for each coordinator.
	// This field is ignored unless model is "flexible".
	CoordinatorMemorySize int32 `protobuf:"varint,11,opt,name=coordinator_memory_size,json=coordinatorMemorySize,proto3" json:"coordinator_memory_size,omitempty"`
	// Number of dbservers of the deployment
	// This field is ignored unless model is "flexible".
	Dbservers int32 `protobuf:"varint,12,opt,name=dbservers,proto3" json:"dbservers,omitempty"`
	// Amount of memory (in GB) to allocate for each dbserver.
	// This field is ignored unless model is "flexible".
	DbserverMemorySize int32 `protobuf:"varint,13,opt,name=dbserver_memory_size,json=dbserverMemorySize,proto3" json:"dbserver_memory_size,omitempty"`
	// Amount of disk space (in GB) to allocate for each dbserver.
	// This field is ignored unless model is "flexible".
	DbserverDiskSize     int32    `protobuf:"varint,14,opt,name=dbserver_disk_size,json=dbserverDiskSize,proto3" json:"dbserver_disk_size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentPriceRequest) Reset()         { *m = DeploymentPriceRequest{} }
func (m *DeploymentPriceRequest) String() string { return proto.CompactTextString(m) }
func (*DeploymentPriceRequest) ProtoMessage()    {}
func (*DeploymentPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{31}
}
func (m *DeploymentPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentPriceRequest.Merge(m, src)
}
func (m *DeploymentPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentPriceRequest proto.InternalMessageInfo

func (m *DeploymentPriceRequest) GetOrganizationId() string {
	if m != nil {
		return m.OrganizationId
	}
	return ""
}

func (m *DeploymentPriceRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *DeploymentPriceRequest) GetSupportPlanId() string {
	if m != nil {
		return m.SupportPlanId
	}
	return ""
}

func (m *DeploymentPriceRequest) GetCloudProviderId() string {
	if m != nil {
		return m.CloudProviderId
	}
	return ""
}

func (m *DeploymentPriceRequest) GetCloudRegionId() string {
	if m != nil {
		return m.CloudRegionId
	}
	return ""
}

func (m *DeploymentPriceRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *DeploymentPriceRequest) GetNodeSizeId() string {
	if m != nil {
		return m.NodeSizeId
	}
	return ""
}

func (m *DeploymentPriceRequest) GetNodeCount() int32 {
	if m != nil {
		return m.NodeCount
	}
	return 0
}

func (m *DeploymentPriceRequest) GetNodeDiskSize() int32 {
	if m != nil {
		return m.NodeDiskSize
	}
	return 0
}

func (m *DeploymentPriceRequest) GetCoordinators() int32 {
	if m != nil {
		return m.Coordinators
	}
	return 0
}

func (m *DeploymentPriceRequest) GetCoordinatorMemorySize() int32 {
	if m != nil {
		return m.CoordinatorMemorySize
	}
	return 0
}

func (m *DeploymentPriceRequest) GetDbservers() int32 {
	if m != nil {
		return m.Dbservers
	}
	return 0
}

func (m *DeploymentPriceRequest) GetDbserverMemorySize() int32 {
	if m != nil {
		return m.DbserverMemorySize
	}
	return 0
}

func (m *DeploymentPriceRequest) GetDbserverDiskSize() int32 {
	if m != nil {
		return m.DbserverDiskSize
	}
	return 0
}

type DeploymentPrice struct {
	// Price per hour in given currency for the deployment.
	PricePerHour float32 `protobuf:"fixed32,1,opt,name=price_per_hour,json=pricePerHour,proto3" json:"price_per_hour,omitempty"`
	// Network transfer prices (variable depending on usage)
	NetworkTransferPrices []*DeploymentPrice_NetworkTransferPrice `protobuf:"bytes,2,rep,name=network_transfer_prices,json=networkTransferPrices,proto3" json:"network_transfer_prices,omitempty"`
	// Backup prices (variable depending on usage)
	BackupPrice *DeploymentPrice_BackupPrice `protobuf:"bytes,3,opt,name=backup_price,json=backupPrice,proto3" json:"backup_price,omitempty"`
	// Identifier of the currency in which the price is specified.
	CurrencyId string `protobuf:"bytes,4,opt,name=currency_id,json=currencyId,proto3" json:"currency_id,omitempty"`
	// AuditLog prices (variable depending on usage)
	AuditlogPrice        *DeploymentPrice_AuditLogPrice `protobuf:"bytes,5,opt,name=auditlog_price,json=auditlogPrice,proto3" json:"auditlog_price,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *DeploymentPrice) Reset()         { *m = DeploymentPrice{} }
func (m *DeploymentPrice) String() string { return proto.CompactTextString(m) }
func (*DeploymentPrice) ProtoMessage()    {}
func (*DeploymentPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{32}
}
func (m *DeploymentPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentPrice.Merge(m, src)
}
func (m *DeploymentPrice) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentPrice.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentPrice proto.InternalMessageInfo

func (m *DeploymentPrice) GetPricePerHour() float32 {
	if m != nil {
		return m.PricePerHour
	}
	return 0
}

func (m *DeploymentPrice) GetNetworkTransferPrices() []*DeploymentPrice_NetworkTransferPrice {
	if m != nil {
		return m.NetworkTransferPrices
	}
	return nil
}

func (m *DeploymentPrice) GetBackupPrice() *DeploymentPrice_BackupPrice {
	if m != nil {
		return m.BackupPrice
	}
	return nil
}

func (m *DeploymentPrice) GetCurrencyId() string {
	if m != nil {
		return m.CurrencyId
	}
	return ""
}

func (m *DeploymentPrice) GetAuditlogPrice() *DeploymentPrice_AuditLogPrice {
	if m != nil {
		return m.AuditlogPrice
	}
	return nil
}

type DeploymentPrice_NetworkTransferPrice struct {
	// Price per GB of network transfer into the database
	IngressPricePerGb float32 `protobuf:"fixed32,1,opt,name=ingress_price_per_gb,json=ingressPricePerGb,proto3" json:"ingress_price_per_gb,omitempty"`
	// Price per GB of network transfer out of the database
	EgressPricePerGb float32 `protobuf:"fixed32,2,opt,name=egress_price_per_gb,json=egressPricePerGb,proto3" json:"egress_price_per_gb,omitempty"`
	// Description of this price
	Description          string   `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentPrice_NetworkTransferPrice) Reset()         { *m = DeploymentPrice_NetworkTransferPrice{} }
func (m *DeploymentPrice_NetworkTransferPrice) String() string { return proto.CompactTextString(m) }
func (*DeploymentPrice_NetworkTransferPrice) ProtoMessage()    {}
func (*DeploymentPrice_NetworkTransferPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{32, 0}
}
func (m *DeploymentPrice_NetworkTransferPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentPrice_NetworkTransferPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentPrice_NetworkTransferPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentPrice_NetworkTransferPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentPrice_NetworkTransferPrice.Merge(m, src)
}
func (m *DeploymentPrice_NetworkTransferPrice) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentPrice_NetworkTransferPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentPrice_NetworkTransferPrice.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentPrice_NetworkTransferPrice proto.InternalMessageInfo

func (m *DeploymentPrice_NetworkTransferPrice) GetIngressPricePerGb() float32 {
	if m != nil {
		return m.IngressPricePerGb
	}
	return 0
}

func (m *DeploymentPrice_NetworkTransferPrice) GetEgressPricePerGb() float32 {
	if m != nil {
		return m.EgressPricePerGb
	}
	return 0
}

func (m *DeploymentPrice_NetworkTransferPrice) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type DeploymentPrice_BackupPrice struct {
	// Price per GB/hour of uploaded backup storage
	PricePerGbPerHour    float32  `protobuf:"fixed32,1,opt,name=price_per_gb_per_hour,json=pricePerGbPerHour,proto3" json:"price_per_gb_per_hour,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentPrice_BackupPrice) Reset()         { *m = DeploymentPrice_BackupPrice{} }
func (m *DeploymentPrice_BackupPrice) String() string { return proto.CompactTextString(m) }
func (*DeploymentPrice_BackupPrice) ProtoMessage()    {}
func (*DeploymentPrice_BackupPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{32, 1}
}
func (m *DeploymentPrice_BackupPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentPrice_BackupPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentPrice_BackupPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentPrice_BackupPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentPrice_BackupPrice.Merge(m, src)
}
func (m *DeploymentPrice_BackupPrice) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentPrice_BackupPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentPrice_BackupPrice.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentPrice_BackupPrice proto.InternalMessageInfo

func (m *DeploymentPrice_BackupPrice) GetPricePerGbPerHour() float32 {
	if m != nil {
		return m.PricePerGbPerHour
	}
	return 0
}

type DeploymentPrice_AuditLogPrice struct {
	// Price per GB/hour of audit logs in cloud storage (destination=cloud)
	PricePerGbPerHour float32 `protobuf:"fixed32,1,opt,name=price_per_gb_per_hour,json=pricePerGbPerHour,proto3" json:"price_per_gb_per_hour,omitempty"`
	// Price per 1.000 HTTPS Post invocations (destination=https-post)
	HttpsPostInvocationPricePer_1000 float32 `protobuf:"fixed32,2,opt,name=https_post_invocation_price_per_1000,json=httpsPostInvocationPricePer1000,proto3" json:"https_post_invocation_price_per_1000,omitempty"`
	// Price per GB HTTPS Post body size (destination=https-post)
	HttpsPostBodySizePricePerGb float32  `protobuf:"fixed32,3,opt,name=https_post_body_size_price_per_gb,json=httpsPostBodySizePricePerGb,proto3" json:"https_post_body_size_price_per_gb,omitempty"`
	XXX_NoUnkeyedLiteral        struct{} `json:"-"`
	XXX_unrecognized            []byte   `json:"-"`
	XXX_sizecache               int32    `json:"-"`
}

func (m *DeploymentPrice_AuditLogPrice) Reset()         { *m = DeploymentPrice_AuditLogPrice{} }
func (m *DeploymentPrice_AuditLogPrice) String() string { return proto.CompactTextString(m) }
func (*DeploymentPrice_AuditLogPrice) ProtoMessage()    {}
func (*DeploymentPrice_AuditLogPrice) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{32, 2}
}
func (m *DeploymentPrice_AuditLogPrice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentPrice_AuditLogPrice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentPrice_AuditLogPrice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentPrice_AuditLogPrice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentPrice_AuditLogPrice.Merge(m, src)
}
func (m *DeploymentPrice_AuditLogPrice) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentPrice_AuditLogPrice) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentPrice_AuditLogPrice.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentPrice_AuditLogPrice proto.InternalMessageInfo

func (m *DeploymentPrice_AuditLogPrice) GetPricePerGbPerHour() float32 {
	if m != nil {
		return m.PricePerGbPerHour
	}
	return 0
}

func (m *DeploymentPrice_AuditLogPrice) GetHttpsPostInvocationPricePer_1000() float32 {
	if m != nil {
		return m.HttpsPostInvocationPricePer_1000
	}
	return 0
}

func (m *DeploymentPrice_AuditLogPrice) GetHttpsPostBodySizePricePerGb() float32 {
	if m != nil {
		return m.HttpsPostBodySizePricePerGb
	}
	return 0
}

// Features that are available to new deployments in a given context.
type DeploymentFeatures struct {
	// Is the use of an IAM provider available?
	Iamprovider          bool     `protobuf:"varint,1,opt,name=iamprovider,proto3" json:"iamprovider,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentFeatures) Reset()         { *m = DeploymentFeatures{} }
func (m *DeploymentFeatures) String() string { return proto.CompactTextString(m) }
func (*DeploymentFeatures) ProtoMessage()    {}
func (*DeploymentFeatures) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{33}
}
func (m *DeploymentFeatures) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentFeatures) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentFeatures.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentFeatures) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentFeatures.Merge(m, src)
}
func (m *DeploymentFeatures) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentFeatures) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentFeatures.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentFeatures proto.InternalMessageInfo

func (m *DeploymentFeatures) GetIamprovider() bool {
	if m != nil {
		return m.Iamprovider
	}
	return false
}

// Request arguments for GetDeploymentFeatures
type DeploymentFeaturesRequest struct {
	// Identifier of project that will own a deployment.
	ProjectId string `protobuf:"bytes,1,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Identifier of a region in which a deployment will be created.
	RegionId string `protobuf:"bytes,2,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// Model of the intended deployment.
	Model string `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
	// Node size use for the intended deployments
	NodeSizeId           string   `protobuf:"bytes,4,opt,name=node_size_id,json=nodeSizeId,proto3" json:"node_size_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeploymentFeaturesRequest) Reset()         { *m = DeploymentFeaturesRequest{} }
func (m *DeploymentFeaturesRequest) String() string { return proto.CompactTextString(m) }
func (*DeploymentFeaturesRequest) ProtoMessage()    {}
func (*DeploymentFeaturesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_871986018790d2fd, []int{34}
}
func (m *DeploymentFeaturesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeploymentFeaturesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeploymentFeaturesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeploymentFeaturesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeploymentFeaturesRequest.Merge(m, src)
}
func (m *DeploymentFeaturesRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeploymentFeaturesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeploymentFeaturesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeploymentFeaturesRequest proto.InternalMessageInfo

func (m *DeploymentFeaturesRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *DeploymentFeaturesRequest) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *DeploymentFeaturesRequest) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *DeploymentFeaturesRequest) GetNodeSizeId() string {
	if m != nil {
		return m.NodeSizeId
	}
	return ""
}

func init() {
	proto.RegisterType((*RotateDeploymentServerRequest)(nil), "arangodb.cloud.data.v1.RotateDeploymentServerRequest")
	proto.RegisterType((*CreateTestDatabaseResponse)(nil), "arangodb.cloud.data.v1.CreateTestDatabaseResponse")
	proto.RegisterType((*CreateTestDatabaseRequest)(nil), "arangodb.cloud.data.v1.CreateTestDatabaseRequest")
	proto.RegisterType((*RebalanceDeploymentShardsRequest)(nil), "arangodb.cloud.data.v1.RebalanceDeploymentShardsRequest")
	proto.RegisterType((*Deployment)(nil), "arangodb.cloud.data.v1.Deployment")
	proto.RegisterType((*Deployment_CertificateSpec)(nil), "arangodb.cloud.data.v1.Deployment.CertificateSpec")
	proto.RegisterType((*Deployment_ServersSpec)(nil), "arangodb.cloud.data.v1.Deployment.ServersSpec")
	proto.RegisterType((*Deployment_ModelSpec)(nil), "arangodb.cloud.data.v1.Deployment.ModelSpec")
	proto.RegisterType((*Deployment_ServerStatus)(nil), "arangodb.cloud.data.v1.Deployment.ServerStatus")
	proto.RegisterType((*Deployment_Status)(nil), "arangodb.cloud.data.v1.Deployment.Status")
	proto.RegisterType((*Deployment_BackupRestoreStatus)(nil), "arangodb.cloud.data.v1.Deployment.BackupRestoreStatus")
	proto.RegisterType((*Deployment_Expiration)(nil), "arangodb.cloud.data.v1.Deployment.Expiration")
	proto.RegisterType((*Deployment_BackupRestoreSpec)(nil), "arangodb.cloud.data.v1.Deployment.BackupRestoreSpec")
	proto.RegisterType((*NodeSize)(nil), "arangodb.cloud.data.v1.NodeSize")
	proto.RegisterType((*NodeSizeList)(nil), "arangodb.cloud.data.v1.NodeSizeList")
	proto.RegisterType((*NodeSizesRequest)(nil), "arangodb.cloud.data.v1.NodeSizesRequest")
	proto.RegisterType((*DeploymentModel)(nil), "arangodb.cloud.data.v1.DeploymentModel")
	proto.RegisterType((*DeploymentModelList)(nil), "arangodb.cloud.data.v1.DeploymentModelList")
	proto.RegisterType((*ListDeploymentModelsRequest)(nil), "arangodb.cloud.data.v1.ListDeploymentModelsRequest")
	proto.RegisterType((*CPUSize)(nil), "arangodb.cloud.data.v1.CPUSize")
	proto.RegisterType((*CPUSizeList)(nil), "arangodb.cloud.data.v1.CPUSizeList")
	proto.RegisterType((*ListCPUSizesRequest)(nil), "arangodb.cloud.data.v1.ListCPUSizesRequest")
	proto.RegisterType((*DeploymentCredentialsRequest)(nil), "arangodb.cloud.data.v1.DeploymentCredentialsRequest")
	proto.RegisterType((*DeploymentCredentials)(nil), "arangodb.cloud.data.v1.DeploymentCredentials")
	proto.RegisterType((*DeploymentList)(nil), "arangodb.cloud.data.v1.DeploymentList")
	proto.RegisterType((*Version)(nil), "arangodb.cloud.data.v1.Version")
	proto.RegisterType((*ReplaceVersionBy)(nil), "arangodb.cloud.data.v1.ReplaceVersionBy")
	proto.RegisterType((*UpgradeVersionRecommendation)(nil), "arangodb.cloud.data.v1.UpgradeVersionRecommendation")
	proto.RegisterType((*VersionList)(nil), "arangodb.cloud.data.v1.VersionList")
	proto.RegisterType((*ListVersionsRequest)(nil), "arangodb.cloud.data.v1.ListVersionsRequest")
	proto.RegisterType((*ServersSpecLimitsRequest)(nil), "arangodb.cloud.data.v1.ServersSpecLimitsRequest")
	proto.RegisterType((*ServersSpecLimits)(nil), "arangodb.cloud.data.v1.ServersSpecLimits")
	proto.RegisterType((*ServersSpecLimits_Limits)(nil), "arangodb.cloud.data.v1.ServersSpecLimits.Limits")
	proto.RegisterType((*CalculateDeploymentSizeRequest)(nil), "arangodb.cloud.data.v1.CalculateDeploymentSizeRequest")
	proto.RegisterType((*DeploymentSize)(nil), "arangodb.cloud.data.v1.DeploymentSize")
	proto.RegisterType((*DeploymentSizeRequest)(nil), "arangodb.cloud.data.v1.DeploymentSizeRequest")
	proto.RegisterType((*DeploymentSizeRecommendation)(nil), "arangodb.cloud.data.v1.DeploymentSizeRecommendation")
	proto.RegisterType((*DataVolumeInfo)(nil), "arangodb.cloud.data.v1.DataVolumeInfo")
	proto.RegisterType((*ConnectDriverInstructions)(nil), "arangodb.cloud.data.v1.ConnectDriverInstructions")
	proto.RegisterType((*ConnectDriverInstructions_DriverInstructions)(nil), "arangodb.cloud.data.v1.ConnectDriverInstructions.DriverInstructions")
	proto.RegisterType((*ImportDataInstructions)(nil), "arangodb.cloud.data.v1.ImportDataInstructions")
	proto.RegisterType((*DeploymentPriceRequest)(nil), "arangodb.cloud.data.v1.DeploymentPriceRequest")
	proto.RegisterType((*DeploymentPrice)(nil), "arangodb.cloud.data.v1.DeploymentPrice")
	proto.RegisterType((*DeploymentPrice_NetworkTransferPrice)(nil), "arangodb.cloud.data.v1.DeploymentPrice.NetworkTransferPrice")
	proto.RegisterType((*DeploymentPrice_BackupPrice)(nil), "arangodb.cloud.data.v1.DeploymentPrice.BackupPrice")
	proto.RegisterType((*DeploymentPrice_AuditLogPrice)(nil), "arangodb.cloud.data.v1.DeploymentPrice.AuditLogPrice")
	proto.RegisterType((*DeploymentFeatures)(nil), "arangodb.cloud.data.v1.DeploymentFeatures")
	proto.RegisterType((*DeploymentFeaturesRequest)(nil), "arangodb.cloud.data.v1.DeploymentFeaturesRequest")
}

func init() { proto.RegisterFile("data.proto", fileDescriptor_871986018790d2fd) }

var fileDescriptor_871986018790d2fd = []byte{
	// 4672 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x3b, 0x5b, 0x8c, 0x1d, 0x47,
	0x56, 0xf4, 0x9d, 0xf7, 0x99, 0x77, 0xd9, 0x33, 0x73, 0xe7, 0xfa, 0x35, 0xee, 0xc4, 0xf6, 0xd8,
	0xc9, 0xcc, 0xb5, 0x27, 0x89, 0xe5, 0xc4, 0x9b, 0x4d, 0xe6, 0x61, 0x3b, 0x83, 0xf2, 0x18, 0x7a,
	0x6c, 0xaf, 0xb4, 0xbb, 0xda, 0x56, 0xdd, 0xee, 0x9a, 0xeb, 0x8e, 0x6f, 0x3f, 0xb6, 0xab, 0x7a,
	0xe2, 0x89, 0x89, 0x22, 0xd0, 0x0a, 0xc1, 0x0f, 0x0b, 0x62, 0x91, 0xf2, 0xc3, 0x0f, 0x0f, 0x89,
	0x45, 0x02, 0xad, 0x84, 0xf8, 0x58, 0xf6, 0x03, 0x89, 0x2f, 0x40, 0x42, 0x02, 0xed, 0xcf, 0xee,
	0x1f, 0x04, 0x7e, 0xf8, 0x42, 0x02, 0xf1, 0x8f, 0xea, 0x54, 0x75, 0xdf, 0xee, 0xfb, 0xec, 0xb1,
	0xb2, 0xf0, 0xd7, 0x7d, 0xea, 0xbc, 0xea, 0xd4, 0x39, 0xa7, 0x4e, 0x9d, 0xea, 0x06, 0x70, 0xa9,
	0xa0, 0x9b, 0x51, 0x1c, 0x8a, 0x90, 0x2c, 0xd3, 0x98, 0x06, 0xcd, 0xd0, 0x6d, 0x6c, 0x3a, 0xad,
	0x30, 0x71, 0x37, 0x71, 0xe8, 0xf8, 0x56, 0x6d, 0xd9, 0x09, 0x7d, 0x3f, 0x0c, 0xea, 0xc7, 0xb7,
	0xea, 0xea, 0x49, 0xe1, 0xd7, 0xee, 0x36, 0x3d, 0xf1, 0x24, 0x69, 0x6c, 0x3a, 0xa1, 0x5f, 0x6f,
	0x86, 0x2d, 0x1a, 0x34, 0xeb, 0x38, 0xd0, 0x48, 0x8e, 0xea, 0x91, 0x38, 0x89, 0x18, 0xaf, 0x0b,
	0xcf, 0x67, 0x5c, 0x50, 0x3f, 0x6a, 0x3f, 0x69, 0xe2, 0xf3, 0xcd, 0x30, 0x6c, 0xb6, 0x58, 0x9d,
	0x46, 0x5e, 0x9d, 0x06, 0x41, 0x28, 0xa8, 0xf0, 0xc2, 0x80, 0xab, 0x51, 0x93, 0xc2, 0x05, 0x4b,
	0x82, 0xd8, 0x1e, 0x8b, 0x5a, 0xe1, 0x89, 0xcf, 0x02, 0x71, 0xc8, 0xe2, 0x63, 0x16, 0x5b, 0xec,
	0xbb, 0x09, 0xe3, 0x82, 0xbc, 0x04, 0xb3, 0x6e, 0x36, 0x64, 0x7b, 0x6e, 0xd5, 0x58, 0x33, 0xd6,
	0xa7, 0xac, 0x99, 0x36, 0x70, 0xdf, 0x25, 0xe7, 0x60, 0x8a, 0x23, 0x95, 0x44, 0xa8, 0x20, 0xc2,
	0xa4, 0x02, 0xec, 0xbb, 0xe6, 0x1f, 0x18, 0x50, 0xdb, 0x8d, 0x19, 0x15, 0xec, 0x21, 0xe3, 0x62,
	0x8f, 0x0a, 0xda, 0xa0, 0x9c, 0x59, 0x8c, 0x47, 0x61, 0xc0, 0x19, 0x59, 0x81, 0x09, 0xb7, 0x61,
	0x07, 0xd4, 0x67, 0x9a, 0xf5, 0xb8, 0xdb, 0xf8, 0x90, 0xfa, 0x8c, 0xd4, 0x60, 0x32, 0xe1, 0x2c,
	0xc6, 0x11, 0xcd, 0x33, 0x7d, 0x97, 0x63, 0x11, 0xe5, 0xfc, 0x93, 0x30, 0x76, 0xab, 0x23, 0x6a,
	0x2c, 0x7d, 0x97, 0x63, 0x4f, 0x42, 0x2e, 0x90, 0x6e, 0x54, 0x8d, 0xa5, 0xef, 0x84, 0xc0, 0x68,
	0x14, 0xc6, 0xa2, 0x3a, 0x86, 0x70, 0x7c, 0x36, 0xdf, 0x85, 0xd5, 0x5e, 0xea, 0x95, 0x9f, 0xbe,
	0xf9, 0x00, 0xd6, 0x2c, 0xd6, 0xa0, 0x2d, 0x1a, 0x38, 0x79, 0x3b, 0x3e, 0xa1, 0xb1, 0xcb, 0x4f,
	0xc5, 0xe8, 0x1f, 0xaf, 0x00, 0xb4, 0x19, 0x90, 0x39, 0xa8, 0x64, 0x88, 0x15, 0xcf, 0x25, 0x0b,
	0x30, 0x92, 0xc4, 0x2d, 0x6d, 0x0c, 0xf9, 0x28, 0xe7, 0x83, 0xf3, 0x54, 0x36, 0xc0, 0x67, 0xb2,
	0x06, 0xd3, 0x2e, 0xe3, 0x4e, 0xec, 0x45, 0x72, 0xa1, 0xb5, 0x09, 0xf2, 0x20, 0x72, 0x01, 0x20,
	0x8a, 0xc3, 0x8f, 0x99, 0x83, 0x8a, 0x28, 0x5b, 0x4c, 0x69, 0x88, 0x5a, 0xcd, 0x98, 0x35, 0xbd,
	0x30, 0x90, 0xa3, 0xe3, 0xca, 0x82, 0x0a, 0xb0, 0xef, 0x92, 0x37, 0x01, 0x1c, 0xb4, 0x96, 0x6b,
	0x53, 0x51, 0x9d, 0x58, 0x33, 0xd6, 0xa7, 0xb7, 0x6a, 0x9b, 0xca, 0xc7, 0x36, 0x53, 0xaf, 0xdc,
	0x7c, 0x98, 0x3a, 0xa1, 0x35, 0xa5, 0xb1, 0xb7, 0x85, 0x24, 0x75, 0x59, 0x8b, 0x69, 0xd2, 0xc9,
	0xe1, 0xa4, 0x1a, 0x7b, 0x5b, 0x48, 0x8d, 0x3d, 0x6e, 0xeb, 0xf7, 0xea, 0xd4, 0x9a, 0xb1, 0x3e,
	0x69, 0x4d, 0x79, 0x7c, 0x4f, 0x01, 0xc8, 0x55, 0x98, 0xe7, 0x49, 0x24, 0x57, 0xd3, 0x8e, 0x5a,
	0x14, 0xf5, 0x06, 0xd4, 0x7b, 0x56, 0x83, 0x0f, 0x5a, 0x54, 0x2a, 0x6f, 0xc2, 0x6c, 0xaa, 0x7c,
	0xe3, 0x44, 0x62, 0x4d, 0x2b, 0xe3, 0x68, 0xe0, 0xce, 0xc9, 0xbe, 0x4b, 0xee, 0xc3, 0x1a, 0x75,
	0x1c, 0x16, 0x49, 0x24, 0xc1, 0x62, 0x9f, 0xdb, 0x34, 0x70, 0x6d, 0x27, 0x0c, 0x5c, 0x0f, 0x03,
	0x47, 0x92, 0xcd, 0x20, 0xd9, 0xf9, 0x14, 0xef, 0xa1, 0x44, 0xdb, 0x0e, 0xdc, 0xdd, 0x0c, 0x69,
	0xdf, 0x25, 0xcb, 0x30, 0xde, 0x0a, 0x9d, 0xa7, 0xcc, 0xad, 0xce, 0xa2, 0xba, 0xfa, 0x4d, 0x5a,
	0xd7, 0xe3, 0x76, 0x44, 0x13, 0xce, 0xdc, 0xea, 0x59, 0x1c, 0x9a, 0xf4, 0xf8, 0x01, 0xbe, 0x93,
	0x77, 0x61, 0xae, 0x45, 0xb9, 0xd0, 0xc3, 0xd2, 0x4c, 0x4b, 0x43, 0xcd, 0x34, 0x23, 0x29, 0x14,
	0xfd, 0xb6, 0x20, 0x3b, 0x30, 0x8f, 0x1c, 0x62, 0xc6, 0x13, 0x5f, 0xb1, 0x58, 0x1e, 0xca, 0x62,
	0x56, 0x92, 0x58, 0x8a, 0x62, 0x5b, 0x90, 0x2d, 0x58, 0x8a, 0x62, 0x16, 0x51, 0xcf, 0xb5, 0x8b,
	0x3e, 0xbb, 0x82, 0xf3, 0x3e, 0xa3, 0x07, 0xf7, 0xf2, 0x29, 0xe0, 0xeb, 0x70, 0xce, 0xf5, 0x38,
	0x6d, 0xb4, 0x98, 0x7d, 0x14, 0x3e, 0x7b, 0x66, 0xd3, 0x44, 0x3c, 0x61, 0x81, 0xf0, 0x1c, 0x4c,
	0x37, 0xd5, 0x2a, 0x4e, 0x74, 0x55, 0xa3, 0xdc, 0x0f, 0x9f, 0x3d, 0xdb, 0x2e, 0x20, 0x90, 0x6f,
	0xc1, 0xf9, 0x1e, 0x32, 0xb9, 0xa0, 0xb1, 0xe0, 0x72, 0x12, 0xab, 0x43, 0x27, 0xb1, 0xda, 0xa5,
	0xd6, 0x21, 0x52, 0x6f, 0x0b, 0xf2, 0x0d, 0xa8, 0xf5, 0x60, 0xce, 0x02, 0x17, 0x59, 0xd7, 0x86,
	0xb2, 0x5e, 0xe9, 0x62, 0x7d, 0x2f, 0x70, 0x25, 0x63, 0x0b, 0xae, 0xca, 0xc5, 0xec, 0xe6, 0x9d,
	0x44, 0x2e, 0x15, 0xcc, 0xa6, 0xc7, 0xd4, 0x6b, 0xc9, 0x19, 0x57, 0xcf, 0xa1, 0x01, 0x4c, 0x8f,
	0x1f, 0x74, 0xb2, 0x7a, 0x84, 0xa8, 0xdb, 0x29, 0x26, 0xb9, 0x0e, 0x0b, 0x51, 0xec, 0x1d, 0x4b,
	0x72, 0x16, 0xb8, 0x51, 0xe8, 0x05, 0xa2, 0x7a, 0x11, 0xa9, 0xe7, 0x35, 0xfc, 0x9e, 0x06, 0x93,
	0x2a, 0x4c, 0x1c, 0xb3, 0x98, 0x4b, 0x03, 0x33, 0x5c, 0x9a, 0xf4, 0x95, 0x3c, 0x06, 0x12, 0xb3,
	0xa8, 0x45, 0x1d, 0x66, 0x6b, 0x90, 0xdd, 0x38, 0xa9, 0x3e, 0xc1, 0x99, 0xae, 0x6f, 0xf6, 0xde,
	0x7f, 0x36, 0x2d, 0x45, 0xf1, 0x58, 0x11, 0xec, 0x9c, 0x58, 0x0b, 0x71, 0x07, 0x84, 0x3c, 0x85,
	0xe5, 0x24, 0x6a, 0xc6, 0xd4, 0x65, 0x76, 0xcc, 0xe4, 0x26, 0xc5, 0x02, 0x57, 0xad, 0xb0, 0x87,
	0xbc, 0x5f, 0xef, 0xc7, 0xfb, 0x91, 0xa2, 0xd2, 0x9c, 0xac, 0x02, 0xad, 0xb5, 0xa4, 0x79, 0x16,
	0xc1, 0xe4, 0x31, 0xcc, 0x38, 0x2c, 0x16, 0xde, 0x91, 0x74, 0x12, 0xc6, 0xab, 0x47, 0x28, 0x62,
	0xab, 0x9f, 0x88, 0xb6, 0x49, 0x37, 0x77, 0xdb, 0x64, 0x87, 0x11, 0x73, 0xac, 0x02, 0x1f, 0xf2,
	0x1e, 0x4c, 0xa8, 0xdd, 0x89, 0x57, 0x9b, 0xc8, 0x72, 0xb3, 0x04, 0x4b, 0xb5, 0x2d, 0x72, 0x64,
	0x97, 0x92, 0x93, 0x2b, 0x30, 0xe7, 0x45, 0xb4, 0xd5, 0x0a, 0x3f, 0x69, 0x79, 0x1c, 0x43, 0xc4,
	0x57, 0x79, 0x27, 0x07, 0xdd, 0x77, 0xc9, 0x0e, 0x8c, 0xf9, 0xa1, 0xcb, 0x5a, 0xd5, 0x8f, 0x51,
	0xdc, 0xab, 0x25, 0xc4, 0x7d, 0x20, 0xf1, 0x51, 0x98, 0x22, 0x25, 0x97, 0x61, 0xc6, 0x49, 0xb8,
	0x08, 0x7d, 0xdb, 0xf3, 0x69, 0x93, 0x55, 0x9f, 0xea, 0xd4, 0x85, 0xb0, 0x7d, 0x09, 0x42, 0x6d,
	0xa8, 0x1f, 0xc5, 0xe1, 0xb1, 0xe7, 0xaa, 0xbd, 0xb8, 0xa5, 0xb5, 0x69, 0x43, 0x51, 0x9b, 0x71,
	0x2e, 0xa8, 0x48, 0x78, 0xf5, 0xef, 0x0d, 0xd4, 0xe7, 0x7a, 0x99, 0xe9, 0x23, 0x85, 0xa5, 0x29,
	0xc9, 0x5d, 0x18, 0xe5, 0xde, 0xa7, 0xac, 0xfa, 0x0f, 0x8a, 0xc3, 0xd5, 0xe1, 0x1c, 0x0e, 0xbd,
	0x4f, 0x99, 0x85, 0x44, 0xe4, 0x43, 0x00, 0xf6, 0x2c, 0xf2, 0x62, 0xe5, 0x38, 0x7f, 0x5e, 0x41,
	0x16, 0x1b, 0x25, 0x94, 0xb8, 0x97, 0x51, 0x59, 0x39, 0x0e, 0xe4, 0xdb, 0x30, 0xd7, 0xa0, 0xce,
	0xd3, 0x24, 0x92, 0x59, 0x4f, 0x84, 0x31, 0xab, 0xfe, 0xee, 0xc8, 0x60, 0x6f, 0xcc, 0xf1, 0xdc,
	0x41, 0x4a, 0x4b, 0x11, 0xa2, 0xc1, 0x67, 0x1b, 0x79, 0x10, 0x11, 0x50, 0xcb, 0x05, 0x76, 0xd1,
	0xeb, 0x79, 0xf5, 0x7f, 0x46, 0xd6, 0x46, 0xca, 0x49, 0x42, 0x03, 0x14, 0xfd, 0x7e, 0xb5, 0xcd,
	0xb8, 0x38, 0xc2, 0x65, 0x15, 0xe3, 0x71, 0xdb, 0x69, 0x85, 0x01, 0xab, 0xfe, 0x6c, 0x14, 0xc3,
	0x7f, 0xc2, 0xe3, 0xbb, 0xf2, 0x9d, 0x5c, 0x83, 0x79, 0x1c, 0xb0, 0xf5, 0xac, 0x3d, 0xb7, 0xfa,
	0x73, 0xb5, 0xcd, 0xcf, 0x22, 0x5c, 0x4d, 0x69, 0xdf, 0x25, 0xdb, 0x70, 0x3e, 0x08, 0xb5, 0xdf,
	0xcb, 0x14, 0xc0, 0x7c, 0xea, 0xb5, 0x6c, 0xea, 0xba, 0x31, 0xe3, 0x9c, 0xf1, 0xea, 0x97, 0xa3,
	0x6b, 0x23, 0xeb, 0x53, 0x56, 0x2d, 0x8f, 0x74, 0x4f, 0xe2, 0x6c, 0xa7, 0x28, 0x35, 0x1f, 0xe6,
	0x3b, 0x82, 0x89, 0xdc, 0x80, 0x45, 0x87, 0xda, 0xb9, 0x88, 0x6a, 0x97, 0x33, 0xf3, 0x0e, 0xcd,
	0x61, 0xef, 0xbb, 0x64, 0x13, 0xce, 0xd0, 0x96, 0x90, 0x55, 0x9b, 0x60, 0xb6, 0x1b, 0x70, 0x2c,
	0xf4, 0x78, 0xb5, 0x82, 0x72, 0x17, 0xb3, 0xa1, 0xbd, 0x80, 0xcb, 0x9a, 0x8f, 0xd7, 0xfe, 0xb3,
	0x02, 0xd3, 0xb9, 0x48, 0x23, 0x26, 0xcc, 0x38, 0x61, 0x18, 0xbb, 0x5e, 0x40, 0x45, 0x18, 0x73,
	0x14, 0x33, 0x66, 0x15, 0x60, 0xe4, 0x36, 0xac, 0xe4, 0xde, 0x6d, 0x9f, 0xf9, 0x61, 0x7c, 0x62,
	0xa3, 0x7b, 0x56, 0x10, 0x7d, 0x29, 0x37, 0xfc, 0x01, 0x8e, 0xca, 0xb5, 0x90, 0x89, 0x36, 0x4f,
	0x47, 0xe3, 0x26, 0xaf, 0x8e, 0xa0, 0x62, 0xf3, 0x39, 0xf8, 0x76, 0xdc, 0xe4, 0xe4, 0x3c, 0x4c,
	0xb9, 0x8d, 0x34, 0x67, 0x4c, 0x23, 0xd3, 0x36, 0x80, 0xdc, 0x84, 0xb3, 0xe9, 0x4b, 0x41, 0xfa,
	0x0c, 0x22, 0x92, 0x74, 0x2c, 0x27, 0xfa, 0x55, 0xc8, 0xa0, 0xb6, 0xeb, 0xf1, 0xa7, 0x0a, 0x7f,
	0x16, 0xf1, 0x17, 0xd2, 0x91, 0x3d, 0x8f, 0x3f, 0x45, 0x6c, 0x59, 0x3b, 0xa6, 0xd8, 0xa8, 0xe5,
	0x1c, 0x6a, 0x39, 0x93, 0x02, 0x51, 0xc5, 0xdb, 0xb0, 0xe2, 0x7b, 0x81, 0xe7, 0x27, 0xbe, 0x9d,
	0x69, 0x66, 0x3b, 0x61, 0x12, 0x88, 0xea, 0xbc, 0xb2, 0x82, 0x1e, 0xde, 0x4b, 0x47, 0x77, 0xe5,
	0x60, 0xed, 0x37, 0x0d, 0x98, 0xca, 0x92, 0x0d, 0x39, 0x9b, 0x66, 0x2a, 0xb5, 0x9e, 0x3a, 0xf7,
	0xac, 0xc1, 0x4c, 0x10, 0xba, 0x0c, 0xb5, 0x6c, 0x97, 0xf8, 0x20, 0x61, 0x52, 0xc1, 0x7d, 0x57,
	0x16, 0x68, 0x88, 0xa1, 0x04, 0x8e, 0x28, 0x0b, 0x49, 0x08, 0x0a, 0x21, 0x2f, 0xc3, 0x1c, 0x0e,
	0xb7, 0xe7, 0x3a, 0xaa, 0x16, 0x52, 0x42, 0xd3, 0x79, 0xd6, 0x7e, 0x34, 0x0e, 0x33, 0x6a, 0xf1,
	0x55, 0xb6, 0xe9, 0x2a, 0x80, 0x09, 0x8c, 0xca, 0xe3, 0x8e, 0x96, 0x8f, 0xcf, 0x9d, 0xe5, 0xee,
	0x48, 0x77, 0xb9, 0x5b, 0x2c, 0x59, 0x47, 0x4f, 0x53, 0xb2, 0x9e, 0x85, 0xb1, 0x98, 0x51, 0xf7,
	0x04, 0x8b, 0xe4, 0x49, 0x4b, 0xbd, 0xc8, 0x00, 0xf0, 0x99, 0xdf, 0x60, 0xb1, 0x1d, 0x1e, 0xd9,
	0x4e, 0x2b, 0xe1, 0x82, 0xc5, 0x58, 0x28, 0x4f, 0x5a, 0xf3, 0x6a, 0xe0, 0xa3, 0xa3, 0x5d, 0x05,
	0x96, 0x65, 0xe0, 0x11, 0xf5, 0x5a, 0xcc, 0xc5, 0x5a, 0x79, 0xd2, 0xd2, 0x6f, 0x32, 0xbe, 0x51,
	0x8c, 0x17, 0x34, 0xb1, 0x14, 0x9e, 0xb4, 0xb2, 0x77, 0x39, 0xed, 0xf0, 0xa9, 0xae, 0x72, 0x2b,
	0xe1, 0x53, 0x59, 0xf7, 0x37, 0xa8, 0x5b, 0x9d, 0x43, 0x80, 0x7c, 0x94, 0xfe, 0xa8, 0xb6, 0x4c,
	0x49, 0x0e, 0xaa, 0x1c, 0xce, 0x00, 0xf9, 0xb2, 0x60, 0xba, 0x58, 0x16, 0xa4, 0xd5, 0x21, 0xd6,
	0x55, 0xca, 0x1e, 0x33, 0xe5, 0xaa, 0xc3, 0x43, 0x45, 0xb1, 0x2d, 0x64, 0xd8, 0xc4, 0xfa, 0x14,
	0x69, 0x47, 0x2c, 0x40, 0x15, 0x54, 0x89, 0x3b, 0x9f, 0xc2, 0x0f, 0x14, 0x58, 0x2e, 0xbb, 0x43,
	0x03, 0xbb, 0xc1, 0xb2, 0xd2, 0x7d, 0x1e, 0x11, 0x67, 0x1c, 0x1a, 0xec, 0xb0, 0xb4, 0x7a, 0x57,
	0x15, 0x71, 0x8b, 0x51, 0x97, 0xc5, 0xd5, 0x85, 0xb4, 0x22, 0x7e, 0x1f, 0xdf, 0xc9, 0x01, 0x2c,
	0xc8, 0x54, 0x6a, 0x1f, 0x87, 0xad, 0xc4, 0x67, 0xb6, 0x17, 0x1c, 0x85, 0x58, 0x35, 0x0f, 0xda,
	0x73, 0xa8, 0xa0, 0x8f, 0x11, 0x7d, 0x3f, 0x38, 0x0a, 0xad, 0x39, 0xb7, 0xf0, 0x2e, 0xb3, 0x67,
	0xcc, 0x1c, 0x95, 0xcb, 0x55, 0x7d, 0x89, 0xe5, 0xd5, 0x98, 0x35, 0xa7, 0xc0, 0x96, 0x86, 0xca,
	0x65, 0x46, 0x63, 0xe9, 0x90, 0x4e, 0xb8, 0xdc, 0x76, 0x2f, 0xad, 0x19, 0xeb, 0x23, 0x16, 0x5a,
	0x51, 0xc5, 0xf3, 0x23, 0x09, 0x96, 0x33, 0x45, 0x5c, 0x27, 0x4a, 0x34, 0xe2, 0xda, 0x9a, 0xb1,
	0x5e, 0x51, 0xc5, 0xf9, 0x6e, 0x94, 0x28, 0xac, 0x0e, 0x8e, 0x2d, 0xcf, 0xf7, 0x44, 0xf5, 0x72,
	0x27, 0xc7, 0xf7, 0x25, 0xb8, 0xc0, 0x51, 0x21, 0x9a, 0x05, 0x8e, 0x88, 0x55, 0xfb, 0xb5, 0x31,
	0x18, 0xd7, 0xc1, 0x52, 0x83, 0xc9, 0xac, 0x5e, 0x54, 0x21, 0x93, 0xbd, 0x77, 0x06, 0x49, 0xa5,
	0x3b, 0x48, 0xaa, 0x30, 0xa1, 0xdd, 0x1e, 0x43, 0x68, 0xd2, 0x4a, 0x5f, 0xdb, 0x31, 0x30, 0x9a,
	0x8f, 0x81, 0x82, 0x07, 0x8e, 0x75, 0x7a, 0xe0, 0x35, 0x98, 0xd7, 0xf9, 0x4a, 0x7b, 0x1e, 0xaf,
	0x8e, 0x63, 0xce, 0x9a, 0x53, 0x60, 0x5d, 0x06, 0x72, 0xb2, 0xdf, 0x2e, 0xc5, 0x26, 0x70, 0x23,
	0xad, 0x97, 0x2e, 0xc5, 0x74, 0x45, 0x92, 0xd5, 0x62, 0xbb, 0x30, 0xdf, 0x08, 0x43, 0xc1, 0x45,
	0x4c, 0xa3, 0xa8, 0xec, 0x19, 0x73, 0x2e, 0x4f, 0xb2, 0x2d, 0xe4, 0x7e, 0x93, 0x87, 0xe8, 0x20,
	0x2c, 0xc0, 0x64, 0xba, 0x4f, 0x0d, 0x6b, 0x73, 0xd6, 0x3a, 0xb2, 0xb9, 0xd7, 0x0c, 0x58, 0x7a,
	0xe4, 0x24, 0xe9, 0xd8, 0x21, 0x6b, 0x1d, 0x1d, 0xe2, 0x08, 0xf9, 0x18, 0x96, 0x8a, 0x05, 0x8a,
	0xad, 0x0b, 0x30, 0x17, 0x15, 0xbc, 0x7d, 0xea, 0x32, 0x45, 0x4d, 0xfd, 0x4c, 0xa3, 0x1b, 0x48,
	0xde, 0x80, 0x15, 0x11, 0x0a, 0xda, 0x4a, 0x8b, 0x03, 0xcc, 0xd9, 0x8d, 0x13, 0x59, 0x3f, 0x33,
	0xf4, 0xb4, 0xb3, 0x38, 0xac, 0xf8, 0xc9, 0xb4, 0xbb, 0x23, 0xc7, 0xc8, 0x9b, 0xb0, 0xaa, 0x09,
	0x92, 0xa8, 0x15, 0x52, 0xd7, 0xf6, 0x02, 0x3b, 0x8a, 0xc3, 0xa6, 0x2c, 0x03, 0xb0, 0xf0, 0x9e,
	0xb4, 0x96, 0x15, 0xc2, 0x23, 0x1c, 0xdf, 0x0f, 0x0e, 0xf4, 0x68, 0xed, 0xb7, 0x0d, 0x38, 0xd3,
	0x43, 0x3d, 0xe9, 0x90, 0x31, 0x3b, 0xf6, 0x30, 0x0f, 0xa9, 0x7d, 0x3b, 0x7b, 0x97, 0xee, 0xa3,
	0x4c, 0x91, 0x4b, 0x60, 0x19, 0x40, 0x26, 0x4d, 0x6d, 0x20, 0x95, 0xbf, 0xd2, 0xaa, 0xf3, 0x0a,
	0xcc, 0xc9, 0xf4, 0x99, 0xc4, 0xf2, 0xf4, 0x41, 0x79, 0x18, 0xe8, 0x93, 0xf8, 0xac, 0x86, 0x5a,
	0x08, 0xac, 0xfd, 0xb7, 0x01, 0xd0, 0x2e, 0x15, 0x65, 0xfe, 0xc7, 0x62, 0x91, 0xe1, 0x69, 0xcf,
	0x18, 0x9e, 0xff, 0x35, 0xf6, 0xb6, 0x90, 0x8a, 0x68, 0x41, 0x2a, 0x64, 0xf4, 0x1b, 0x79, 0x0c,
	0x35, 0x0c, 0xce, 0x4f, 0x68, 0x1c, 0x78, 0x41, 0x53, 0x17, 0x56, 0x9c, 0x05, 0xe8, 0x76, 0x23,
	0x43, 0x45, 0x2c, 0x4b, 0xea, 0x6f, 0x28, 0x62, 0x2c, 0xb8, 0x0e, 0x59, 0x20, 0xdd, 0xef, 0xad,
	0xfe, 0x7c, 0x45, 0x58, 0x55, 0xd5, 0x5a, 0x4f, 0xda, 0x87, 0x61, 0xed, 0x77, 0x0c, 0x58, 0xec,
	0x2a, 0x66, 0x07, 0x2e, 0x42, 0xba, 0x1b, 0xa8, 0xc3, 0x2a, 0xaa, 0x5e, 0x29, 0xb7, 0x1b, 0xa8,
	0x33, 0xab, 0xd4, 0xf8, 0x1c, 0x4c, 0xb5, 0xab, 0x50, 0x15, 0x01, 0x93, 0x0d, 0x5d, 0x7f, 0x9a,
	0xff, 0x6c, 0xc0, 0xe4, 0x87, 0xba, 0x48, 0xe8, 0xb5, 0x99, 0xe7, 0x7a, 0x7b, 0xaa, 0x77, 0x75,
	0x09, 0xa6, 0xf3, 0x05, 0x94, 0xaa, 0x23, 0xc0, 0x6f, 0x17, 0x4e, 0x26, 0xcc, 0xfa, 0x5e, 0xd0,
	0x55, 0x47, 0x4c, 0xfb, 0x5e, 0x90, 0x95, 0x4b, 0x12, 0x87, 0x3e, 0xcb, 0xe1, 0x8c, 0x69, 0x1c,
	0xfa, 0x2c, 0xc3, 0x59, 0x85, 0x49, 0x99, 0x58, 0x71, 0x58, 0xb5, 0xb8, 0x26, 0x9c, 0x28, 0xc1,
	0xa1, 0x0b, 0x00, 0x19, 0xa9, 0xca, 0x4a, 0xb2, 0xd8, 0xd3, 0x84, 0xdc, 0xbc, 0x0f, 0x33, 0xe9,
	0x94, 0xde, 0xf7, 0xb8, 0x20, 0xb7, 0x61, 0xcc, 0x13, 0xcc, 0x97, 0xa5, 0xa9, 0xcc, 0x5f, 0x6b,
	0xfd, 0x62, 0x39, 0x25, 0xb2, 0x14, 0xba, 0xf9, 0x5b, 0x06, 0x2c, 0xa4, 0xb0, 0xac, 0x4b, 0x58,
	0xec, 0xcc, 0x19, 0x03, 0x3b, 0x73, 0x95, 0x8e, 0xce, 0x5c, 0x57, 0x87, 0x71, 0xa4, 0x47, 0xa7,
	0x36, 0xab, 0xef, 0x46, 0x73, 0xf5, 0x9d, 0xf9, 0x06, 0xcc, 0xb7, 0x53, 0x0d, 0x16, 0x83, 0x65,
	0x56, 0xcb, 0x7c, 0x08, 0x67, 0x3a, 0xc8, 0xd0, 0x22, 0x6f, 0x17, 0x2d, 0x72, 0x6d, 0x78, 0x76,
	0x43, 0xda, 0xd4, 0x30, 0x5f, 0x83, 0x73, 0x92, 0x4d, 0xc7, 0x68, 0x49, 0x13, 0x99, 0x1b, 0x30,
	0xb1, 0x7b, 0xf0, 0xa8, 0xac, 0xc3, 0x99, 0x7b, 0x30, 0xad, 0xd1, 0x51, 0xf5, 0x37, 0x8a, 0xaa,
	0x5f, 0xea, 0xa7, 0xba, 0xa6, 0x49, 0x55, 0x7e, 0x1d, 0xce, 0x48, 0x72, 0x0d, 0x2d, 0xab, 0xea,
	0xb7, 0xe0, 0x7c, 0x7b, 0x92, 0xbb, 0x31, 0x73, 0x59, 0x20, 0x3c, 0xda, 0x3a, 0x55, 0xcb, 0xb8,
	0x5f, 0x86, 0x32, 0x3f, 0x82, 0xa5, 0x9e, 0xcc, 0x0b, 0x6d, 0x75, 0x63, 0x40, 0x5b, 0xbd, 0x52,
	0x6c, 0xab, 0x9b, 0xdf, 0x33, 0x60, 0xae, 0xcd, 0x11, 0xad, 0x75, 0xa7, 0x68, 0x2d, 0x73, 0xf8,
	0x42, 0x6b, 0x83, 0x91, 0x3b, 0x30, 0xde, 0x48, 0xdc, 0x26, 0x4b, 0x13, 0x4e, 0x57, 0xd4, 0xe8,
	0xfb, 0x8f, 0xe3, 0x5b, 0x9b, 0x3b, 0x88, 0x67, 0x69, 0x7c, 0xf3, 0xe7, 0x06, 0x4c, 0xe8, 0xea,
	0x21, 0x5f, 0xe7, 0x1a, 0xc5, 0x3a, 0xf7, 0x01, 0x40, 0xda, 0xfe, 0x6a, 0x9c, 0x68, 0x19, 0xe5,
	0xdb, 0x5e, 0x53, 0x9a, 0x76, 0x60, 0xbf, 0x6b, 0xe4, 0x2b, 0xef, 0x77, 0x99, 0x7b, 0xb0, 0xd0,
	0xa9, 0xcb, 0x80, 0x39, 0xf6, 0x5b, 0xf9, 0x03, 0x38, 0x3f, 0x48, 0xf8, 0x0b, 0x70, 0xdc, 0x83,
	0x69, 0xcd, 0xea, 0x54, 0x41, 0x92, 0x8a, 0xd7, 0x41, 0xf2, 0xa7, 0x86, 0x8a, 0x92, 0xb4, 0xf6,
	0x4b, 0xdd, 0xfc, 0x1d, 0x98, 0x08, 0x23, 0xd5, 0x4c, 0x51, 0x7b, 0xf3, 0x95, 0xfe, 0xce, 0x20,
	0xe9, 0x3f, 0x52, 0xc8, 0x56, 0x4a, 0x25, 0x8b, 0xcd, 0x30, 0x6e, 0xd2, 0xc0, 0xfb, 0x54, 0x1d,
	0x4a, 0xb2, 0xdc, 0x38, 0x97, 0x07, 0xef, 0xbb, 0xd8, 0x37, 0x49, 0xe2, 0x58, 0x46, 0x53, 0x6a,
	0x01, 0x95, 0x23, 0xe7, 0x34, 0x58, 0xab, 0x66, 0x3e, 0x87, 0x6a, 0xae, 0x09, 0x81, 0x95, 0xf6,
	0xff, 0x59, 0x8a, 0x36, 0xff, 0x63, 0x0c, 0x16, 0xbb, 0xa4, 0x93, 0x87, 0x3d, 0x1a, 0x21, 0xd3,
	0x5b, 0x37, 0xfb, 0xd9, 0xbe, 0x8b, 0xc1, 0xa6, 0x9e, 0x45, 0xb1, 0x75, 0xf2, 0x64, 0x70, 0xeb,
	0xe4, 0x45, 0x04, 0xf4, 0x69, 0xb6, 0x7c, 0xd8, 0xd9, 0x41, 0x79, 0x11, 0xde, 0xb9, 0x9e, 0x4b,
	0x63, 0x40, 0xcf, 0xe5, 0x45, 0x58, 0xf7, 0xea, 0xd2, 0x7c, 0xa7, 0x6f, 0x97, 0xe6, 0x45, 0x24,
	0x74, 0xf7, 0x75, 0xbe, 0x09, 0x0b, 0xd8, 0x15, 0xc9, 0xeb, 0xbf, 0xf4, 0x82, 0xdc, 0xb1, 0xbf,
	0x92, 0xd3, 0xfd, 0xa3, 0x42, 0x43, 0x66, 0xf9, 0x45, 0x0d, 0x9e, 0xb5, 0x70, 0x6a, 0x87, 0x30,
	0xae, 0x5d, 0x71, 0x01, 0x46, 0x7c, 0x2f, 0xad, 0x26, 0xe5, 0x23, 0x42, 0xe8, 0x33, 0xdd, 0x6d,
	0x93, 0x8f, 0xb2, 0x52, 0xc7, 0x06, 0x38, 0x73, 0xed, 0x63, 0xda, 0x4a, 0x98, 0xea, 0xac, 0x8d,
	0x59, 0xb3, 0x1a, 0xfa, 0x18, 0x81, 0xe6, 0x0f, 0x46, 0xe0, 0xe2, 0x2e, 0x6d, 0x39, 0x49, 0xab,
	0x78, 0x05, 0x8d, 0xad, 0x52, 0x15, 0x6f, 0xbf, 0xc8, 0x0e, 0xe0, 0xff, 0x6f, 0x5b, 0x2f, 0xab,
	0xc5, 0x96, 0x06, 0xf5, 0xda, 0x96, 0x87, 0xf4, 0xda, 0x56, 0x86, 0xf7, 0xda, 0xcc, 0xee, 0x5e,
	0x5b, 0x31, 0x4f, 0x6d, 0x15, 0xf3, 0x94, 0xf9, 0x67, 0x23, 0xf9, 0xbd, 0x1e, 0xf1, 0x97, 0x61,
	0x9c, 0x36, 0x59, 0x20, 0xd2, 0x05, 0xd0, 0x6f, 0xe4, 0x06, 0x2c, 0xe2, 0x53, 0x0f, 0xa3, 0xcf,
	0xe3, 0x40, 0xce, 0x3c, 0x57, 0x41, 0x81, 0x72, 0xaa, 0xa9, 0x0a, 0x7f, 0x16, 0xc1, 0x99, 0x6e,
	0x37, 0x60, 0x51, 0x1d, 0x61, 0xf3, 0x3c, 0xd5, 0xf2, 0xcc, 0xe3, 0x40, 0x91, 0xa7, 0xc2, 0x6d,
	0xf3, 0x54, 0xeb, 0x33, 0x8b, 0xe0, 0xdc, 0xa1, 0xa0, 0xe8, 0x46, 0x4b, 0xa7, 0x73, 0xa3, 0xe5,
	0xd2, 0x6e, 0x74, 0xa9, 0xac, 0x1b, 0xad, 0x9d, 0xd2, 0x8d, 0x2e, 0xf7, 0x76, 0x23, 0xf3, 0xa7,
	0xa3, 0xf9, 0x52, 0x2f, 0x1f, 0x3a, 0x97, 0x61, 0x46, 0x46, 0x38, 0x67, 0x42, 0x71, 0x50, 0x2b,
	0x37, 0xad, 0x61, 0x28, 0xaa, 0x0a, 0x13, 0x09, 0x67, 0x0e, 0xe5, 0x69, 0x59, 0x9c, 0xbe, 0xb6,
	0xbd, 0x73, 0x24, 0xef, 0x9d, 0x97, 0x60, 0xfa, 0xc8, 0xc3, 0x3b, 0xde, 0xd8, 0xd7, 0xcd, 0xd4,
	0x29, 0x0b, 0x24, 0xe8, 0x3e, 0x42, 0xc8, 0x26, 0x9c, 0x09, 0x92, 0xb4, 0x37, 0xea, 0x86, 0x4e,
	0xe2, 0xa3, 0xd3, 0x8c, 0x61, 0xeb, 0x61, 0x51, 0x0d, 0x7d, 0x74, 0xb4, 0x97, 0x0e, 0xc8, 0xb5,
	0x6e, 0xe3, 0x3b, 0x61, 0x2b, 0xf1, 0xb1, 0x57, 0x84, 0x6b, 0x9d, 0x62, 0xef, 0x2a, 0x30, 0x79,
	0x1d, 0x96, 0x3f, 0x09, 0xe3, 0xa7, 0xf2, 0x60, 0x2c, 0xe7, 0x14, 0xb1, 0xd8, 0x61, 0x81, 0xa0,
	0x4d, 0x86, 0xbd, 0xd5, 0x8a, 0x75, 0x56, 0x8f, 0x1e, 0x32, 0x71, 0x90, 0x8d, 0x49, 0x2a, 0xea,
	0x38, 0x8c, 0x73, 0x3b, 0x66, 0xd4, 0xcd, 0x53, 0x4d, 0x2a, 0x2a, 0x35, 0x6a, 0x31, 0xea, 0xe6,
	0xa8, 0xee, 0x40, 0x55, 0x53, 0xa9, 0x3e, 0x58, 0x9e, 0x6e, 0x0a, 0xe9, 0x34, 0x57, 0xf5, 0xed,
	0x48, 0x4f, 0x4a, 0x7d, 0x09, 0x9c, 0xa3, 0x84, 0x3c, 0xa5, 0x3a, 0x44, 0xe7, 0x28, 0x2f, 0xc1,
	0x74, 0x33, 0x0e, 0x3f, 0x11, 0x4f, 0xec, 0x98, 0x0a, 0xe5, 0xf1, 0x15, 0x0b, 0x14, 0xc8, 0xa2,
	0x82, 0x91, 0x0d, 0x75, 0xab, 0x9b, 0x5e, 0xe7, 0x1c, 0x51, 0x47, 0x84, 0xb1, 0xf6, 0xf7, 0xc5,
	0xdc, 0xc8, 0x7d, 0x1c, 0xe8, 0x28, 0x55, 0x96, 0x06, 0x96, 0x2a, 0xcb, 0x1d, 0x29, 0xe0, 0x5f,
	0x2b, 0xf9, 0xd3, 0x49, 0xf7, 0xdd, 0x15, 0x79, 0x00, 0x13, 0xb1, 0xf2, 0x33, 0x5d, 0x8b, 0x6c,
	0x94, 0xbd, 0x02, 0x43, 0x22, 0x2b, 0xa5, 0xee, 0x68, 0xcf, 0x57, 0x4e, 0xd3, 0x9e, 0x5f, 0xef,
	0xb1, 0x81, 0xaa, 0x3c, 0xd1, 0xb9, 0x1d, 0x76, 0x27, 0xc5, 0x99, 0x1e, 0x49, 0xb1, 0x98, 0x59,
	0x67, 0x3b, 0x33, 0xeb, 0x4b, 0x30, 0xcb, 0x9e, 0x39, 0x8c, 0xb9, 0xdc, 0xfe, 0x6e, 0x12, 0x0a,
	0x8a, 0x26, 0x9d, 0xb4, 0x66, 0x34, 0xf0, 0x57, 0x24, 0x8c, 0x5c, 0x87, 0x85, 0x14, 0x29, 0x6a,
	0x51, 0x21, 0x03, 0x05, 0x8d, 0x3b, 0x69, 0xcd, 0x6b, 0xf8, 0x81, 0x06, 0x9b, 0x7f, 0x52, 0x81,
	0xb9, 0x62, 0xb3, 0x5a, 0xba, 0x80, 0xee, 0xde, 0x61, 0xc7, 0xce, 0xc0, 0xb0, 0x01, 0xd5, 0xb1,
	0xc3, 0x3e, 0xdd, 0x05, 0x00, 0xfc, 0x34, 0x44, 0x8d, 0x57, 0x70, 0x7c, 0x4a, 0x42, 0xd4, 0xf0,
	0x35, 0x98, 0xcf, 0xbe, 0x39, 0xd0, 0x38, 0x23, 0x88, 0x33, 0x97, 0x81, 0x15, 0xe2, 0x65, 0x98,
	0x51, 0x82, 0x3c, 0x39, 0x3f, 0x8e, 0x91, 0x3c, 0x62, 0x29, 0xe1, 0xfb, 0x08, 0x92, 0xba, 0xa0,
	0x28, 0x8d, 0xa1, 0x42, 0x18, 0xa5, 0x6b, 0x84, 0xeb, 0xb0, 0xd0, 0x16, 0xa6, 0xb1, 0xc6, 0x55,
	0x37, 0x3b, 0x83, 0x6b, 0xd4, 0xbb, 0x30, 0xed, 0x33, 0xca, 0x93, 0x58, 0xad, 0x32, 0x0c, 0x5d,
	0x65, 0x48, 0xd1, 0xb7, 0x85, 0xf9, 0x5f, 0x06, 0xac, 0xee, 0x86, 0x41, 0xc0, 0x1c, 0xb1, 0x17,
	0x7b, 0xc7, 0x2c, 0xde, 0x0f, 0xb8, 0x88, 0x13, 0x47, 0x95, 0xff, 0xdf, 0x81, 0x09, 0x17, 0xa1,
	0xe9, 0x81, 0x64, 0xaf, 0xef, 0xa9, 0xbd, 0x1f, 0x8f, 0xcd, 0x6e, 0x90, 0x95, 0x32, 0xad, 0x25,
	0x40, 0x7a, 0x48, 0x4d, 0x9b, 0x09, 0x46, 0xae, 0x7b, 0x45, 0x60, 0xd4, 0x09, 0x5d, 0xa6, 0x6f,
	0x37, 0xf1, 0x59, 0x26, 0xd8, 0x98, 0xf9, 0x34, 0x7e, 0x9a, 0xde, 0x2d, 0xa6, 0xaf, 0xd8, 0x67,
	0x42, 0xbe, 0x76, 0x12, 0xa7, 0xfd, 0x98, 0x29, 0x05, 0x79, 0x14, 0xb7, 0xcc, 0xbf, 0x31, 0x60,
	0x79, 0xdf, 0x8f, 0xc2, 0x18, 0xbf, 0x49, 0x2b, 0xc8, 0xbe, 0x04, 0xd3, 0x1e, 0x8e, 0xd8, 0x6e,
	0xe2, 0x47, 0x5a, 0x1c, 0x28, 0xd0, 0x5e, 0xe2, 0x47, 0x72, 0x03, 0x51, 0x26, 0xb0, 0x35, 0xde,
	0xc7, 0x1c, 0xcf, 0x3a, 0x12, 0x6f, 0x41, 0x8d, 0x28, 0xd6, 0xbf, 0xcc, 0xc3, 0x00, 0xb7, 0xf0,
	0x02, 0xb6, 0xc3, 0x8f, 0x75, 0xaf, 0x71, 0x3e, 0x8f, 0xbc, 0xcb, 0x8f, 0xbb, 0x71, 0x05, 0x3f,
	0xae, 0x8e, 0x75, 0xe3, 0x3e, 0xe4, 0xc7, 0xe6, 0x5f, 0x8e, 0xc2, 0x72, 0x3b, 0xf6, 0x0f, 0x62,
	0xcf, 0xc9, 0x76, 0xa6, 0x1e, 0x47, 0x36, 0xa3, 0xe7, 0x91, 0xad, 0x98, 0xc2, 0x2a, 0x9d, 0x29,
	0xac, 0xc7, 0x87, 0x5f, 0x23, 0xbd, 0x3e, 0xfc, 0xba, 0x01, 0x8b, 0xe8, 0x0a, 0x76, 0xfe, 0xe3,
	0x88, 0x51, 0x7d, 0x65, 0x2d, 0x07, 0x0e, 0xda, 0x9f, 0x47, 0x5c, 0x05, 0x05, 0xb2, 0xdb, 0xc9,
	0x71, 0x2c, 0xbb, 0x5c, 0x4f, 0x5c, 0x2b, 0x3d, 0xcc, 0x65, 0x1b, 0xe4, 0xf8, 0xa0, 0xf2, 0x6d,
	0x62, 0x48, 0xf9, 0x36, 0x39, 0xbc, 0x7c, 0x9b, 0xea, 0x91, 0xa9, 0x3a, 0xcb, 0x19, 0x38, 0x5d,
	0x39, 0x33, 0x5d, 0xba, 0x9c, 0x99, 0x29, 0x5b, 0xce, 0xcc, 0x9e, 0xb2, 0x9c, 0x99, 0xeb, 0x53,
	0xce, 0xfc, 0x64, 0x3c, 0xdf, 0x8c, 0x44, 0xaf, 0x91, 0x36, 0x89, 0xe4, 0x83, 0xdc, 0x4a, 0xed,
	0x27, 0x61, 0x12, 0xa3, 0xb7, 0x54, 0xac, 0x19, 0x84, 0x1e, 0xb0, 0xf8, 0xbd, 0x30, 0x89, 0x89,
	0x80, 0x95, 0x80, 0x09, 0x59, 0x03, 0xd8, 0x22, 0xa6, 0x01, 0x3f, 0x62, 0xb1, 0x8d, 0x08, 0xea,
	0x7b, 0x83, 0xe9, 0xad, 0xaf, 0x0d, 0xdf, 0xa1, 0x50, 0xde, 0xe6, 0x87, 0x8a, 0xcd, 0x43, 0xcd,
	0x45, 0xb9, 0xee, 0x52, 0xd0, 0x03, 0xca, 0xc9, 0x63, 0x98, 0xd1, 0x0d, 0x70, 0x94, 0xa5, 0xfb,
	0x42, 0xaf, 0x95, 0x15, 0xa5, 0x3a, 0xf6, 0x4a, 0xc2, 0x74, 0xa3, 0xfd, 0x22, 0x83, 0x5c, 0x75,
	0x25, 0x9c, 0x93, 0xb6, 0xb3, 0x42, 0x0a, 0xda, 0x77, 0xc9, 0xb7, 0x61, 0x8e, 0x26, 0xae, 0x27,
	0x5a, 0x61, 0x53, 0x8b, 0x1e, 0x43, 0xd1, 0x6f, 0x94, 0x15, 0xbd, 0x2d, 0xa9, 0xdf, 0x0f, 0x9b,
	0x4a, 0xf8, 0x6c, 0xca, 0x0c, 0x5f, 0x6b, 0x5f, 0x18, 0x70, 0xb6, 0x97, 0x19, 0x48, 0x1d, 0xce,
	0x7a, 0x01, 0x5e, 0xfc, 0xd8, 0xed, 0x35, 0x69, 0x36, 0xf4, 0x8a, 0x2c, 0xea, 0xb1, 0x03, 0xbd,
	0x30, 0x0f, 0x1a, 0x64, 0x03, 0xce, 0xb0, 0x1e, 0xf8, 0x15, 0xc4, 0x5f, 0x60, 0x9d, 0xe8, 0x43,
	0xef, 0xf3, 0x6b, 0xef, 0xc0, 0x74, 0xce, 0x6a, 0xe4, 0x26, 0x2c, 0xe5, 0x19, 0x77, 0xfa, 0xc8,
	0x62, 0x94, 0xf1, 0xd6, 0x8e, 0x52, 0xfb, 0x99, 0x01, 0xb3, 0x85, 0xc9, 0x9f, 0x9e, 0x07, 0xf9,
	0x00, 0x5e, 0x7e, 0x22, 0x44, 0xc4, 0xed, 0x28, 0xe4, 0xc2, 0xf6, 0x82, 0xe3, 0x50, 0x17, 0x65,
	0x6d, 0x3e, 0xb7, 0x6e, 0xde, 0xbc, 0xa9, 0xa7, 0x79, 0x09, 0x71, 0x0f, 0x42, 0x2e, 0xf6, 0x33,
	0xcc, 0x74, 0xce, 0x12, 0x8d, 0xdc, 0x87, 0xcb, 0x39, 0x76, 0x8d, 0xd0, 0x55, 0x51, 0x55, 0x34,
	0xd9, 0x08, 0xf2, 0x3a, 0x97, 0xf1, 0xda, 0x09, 0x5d, 0x8c, 0xb0, 0xb6, 0xf5, 0xcc, 0xdb, 0x40,
	0xda, 0xcb, 0x7c, 0x9f, 0x51, 0x91, 0xc4, 0x8c, 0x4b, 0x9b, 0xe6, 0x3e, 0x01, 0xc3, 0x49, 0x4d,
	0x5a, 0x79, 0x90, 0xf9, 0x7d, 0x03, 0x56, 0xbb, 0x09, 0xbf, 0x8a, 0x9e, 0x57, 0xef, 0x73, 0x44,
	0x67, 0x9a, 0x1c, 0xed, 0x4c, 0x93, 0x5b, 0x7f, 0x78, 0x11, 0xa6, 0xe5, 0xce, 0x77, 0xc8, 0xe2,
	0x63, 0xb9, 0x44, 0x09, 0xcc, 0x3e, 0x60, 0x62, 0xfb, 0x60, 0x3f, 0xed, 0xfe, 0x5e, 0xea, 0xdf,
	0x26, 0xbc, 0xe7, 0x47, 0xe2, 0xa4, 0x76, 0xb9, 0x3f, 0x42, 0xda, 0xe8, 0x5b, 0xfb, 0xf5, 0x9f,
	0xfe, 0xfb, 0xef, 0x55, 0x6a, 0xa4, 0x8a, 0x9f, 0xc7, 0xcb, 0x40, 0xa9, 0x1f, 0xdf, 0x92, 0xcf,
	0x1b, 0x69, 0x4f, 0xf4, 0x0b, 0x03, 0xe6, 0x8b, 0xd7, 0x11, 0x9c, 0x94, 0x6b, 0x50, 0xd6, 0x4a,
	0x7c, 0x14, 0x27, 0xd1, 0xcd, 0xdb, 0xa8, 0xc4, 0x4d, 0xb2, 0x59, 0x50, 0x42, 0x9b, 0x97, 0xd7,
	0x9f, 0x3b, 0x61, 0x20, 0xd8, 0x33, 0x69, 0xfa, 0xcf, 0xea, 0x6e, 0x4e, 0x8d, 0xcf, 0xd1, 0x22,
	0xb9, 0xef, 0xc5, 0x5f, 0xea, 0xaf, 0xd7, 0xfe, 0x5e, 0xaa, 0x55, 0x89, 0x2e, 0xbd, 0x79, 0x05,
	0x35, 0xba, 0x44, 0x2e, 0x14, 0x34, 0xca, 0xc9, 0xae, 0x3f, 0xf7, 0xdc, 0xcf, 0xc8, 0xf7, 0x0d,
	0x38, 0x5b, 0xd0, 0x40, 0x9d, 0x68, 0xf8, 0x57, 0xa7, 0xc8, 0xab, 0xa8, 0xc8, 0x55, 0xf3, 0x72,
	0x41, 0x11, 0x2e, 0x62, 0x46, 0x7d, 0x2f, 0x68, 0xe6, 0x54, 0x7a, 0xcb, 0xb8, 0x71, 0xd3, 0x20,
	0x3f, 0x30, 0x60, 0x41, 0x1d, 0xc8, 0x72, 0x66, 0x29, 0x21, 0xa8, 0x94, 0x32, 0x77, 0x50, 0x99,
	0x2d, 0x73, 0xa3, 0xd7, 0x3a, 0xd5, 0x9f, 0xb7, 0x23, 0xa4, 0xb0, 0x4c, 0x6f, 0x19, 0x37, 0xc8,
	0xf7, 0x0c, 0x58, 0x50, 0xb6, 0xf9, 0x05, 0xa8, 0xb5, 0x8e, 0x6a, 0x99, 0x5b, 0x83, 0x17, 0x4b,
	0xaa, 0xf1, 0x39, 0x2c, 0xa8, 0x6f, 0x6e, 0x4e, 0xeb, 0x33, 0xc3, 0x42, 0x2d, 0x75, 0x98, 0x1b,
	0x43, 0x1c, 0xe6, 0x27, 0x06, 0x54, 0x0b, 0x0e, 0x93, 0xbf, 0x98, 0x2a, 0xf1, 0x09, 0x65, 0xf7,
	0x25, 0x59, 0x6d, 0xe3, 0x54, 0x54, 0xe6, 0x5b, 0xa8, 0xe8, 0xeb, 0x64, 0xab, 0x8f, 0xa2, 0x4e,
	0x1b, 0xb7, 0xfe, 0xbc, 0xd0, 0xab, 0xff, 0x8c, 0x7c, 0x0e, 0x33, 0xf9, 0xfb, 0x0b, 0xf2, 0x4a,
	0x3f, 0xd1, 0x3d, 0x6e, 0x39, 0x6a, 0x2f, 0x0d, 0xb9, 0x25, 0xc1, 0x4c, 0x70, 0x01, 0xb5, 0x5b,
	0x21, 0x4b, 0x05, 0xed, 0xd2, 0x4f, 0x68, 0xc8, 0xaf, 0xc2, 0x22, 0x5a, 0xef, 0x88, 0x26, 0x2d,
	0x51, 0x3a, 0x0d, 0x0e, 0xbb, 0x9f, 0xe9, 0x13, 0xed, 0xa9, 0xd4, 0xba, 0xab, 0xe4, 0x91, 0xbf,
	0x56, 0xd1, 0xde, 0x7d, 0x35, 0x51, 0xbe, 0xad, 0x9c, 0x1a, 0xe3, 0x7a, 0x69, 0x0a, 0xf3, 0x1e,
	0x2a, 0xf7, 0x0e, 0x79, 0xbb, 0x4f, 0x72, 0xcc, 0x47, 0x9d, 0xda, 0x73, 0x78, 0xfd, 0x79, 0xb6,
	0x1b, 0x7d, 0x56, 0x6f, 0x29, 0x1d, 0x7f, 0x68, 0xc0, 0xac, 0x34, 0x71, 0x76, 0xe3, 0x4e, 0xd6,
	0x87, 0x5d, 0xd4, 0x67, 0xda, 0xbe, 0x3c, 0x0c, 0x13, 0xd7, 0xee, 0x3d, 0x54, 0x74, 0x87, 0xbc,
	0xfb, 0x82, 0x8a, 0xe2, 0x39, 0x19, 0x35, 0xfb, 0x2b, 0x03, 0xce, 0xf6, 0xba, 0x01, 0x27, 0xaf,
	0x0d, 0x72, 0xb8, 0x3e, 0xf7, 0xe5, 0xb5, 0x57, 0x4a, 0x5e, 0xbf, 0xe3, 0x24, 0xee, 0xe2, 0x24,
	0xde, 0x20, 0xaf, 0x95, 0x98, 0x44, 0x3b, 0x3a, 0x7c, 0xa5, 0xde, 0xef, 0x1b, 0x2a, 0x40, 0xd2,
	0x6b, 0xf0, 0xc1, 0x01, 0xd2, 0x71, 0x59, 0xde, 0x3f, 0x40, 0x72, 0xf7, 0xf3, 0xe6, 0x6b, 0xa8,
	0xdf, 0x06, 0x79, 0xa5, 0x84, 0x7e, 0x4e, 0x94, 0x28, 0x7b, 0xfe, 0xd0, 0x80, 0x95, 0x3e, 0x97,
	0x0c, 0xa4, 0xef, 0xa7, 0x57, 0x83, 0x6f, 0x25, 0x6a, 0x25, 0x3f, 0x78, 0x37, 0x37, 0x51, 0xe1,
	0x75, 0x72, 0xb5, 0x4f, 0xbe, 0xd9, 0x90, 0x2a, 0xd6, 0x9d, 0x54, 0x18, 0xf9, 0x0b, 0x03, 0x56,
	0xb2, 0x46, 0x5b, 0x87, 0xae, 0xa7, 0x6b, 0xb0, 0xd5, 0x5e, 0xe8, 0x93, 0xf4, 0x92, 0x0a, 0x67,
	0x77, 0xe1, 0xe4, 0xc7, 0x06, 0x9c, 0x7f, 0xc0, 0x44, 0xff, 0xf6, 0x4c, 0xa9, 0x0d, 0xe6, 0xd6,
	0xa9, 0x5b, 0x36, 0xe6, 0x36, 0x2a, 0x7a, 0x97, 0xbc, 0x39, 0x70, 0xcb, 0xa9, 0x3b, 0x8a, 0xc1,
	0x86, 0x6a, 0xac, 0x6c, 0x78, 0x79, 0xd5, 0x7e, 0x64, 0xc0, 0xea, 0x03, 0x26, 0xfa, 0x74, 0x59,
	0x4a, 0x29, 0xde, 0xf7, 0xcf, 0x91, 0xde, 0x4c, 0xcd, 0xaf, 0xa3, 0xd6, 0x77, 0xc8, 0xed, 0xc1,
	0x5a, 0xab, 0xe6, 0xca, 0x86, 0x1c, 0x2f, 0xaa, 0xfc, 0xc7, 0x06, 0x54, 0x7b, 0xb8, 0xa6, 0x3a,
	0xc5, 0x6c, 0x96, 0x3c, 0xf9, 0xa5, 0x1e, 0x72, 0xad, 0x24, 0xbe, 0x59, 0x47, 0xad, 0xaf, 0x93,
	0x6b, 0xfd, 0x9c, 0x02, 0x8f, 0x29, 0x39, 0x37, 0xfe, 0x23, 0x03, 0x96, 0x0a, 0x1b, 0x7d, 0x76,
	0x14, 0xb9, 0x35, 0x5c, 0x66, 0xc7, 0xe9, 0xa3, 0x76, 0xa3, 0x3c, 0x89, 0xf9, 0x0a, 0x6a, 0x7a,
	0xc5, 0x5c, 0xeb, 0xa7, 0xe9, 0x91, 0xc6, 0x94, 0xf5, 0xd0, 0x6f, 0x18, 0xb0, 0xa0, 0xfe, 0x7a,
	0xfb, 0xca, 0x0b, 0xa2, 0xb4, 0x70, 0x7d, 0x79, 0xf0, 0x3a, 0xab, 0xbf, 0xf4, 0x64, 0xc6, 0x5f,
	0xee, 0xfd, 0x1b, 0x2e, 0xe9, 0x7b, 0x9a, 0x1f, 0xf8, 0xdb, 0xee, 0x70, 0x05, 0x77, 0x51, 0xc1,
	0xb7, 0xcd, 0xbb, 0xfd, 0x15, 0x2c, 0x96, 0x3f, 0x75, 0xfc, 0xb8, 0x9b, 0xd5, 0x9f, 0x67, 0x7f,
	0xfa, 0x7e, 0x46, 0xfe, 0xd6, 0x00, 0xd2, 0xfd, 0xef, 0x6c, 0xff, 0x35, 0xee, 0xfb, 0x9f, 0x6d,
	0x6d, 0xeb, 0x34, 0x24, 0xea, 0xcf, 0xe1, 0xb4, 0x34, 0x30, 0xdf, 0x2e, 0x3d, 0x05, 0x75, 0x73,
	0xb0, 0x21, 0x18, 0x57, 0xb1, 0x85, 0xda, 0xfe, 0xd8, 0x80, 0xd5, 0xbe, 0xbf, 0xef, 0x92, 0x3b,
	0xfd, 0xbf, 0x1a, 0x1a, 0xfc, 0xc7, 0xef, 0xf0, 0x25, 0xd0, 0x19, 0xcc, 0x7c, 0xb3, 0xfc, 0x12,
	0xa4, 0x32, 0x37, 0x38, 0x8a, 0xda, 0x79, 0xeb, 0xef, 0xbe, 0xbc, 0x68, 0xfc, 0xd3, 0x97, 0x17,
	0x8d, 0x7f, 0xf9, 0xf2, 0xa2, 0xf1, 0xc5, 0xbf, 0x5d, 0xfc, 0xa5, 0x6f, 0xae, 0xe7, 0xfe, 0x15,
	0x4f, 0xe5, 0x6f, 0xf8, 0x34, 0xa0, 0x4d, 0xe6, 0x4a, 0x39, 0x3c, 0x15, 0xd4, 0x18, 0xc7, 0xae,
	0xfb, 0x6b, 0xff, 0x1b, 0x00, 0x00, 0xff, 0xff, 0xb6, 0xb4, 0x41, 0x38, 0x9a, 0x3e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DataServiceClient is the client API for DataService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DataServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error)
	// Fetch all deployments in the project identified by the given context ID.
	// Required permissions:
	// - data.deployment.list on the project identified by the given context ID
	ListDeployments(ctx context.Context, in *v1.ListOptions, opts ...grpc.CallOption) (*DeploymentList, error)
	// Fetch a deployment by its id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Deployment, error)
	// Fetch all updates (spec and/or status) of the deployment that matches the given request.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetDeploymentUpdates(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (DataService_GetDeploymentUpdatesClient, error)
	// Create a new deployment
	// Required permissions:
	// - data.deployment.create on the project that owns the deployment
	// - network.privateendpointservice.create on the project that owns the deployment (if private_endpoint field is set)
	// Note that deployment.status & deployment.expiration are ignored
	// in this request.
	CreateDeployment(ctx context.Context, in *Deployment, opts ...grpc.CallOption) (*Deployment, error)
	// Update a deployment
	// Required permissions:
	// - data.deployment.update on the deployment
	// Note that deployment.status & deployment.expiration are ignored
	// in this request.
	UpdateDeployment(ctx context.Context, in *Deployment, opts ...grpc.CallOption) (*Deployment, error)
	// Delete a deployment
	// Note that deployments are initially only marked for deletion.
	// Once all their resources are removed the deployment itself is removed.
	// Required permissions:
	// - data.deployment.delete on the deployment
	DeleteDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Fetch credentials for accessing deployment by its id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	// - data.deploymentcredentials.get on the deployment identified by the given ID
	GetDeploymentCredentials(ctx context.Context, in *DeploymentCredentialsRequest, opts ...grpc.CallOption) (*DeploymentCredentials, error)
	// Fetch all ArangoDB versions that are available for deployments.
	// Required permissions:
	// - None
	ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (*VersionList, error)
	// Fetch the default ArangoDB version for new deployment.
	// Required permissions:
	// - None
	GetDefaultVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*Version, error)
	// Fetch the limits for server specifications for deployments
	// owned by the given projected, created in the given region.
	// Required permissions:
	// - data.limits.get on the requested project
	// - data.deployment.get on the specified deployment (if deployment_id is set)
	// This method is deprecated and will be remove in the very near future, do not use this method anymore
	GetServersSpecLimits(ctx context.Context, in *ServersSpecLimitsRequest, opts ...grpc.CallOption) (*ServersSpecLimits, error)
	// Fetch the node sizes available for deployments
	// owned by the project with given ID, created in the given region with given ID.
	// If project ID "all" is used, then all node sizes for the region with given
	// ID are returned.
	// Required permissions:
	// - data.nodesize.list on the requested project (if project ID does not equal "all")
	// - None if project ID does equals "all"
	ListNodeSizes(ctx context.Context, in *NodeSizesRequest, opts ...grpc.CallOption) (*NodeSizeList, error)
	// Fetch the models available for deployments owned by the project with given ID.
	// Required permissions:
	// - data.deploymentmodel.list on the requested project
	ListDeploymentModels(ctx context.Context, in *ListDeploymentModelsRequest, opts ...grpc.CallOption) (*DeploymentModelList, error)
	// Fetch the CPU sizes available for deployments owned by the project with given ID.
	// Required permissions:
	// - data.cpusize.list on the requested project
	ListCPUSizes(ctx context.Context, in *ListCPUSizesRequest, opts ...grpc.CallOption) (*CPUSizeList, error)
	// Calculate the total size of a deployment with given arguments.
	// Required permissions:
	// - none
	CalculateDeploymentSize(ctx context.Context, in *CalculateDeploymentSizeRequest, opts ...grpc.CallOption) (*DeploymentSize, error)
	// Recommend a deployment size, for a oneshard or sharded deployments, using the
	// given input values.
	// Required permissions:
	// - none
	RecommendDeploymentSize(ctx context.Context, in *DeploymentSizeRequest, opts ...grpc.CallOption) (*DeploymentSizeRecommendation, error)
	// Fetch instructions for connecting drivers to the deployment identified by the given id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetConnectDriverInstructions(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*ConnectDriverInstructions, error)
	// Fetch instructions for importing data into the deployment identified by the given id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetImportDataInstructions(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*ImportDataInstructions, error)
	// Calculate the price of a deployment of given settings.
	// Required permissions:
	// - data.deploymentprice.calculate
	CalculateDeploymentPrice(ctx context.Context, in *DeploymentPriceRequest, opts ...grpc.CallOption) (*DeploymentPrice, error)
	// Get the features that will be available to a deployment in the given context.
	// Required permissions:
	// - data.deploymentfeatures.get on the project that is given in the request.
	GetDeploymentFeatures(ctx context.Context, in *DeploymentFeaturesRequest, opts ...grpc.CallOption) (*DeploymentFeatures, error)
	// Resumes a paused deployment identified by the given id.
	// When ResumeDeployment is invoked on a deployment that has is_paused not set, an PreconditionFailed error is returned.
	// Required permissions:
	// - data.deployment.resume on the deployment
	ResumeDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error)
	// Rotate a server for a deployment.
	// This causes the server to restart after condition are deemed safe for a restart.
	// Required permissions:
	// - data.deployment.rotate-server on the deployment
	RotateDeploymentServer(ctx context.Context, in *RotateDeploymentServerRequest, opts ...grpc.CallOption) (*v1.Empty, error)
	// Create a test database and user for a deployment. Returns the output containing the created
	// database name, password, username, host and port.
	// Required permissions:
	// - data.deployment.create-test-database on the deployment
	CreateTestDatabase(ctx context.Context, in *CreateTestDatabaseRequest, opts ...grpc.CallOption) (*CreateTestDatabaseResponse, error)
	// RebalanceDeploymentShards rebalances shards for deployment across the DB servers.
	// Prerelease: This function is not yet available in production.
	// Required permissions:
	// - data.deployment.rebalance-shards on the deployment
	RebalanceDeploymentShards(ctx context.Context, in *RebalanceDeploymentShardsRequest, opts ...grpc.CallOption) (*v1.Empty, error)
}

type dataServiceClient struct {
	cc *grpc.ClientConn
}

func NewDataServiceClient(cc *grpc.ClientConn) DataServiceClient {
	return &dataServiceClient{cc}
}

func (c *dataServiceClient) GetAPIVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*v1.Version, error) {
	out := new(v1.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ListDeployments(ctx context.Context, in *v1.ListOptions, opts ...grpc.CallOption) (*DeploymentList, error) {
	out := new(DeploymentList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ListDeployments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*Deployment, error) {
	out := new(Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDeploymentUpdates(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (DataService_GetDeploymentUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataService_serviceDesc.Streams[0], "/arangodb.cloud.data.v1.DataService/GetDeploymentUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataServiceGetDeploymentUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DataService_GetDeploymentUpdatesClient interface {
	Recv() (*Deployment, error)
	grpc.ClientStream
}

type dataServiceGetDeploymentUpdatesClient struct {
	grpc.ClientStream
}

func (x *dataServiceGetDeploymentUpdatesClient) Recv() (*Deployment, error) {
	m := new(Deployment)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataServiceClient) CreateDeployment(ctx context.Context, in *Deployment, opts ...grpc.CallOption) (*Deployment, error) {
	out := new(Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/CreateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) UpdateDeployment(ctx context.Context, in *Deployment, opts ...grpc.CallOption) (*Deployment, error) {
	out := new(Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/UpdateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) DeleteDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/DeleteDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDeploymentCredentials(ctx context.Context, in *DeploymentCredentialsRequest, opts ...grpc.CallOption) (*DeploymentCredentials, error) {
	out := new(DeploymentCredentials)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetDeploymentCredentials", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (*VersionList, error) {
	out := new(VersionList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ListVersions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDefaultVersion(ctx context.Context, in *v1.Empty, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetDefaultVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetServersSpecLimits(ctx context.Context, in *ServersSpecLimitsRequest, opts ...grpc.CallOption) (*ServersSpecLimits, error) {
	out := new(ServersSpecLimits)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetServersSpecLimits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ListNodeSizes(ctx context.Context, in *NodeSizesRequest, opts ...grpc.CallOption) (*NodeSizeList, error) {
	out := new(NodeSizeList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ListNodeSizes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ListDeploymentModels(ctx context.Context, in *ListDeploymentModelsRequest, opts ...grpc.CallOption) (*DeploymentModelList, error) {
	out := new(DeploymentModelList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ListDeploymentModels", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ListCPUSizes(ctx context.Context, in *ListCPUSizesRequest, opts ...grpc.CallOption) (*CPUSizeList, error) {
	out := new(CPUSizeList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ListCPUSizes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) CalculateDeploymentSize(ctx context.Context, in *CalculateDeploymentSizeRequest, opts ...grpc.CallOption) (*DeploymentSize, error) {
	out := new(DeploymentSize)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/CalculateDeploymentSize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) RecommendDeploymentSize(ctx context.Context, in *DeploymentSizeRequest, opts ...grpc.CallOption) (*DeploymentSizeRecommendation, error) {
	out := new(DeploymentSizeRecommendation)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/RecommendDeploymentSize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetConnectDriverInstructions(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*ConnectDriverInstructions, error) {
	out := new(ConnectDriverInstructions)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetConnectDriverInstructions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetImportDataInstructions(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*ImportDataInstructions, error) {
	out := new(ImportDataInstructions)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetImportDataInstructions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) CalculateDeploymentPrice(ctx context.Context, in *DeploymentPriceRequest, opts ...grpc.CallOption) (*DeploymentPrice, error) {
	out := new(DeploymentPrice)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/CalculateDeploymentPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) GetDeploymentFeatures(ctx context.Context, in *DeploymentFeaturesRequest, opts ...grpc.CallOption) (*DeploymentFeatures, error) {
	out := new(DeploymentFeatures)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/GetDeploymentFeatures", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) ResumeDeployment(ctx context.Context, in *v1.IDOptions, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/ResumeDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) RotateDeploymentServer(ctx context.Context, in *RotateDeploymentServerRequest, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/RotateDeploymentServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) CreateTestDatabase(ctx context.Context, in *CreateTestDatabaseRequest, opts ...grpc.CallOption) (*CreateTestDatabaseResponse, error) {
	out := new(CreateTestDatabaseResponse)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/CreateTestDatabase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dataServiceClient) RebalanceDeploymentShards(ctx context.Context, in *RebalanceDeploymentShardsRequest, opts ...grpc.CallOption) (*v1.Empty, error) {
	out := new(v1.Empty)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.data.v1.DataService/RebalanceDeploymentShards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DataServiceServer is the server API for DataService service.
type DataServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v1.Empty) (*v1.Version, error)
	// Fetch all deployments in the project identified by the given context ID.
	// Required permissions:
	// - data.deployment.list on the project identified by the given context ID
	ListDeployments(context.Context, *v1.ListOptions) (*DeploymentList, error)
	// Fetch a deployment by its id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetDeployment(context.Context, *v1.IDOptions) (*Deployment, error)
	// Fetch all updates (spec and/or status) of the deployment that matches the given request.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetDeploymentUpdates(*v1.IDOptions, DataService_GetDeploymentUpdatesServer) error
	// Create a new deployment
	// Required permissions:
	// - data.deployment.create on the project that owns the deployment
	// - network.privateendpointservice.create on the project that owns the deployment (if private_endpoint field is set)
	// Note that deployment.status & deployment.expiration are ignored
	// in this request.
	CreateDeployment(context.Context, *Deployment) (*Deployment, error)
	// Update a deployment
	// Required permissions:
	// - data.deployment.update on the deployment
	// Note that deployment.status & deployment.expiration are ignored
	// in this request.
	UpdateDeployment(context.Context, *Deployment) (*Deployment, error)
	// Delete a deployment
	// Note that deployments are initially only marked for deletion.
	// Once all their resources are removed the deployment itself is removed.
	// Required permissions:
	// - data.deployment.delete on the deployment
	DeleteDeployment(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Fetch credentials for accessing deployment by its id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	// - data.deploymentcredentials.get on the deployment identified by the given ID
	GetDeploymentCredentials(context.Context, *DeploymentCredentialsRequest) (*DeploymentCredentials, error)
	// Fetch all ArangoDB versions that are available for deployments.
	// Required permissions:
	// - None
	ListVersions(context.Context, *ListVersionsRequest) (*VersionList, error)
	// Fetch the default ArangoDB version for new deployment.
	// Required permissions:
	// - None
	GetDefaultVersion(context.Context, *v1.Empty) (*Version, error)
	// Fetch the limits for server specifications for deployments
	// owned by the given projected, created in the given region.
	// Required permissions:
	// - data.limits.get on the requested project
	// - data.deployment.get on the specified deployment (if deployment_id is set)
	// This method is deprecated and will be remove in the very near future, do not use this method anymore
	GetServersSpecLimits(context.Context, *ServersSpecLimitsRequest) (*ServersSpecLimits, error)
	// Fetch the node sizes available for deployments
	// owned by the project with given ID, created in the given region with given ID.
	// If project ID "all" is used, then all node sizes for the region with given
	// ID are returned.
	// Required permissions:
	// - data.nodesize.list on the requested project (if project ID does not equal "all")
	// - None if project ID does equals "all"
	ListNodeSizes(context.Context, *NodeSizesRequest) (*NodeSizeList, error)
	// Fetch the models available for deployments owned by the project with given ID.
	// Required permissions:
	// - data.deploymentmodel.list on the requested project
	ListDeploymentModels(context.Context, *ListDeploymentModelsRequest) (*DeploymentModelList, error)
	// Fetch the CPU sizes available for deployments owned by the project with given ID.
	// Required permissions:
	// - data.cpusize.list on the requested project
	ListCPUSizes(context.Context, *ListCPUSizesRequest) (*CPUSizeList, error)
	// Calculate the total size of a deployment with given arguments.
	// Required permissions:
	// - none
	CalculateDeploymentSize(context.Context, *CalculateDeploymentSizeRequest) (*DeploymentSize, error)
	// Recommend a deployment size, for a oneshard or sharded deployments, using the
	// given input values.
	// Required permissions:
	// - none
	RecommendDeploymentSize(context.Context, *DeploymentSizeRequest) (*DeploymentSizeRecommendation, error)
	// Fetch instructions for connecting drivers to the deployment identified by the given id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetConnectDriverInstructions(context.Context, *v1.IDOptions) (*ConnectDriverInstructions, error)
	// Fetch instructions for importing data into the deployment identified by the given id.
	// Required permissions:
	// - data.deployment.get on the deployment identified by the given ID
	GetImportDataInstructions(context.Context, *v1.IDOptions) (*ImportDataInstructions, error)
	// Calculate the price of a deployment of given settings.
	// Required permissions:
	// - data.deploymentprice.calculate
	CalculateDeploymentPrice(context.Context, *DeploymentPriceRequest) (*DeploymentPrice, error)
	// Get the features that will be available to a deployment in the given context.
	// Required permissions:
	// - data.deploymentfeatures.get on the project that is given in the request.
	GetDeploymentFeatures(context.Context, *DeploymentFeaturesRequest) (*DeploymentFeatures, error)
	// Resumes a paused deployment identified by the given id.
	// When ResumeDeployment is invoked on a deployment that has is_paused not set, an PreconditionFailed error is returned.
	// Required permissions:
	// - data.deployment.resume on the deployment
	ResumeDeployment(context.Context, *v1.IDOptions) (*v1.Empty, error)
	// Rotate a server for a deployment.
	// This causes the server to restart after condition are deemed safe for a restart.
	// Required permissions:
	// - data.deployment.rotate-server on the deployment
	RotateDeploymentServer(context.Context, *RotateDeploymentServerRequest) (*v1.Empty, error)
	// Create a test database and user for a deployment. Returns the output containing the created
	// database name, password, username, host and port.
	// Required permissions:
	// - data.deployment.create-test-database on the deployment
	CreateTestDatabase(context.Context, *CreateTestDatabaseRequest) (*CreateTestDatabaseResponse, error)
	// RebalanceDeploymentShards rebalances shards for deployment across the DB servers.
	// Prerelease: This function is not yet available in production.
	// Required permissions:
	// - data.deployment.rebalance-shards on the deployment
	RebalanceDeploymentShards(context.Context, *RebalanceDeploymentShardsRequest) (*v1.Empty, error)
}

// UnimplementedDataServiceServer can be embedded to have forward compatible implementations.
type UnimplementedDataServiceServer struct {
}

func (*UnimplementedDataServiceServer) GetAPIVersion(ctx context.Context, req *v1.Empty) (*v1.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedDataServiceServer) ListDeployments(ctx context.Context, req *v1.ListOptions) (*DeploymentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeployments not implemented")
}
func (*UnimplementedDataServiceServer) GetDeployment(ctx context.Context, req *v1.IDOptions) (*Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeployment not implemented")
}
func (*UnimplementedDataServiceServer) GetDeploymentUpdates(req *v1.IDOptions, srv DataService_GetDeploymentUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method GetDeploymentUpdates not implemented")
}
func (*UnimplementedDataServiceServer) CreateDeployment(ctx context.Context, req *Deployment) (*Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDeployment not implemented")
}
func (*UnimplementedDataServiceServer) UpdateDeployment(ctx context.Context, req *Deployment) (*Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDeployment not implemented")
}
func (*UnimplementedDataServiceServer) DeleteDeployment(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDeployment not implemented")
}
func (*UnimplementedDataServiceServer) GetDeploymentCredentials(ctx context.Context, req *DeploymentCredentialsRequest) (*DeploymentCredentials, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentCredentials not implemented")
}
func (*UnimplementedDataServiceServer) ListVersions(ctx context.Context, req *ListVersionsRequest) (*VersionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVersions not implemented")
}
func (*UnimplementedDataServiceServer) GetDefaultVersion(ctx context.Context, req *v1.Empty) (*Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultVersion not implemented")
}
func (*UnimplementedDataServiceServer) GetServersSpecLimits(ctx context.Context, req *ServersSpecLimitsRequest) (*ServersSpecLimits, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServersSpecLimits not implemented")
}
func (*UnimplementedDataServiceServer) ListNodeSizes(ctx context.Context, req *NodeSizesRequest) (*NodeSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodeSizes not implemented")
}
func (*UnimplementedDataServiceServer) ListDeploymentModels(ctx context.Context, req *ListDeploymentModelsRequest) (*DeploymentModelList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeploymentModels not implemented")
}
func (*UnimplementedDataServiceServer) ListCPUSizes(ctx context.Context, req *ListCPUSizesRequest) (*CPUSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCPUSizes not implemented")
}
func (*UnimplementedDataServiceServer) CalculateDeploymentSize(ctx context.Context, req *CalculateDeploymentSizeRequest) (*DeploymentSize, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalculateDeploymentSize not implemented")
}
func (*UnimplementedDataServiceServer) RecommendDeploymentSize(ctx context.Context, req *DeploymentSizeRequest) (*DeploymentSizeRecommendation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecommendDeploymentSize not implemented")
}
func (*UnimplementedDataServiceServer) GetConnectDriverInstructions(ctx context.Context, req *v1.IDOptions) (*ConnectDriverInstructions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectDriverInstructions not implemented")
}
func (*UnimplementedDataServiceServer) GetImportDataInstructions(ctx context.Context, req *v1.IDOptions) (*ImportDataInstructions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetImportDataInstructions not implemented")
}
func (*UnimplementedDataServiceServer) CalculateDeploymentPrice(ctx context.Context, req *DeploymentPriceRequest) (*DeploymentPrice, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalculateDeploymentPrice not implemented")
}
func (*UnimplementedDataServiceServer) GetDeploymentFeatures(ctx context.Context, req *DeploymentFeaturesRequest) (*DeploymentFeatures, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeploymentFeatures not implemented")
}
func (*UnimplementedDataServiceServer) ResumeDeployment(ctx context.Context, req *v1.IDOptions) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeDeployment not implemented")
}
func (*UnimplementedDataServiceServer) RotateDeploymentServer(ctx context.Context, req *RotateDeploymentServerRequest) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateDeploymentServer not implemented")
}
func (*UnimplementedDataServiceServer) CreateTestDatabase(ctx context.Context, req *CreateTestDatabaseRequest) (*CreateTestDatabaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTestDatabase not implemented")
}
func (*UnimplementedDataServiceServer) RebalanceDeploymentShards(ctx context.Context, req *RebalanceDeploymentShardsRequest) (*v1.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebalanceDeploymentShards not implemented")
}

func RegisterDataServiceServer(s *grpc.Server, srv DataServiceServer) {
	s.RegisterService(&_DataService_serviceDesc, srv)
}

func _DataService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetAPIVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ListDeployments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ListOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ListDeployments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ListDeployments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ListDeployments(ctx, req.(*v1.ListOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDeployment(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDeploymentUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(v1.IDOptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DataServiceServer).GetDeploymentUpdates(m, &dataServiceGetDeploymentUpdatesServer{stream})
}

type DataService_GetDeploymentUpdatesServer interface {
	Send(*Deployment) error
	grpc.ServerStream
}

type dataServiceGetDeploymentUpdatesServer struct {
	grpc.ServerStream
}

func (x *dataServiceGetDeploymentUpdatesServer) Send(m *Deployment) error {
	return x.ServerStream.SendMsg(m)
}

func _DataService_CreateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Deployment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).CreateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/CreateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).CreateDeployment(ctx, req.(*Deployment))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_UpdateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Deployment)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).UpdateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/UpdateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).UpdateDeployment(ctx, req.(*Deployment))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_DeleteDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).DeleteDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/DeleteDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).DeleteDeployment(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDeploymentCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeploymentCredentialsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDeploymentCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetDeploymentCredentials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDeploymentCredentials(ctx, req.(*DeploymentCredentialsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ListVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ListVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ListVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ListVersions(ctx, req.(*ListVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDefaultVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDefaultVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetDefaultVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDefaultVersion(ctx, req.(*v1.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetServersSpecLimits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServersSpecLimitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetServersSpecLimits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetServersSpecLimits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetServersSpecLimits(ctx, req.(*ServersSpecLimitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ListNodeSizes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeSizesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ListNodeSizes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ListNodeSizes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ListNodeSizes(ctx, req.(*NodeSizesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ListDeploymentModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDeploymentModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ListDeploymentModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ListDeploymentModels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ListDeploymentModels(ctx, req.(*ListDeploymentModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ListCPUSizes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCPUSizesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ListCPUSizes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ListCPUSizes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ListCPUSizes(ctx, req.(*ListCPUSizesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_CalculateDeploymentSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalculateDeploymentSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).CalculateDeploymentSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/CalculateDeploymentSize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).CalculateDeploymentSize(ctx, req.(*CalculateDeploymentSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_RecommendDeploymentSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeploymentSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).RecommendDeploymentSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/RecommendDeploymentSize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).RecommendDeploymentSize(ctx, req.(*DeploymentSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetConnectDriverInstructions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetConnectDriverInstructions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetConnectDriverInstructions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetConnectDriverInstructions(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetImportDataInstructions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetImportDataInstructions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetImportDataInstructions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetImportDataInstructions(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_CalculateDeploymentPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeploymentPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).CalculateDeploymentPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/CalculateDeploymentPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).CalculateDeploymentPrice(ctx, req.(*DeploymentPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_GetDeploymentFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeploymentFeaturesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).GetDeploymentFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/GetDeploymentFeatures",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).GetDeploymentFeatures(ctx, req.(*DeploymentFeaturesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_ResumeDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).ResumeDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/ResumeDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).ResumeDeployment(ctx, req.(*v1.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_RotateDeploymentServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RotateDeploymentServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).RotateDeploymentServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/RotateDeploymentServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).RotateDeploymentServer(ctx, req.(*RotateDeploymentServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_CreateTestDatabase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTestDatabaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).CreateTestDatabase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/CreateTestDatabase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).CreateTestDatabase(ctx, req.(*CreateTestDatabaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DataService_RebalanceDeploymentShards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebalanceDeploymentShardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DataServiceServer).RebalanceDeploymentShards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.data.v1.DataService/RebalanceDeploymentShards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DataServiceServer).RebalanceDeploymentShards(ctx, req.(*RebalanceDeploymentShardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _DataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.data.v1.DataService",
	HandlerType: (*DataServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _DataService_GetAPIVersion_Handler,
		},
		{
			MethodName: "ListDeployments",
			Handler:    _DataService_ListDeployments_Handler,
		},
		{
			MethodName: "GetDeployment",
			Handler:    _DataService_GetDeployment_Handler,
		},
		{
			MethodName: "CreateDeployment",
			Handler:    _DataService_CreateDeployment_Handler,
		},
		{
			MethodName: "UpdateDeployment",
			Handler:    _DataService_UpdateDeployment_Handler,
		},
		{
			MethodName: "DeleteDeployment",
			Handler:    _DataService_DeleteDeployment_Handler,
		},
		{
			MethodName: "GetDeploymentCredentials",
			Handler:    _DataService_GetDeploymentCredentials_Handler,
		},
		{
			MethodName: "ListVersions",
			Handler:    _DataService_ListVersions_Handler,
		},
		{
			MethodName: "GetDefaultVersion",
			Handler:    _DataService_GetDefaultVersion_Handler,
		},
		{
			MethodName: "GetServersSpecLimits",
			Handler:    _DataService_GetServersSpecLimits_Handler,
		},
		{
			MethodName: "ListNodeSizes",
			Handler:    _DataService_ListNodeSizes_Handler,
		},
		{
			MethodName: "ListDeploymentModels",
			Handler:    _DataService_ListDeploymentModels_Handler,
		},
		{
			MethodName: "ListCPUSizes",
			Handler:    _DataService_ListCPUSizes_Handler,
		},
		{
			MethodName: "CalculateDeploymentSize",
			Handler:    _DataService_CalculateDeploymentSize_Handler,
		},
		{
			MethodName: "RecommendDeploymentSize",
			Handler:    _DataService_RecommendDeploymentSize_Handler,
		},
		{
			MethodName: "GetConnectDriverInstructions",
			Handler:    _DataService_GetConnectDriverInstructions_Handler,
		},
		{
			MethodName: "GetImportDataInstructions",
			Handler:    _DataService_GetImportDataInstructions_Handler,
		},
		{
			MethodName: "CalculateDeploymentPrice",
			Handler:    _DataService_CalculateDeploymentPrice_Handler,
		},
		{
			MethodName: "GetDeploymentFeatures",
			Handler:    _DataService_GetDeploymentFeatures_Handler,
		},
		{
			MethodName: "ResumeDeployment",
			Handler:    _DataService_ResumeDeployment_Handler,
		},
		{
			MethodName: "RotateDeploymentServer",
			Handler:    _DataService_RotateDeploymentServer_Handler,
		},
		{
			MethodName: "CreateTestDatabase",
			Handler:    _DataService_CreateTestDatabase_Handler,
		},
		{
			MethodName: "RebalanceDeploymentShards",
			Handler:    _DataService_RebalanceDeploymentShards_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetDeploymentUpdates",
			Handler:       _DataService_GetDeploymentUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "data.proto",
}

func (m *RotateDeploymentServerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RotateDeploymentServerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RotateDeploymentServerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ServerId) > 0 {
		i -= len(m.ServerId)
		copy(dAtA[i:], m.ServerId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ServerId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintData(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateTestDatabaseResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTestDatabaseResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTestDatabaseResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Port) > 0 {
		i -= len(m.Port)
		copy(dAtA[i:], m.Port)
		i = encodeVarintData(dAtA, i, uint64(len(m.Port)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintData(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintData(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintData(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintData(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateTestDatabaseRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateTestDatabaseRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateTestDatabaseRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintData(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RebalanceDeploymentShardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RebalanceDeploymentShardsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RebalanceDeploymentShardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintData(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NotificationEmailAddresses) > 0 {
		for iNdEx := len(m.NotificationEmailAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NotificationEmailAddresses[iNdEx])
			copy(dAtA[i:], m.NotificationEmailAddresses[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.NotificationEmailAddresses[iNdEx])))
			i--
			dAtA[i] = 0x26
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.CloneBackupId) > 0 {
		i -= len(m.CloneBackupId)
		copy(dAtA[i:], m.CloneBackupId)
		i = encodeVarintData(dAtA, i, uint64(len(m.CloneBackupId)))
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xca
	}
	if m.IsClone {
		i--
		if m.IsClone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x25
		i--
		dAtA[i] = 0xc0
	}
	if len(m.DeploymentRecommendations) > 0 {
		for iNdEx := len(m.DeploymentRecommendations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DeploymentRecommendations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1f
			i--
			dAtA[i] = 0xaa
		}
	}
	if m.BackupRestore != nil {
		{
			size, err := m.BackupRestore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x19
		i--
		dAtA[i] = 0x8a
	}
	if m.Expiration != nil {
		{
			size, err := m.Expiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
		i--
		dAtA[i] = 0xea
	}
	if m.Size_ != nil {
		{
			size, err := m.Size_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xd2
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xca
	}
	if len(m.IpallowlistId) > 0 {
		i -= len(m.IpallowlistId)
		copy(dAtA[i:], m.IpallowlistId)
		i = encodeVarintData(dAtA, i, uint64(len(m.IpallowlistId)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xea
	}
	if len(m.IamproviderId) > 0 {
		i -= len(m.IamproviderId)
		copy(dAtA[i:], m.IamproviderId)
		i = encodeVarintData(dAtA, i, uint64(len(m.IamproviderId)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xe2
	}
	if len(m.CustomImage) > 0 {
		i -= len(m.CustomImage)
		copy(dAtA[i:], m.CustomImage)
		i = encodeVarintData(dAtA, i, uint64(len(m.CustomImage)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xda
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xd2
	}
	if m.UpgradeRecommendation != nil {
		{
			size, err := m.UpgradeRecommendation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xca
	}
	if m.ReplaceVersionBy != nil {
		{
			size, err := m.ReplaceVersionBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc2
	}
	if m.Servers != nil {
		{
			size, err := m.Servers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xba
	}
	if m.Certificates != nil {
		{
			size, err := m.Certificates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintData(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xaa
	}
	if m.PrivateEndpoint {
		i--
		if m.PrivateEndpoint {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.IsPrepaidDeploymentUpdateAvailable {
		i--
		if m.IsPrepaidDeploymentUpdateAvailable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.PrepaidDeploymentEndsAt != nil {
		{
			size, err := m.PrepaidDeploymentEndsAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.PrepaidDeploymentStartsAt != nil {
		{
			size, err := m.PrepaidDeploymentStartsAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.DisableFoxxAuthentication {
		i--
		if m.DisableFoxxAuthentication {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if len(m.PrepaidDeploymentId) > 0 {
		i -= len(m.PrepaidDeploymentId)
		copy(dAtA[i:], m.PrepaidDeploymentId)
		i = encodeVarintData(dAtA, i, uint64(len(m.PrepaidDeploymentId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.LastResumedAt != nil {
		{
			size, err := m.LastResumedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.LastPausedAt != nil {
		{
			size, err := m.LastPausedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.IsPaused {
		i--
		if m.IsPaused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.Locked {
		i--
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.AcceptedTermsAndConditionsId) > 0 {
		i -= len(m.AcceptedTermsAndConditionsId)
		copy(dAtA[i:], m.AcceptedTermsAndConditionsId)
		i = encodeVarintData(dAtA, i, uint64(len(m.AcceptedTermsAndConditionsId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.CreatedById) > 0 {
		i -= len(m.CreatedById)
		copy(dAtA[i:], m.CreatedById)
		i = encodeVarintData(dAtA, i, uint64(len(m.CreatedById)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SupportPlanId) > 0 {
		i -= len(m.SupportPlanId)
		copy(dAtA[i:], m.SupportPlanId)
		i = encodeVarintData(dAtA, i, uint64(len(m.SupportPlanId)))
		i--
		dAtA[i] = 0x52
	}
	if m.IsDeleted {
		i--
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DeletedAt != nil {
		{
			size, err := m.DeletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintData(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintData(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintData(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_CertificateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_CertificateSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_CertificateSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AlternateDnsNames) > 0 {
		for iNdEx := len(m.AlternateDnsNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlternateDnsNames[iNdEx])
			copy(dAtA[i:], m.AlternateDnsNames[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.AlternateDnsNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CaCertificateId) > 0 {
		i -= len(m.CaCertificateId)
		copy(dAtA[i:], m.CaCertificateId)
		i = encodeVarintData(dAtA, i, uint64(len(m.CaCertificateId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_ServersSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_ServersSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_ServersSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MinimumDbserversCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MinimumDbserversCount))
		i--
		dAtA[i] = 0x78
	}
	if len(m.DbserverArgs) > 0 {
		for iNdEx := len(m.DbserverArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DbserverArgs[iNdEx])
			copy(dAtA[i:], m.DbserverArgs[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.DbserverArgs[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if m.DbserverDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DbserverDiskSize))
		i--
		dAtA[i] = 0x68
	}
	if m.DbserverMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DbserverMemorySize))
		i--
		dAtA[i] = 0x60
	}
	if m.Dbservers != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Dbservers))
		i--
		dAtA[i] = 0x58
	}
	if len(m.CoordinatorArgs) > 0 {
		for iNdEx := len(m.CoordinatorArgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CoordinatorArgs[iNdEx])
			copy(dAtA[i:], m.CoordinatorArgs[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.CoordinatorArgs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.CoordinatorMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CoordinatorMemorySize))
		i--
		dAtA[i] = 0x10
	}
	if m.Coordinators != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Coordinators))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_ModelSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_ModelSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_ModelSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeDiskSize))
		i--
		dAtA[i] = 0x20
	}
	if m.NodeCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.NodeSizeId) > 0 {
		i -= len(m.NodeSizeId)
		copy(dAtA[i:], m.NodeSizeId)
		i = encodeVarintData(dAtA, i, uint64(len(m.NodeSizeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintData(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_ServerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_ServerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_ServerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastCpuLimit != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LastCpuLimit))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x95
	}
	if m.LastMemoryLimit != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.LastMemoryLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.LastCpuUsage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.LastCpuUsage))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x85
	}
	if m.LastMemoryUsage != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.LastMemoryUsage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.RecentRestarts != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.RecentRestarts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.DataVolumeInfo != nil {
		{
			size, err := m.DataVolumeInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.IsLeader {
		i--
		if m.IsLeader {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.CanBeDeleted {
		i--
		if m.CanBeDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if m.Bad {
		i--
		if m.Bad {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.RotationPending {
		i--
		if m.RotationPending {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.LastStartedAt != nil {
		{
			size, err := m.LastStartedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintData(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Upgrading {
		i--
		if m.Upgrading {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Ok {
		i--
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Creating {
		i--
		if m.Creating {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Failed {
		i--
		if m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.MemberOfCluster {
		i--
		if m.MemberOfCluster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Ready {
		i--
		if m.Ready {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintData(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintData(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintData(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BackupUploadInProgress {
		i--
		if m.BackupUploadInProgress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb0
	}
	if m.TotalBackupSizeBytes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.TotalBackupSizeBytes))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa8
	}
	if m.BackupRestoreStatus != nil {
		{
			size, err := m.BackupRestoreStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xa2
	}
	if len(m.EndpointSelfSigned) > 0 {
		i -= len(m.EndpointSelfSigned)
		copy(dAtA[i:], m.EndpointSelfSigned)
		i = encodeVarintData(dAtA, i, uint64(len(m.EndpointSelfSigned)))
		i--
		dAtA[i] = 0x52
	}
	if m.Bootstrapped {
		i--
		if m.Bootstrapped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.BootstrappedAt != nil {
		{
			size, err := m.BootstrappedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Servers) > 0 {
		for iNdEx := len(m.Servers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Servers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ServerVersions) > 0 {
		for iNdEx := len(m.ServerVersions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ServerVersions[iNdEx])
			copy(dAtA[i:], m.ServerVersions[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.ServerVersions[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Upgrading {
		i--
		if m.Upgrading {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Ready {
		i--
		if m.Ready {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Created {
		i--
		if m.Created {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintData(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintData(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_BackupRestoreStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_BackupRestoreStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_BackupRestoreStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FailureReason) > 0 {
		i -= len(m.FailureReason)
		copy(dAtA[i:], m.FailureReason)
		i = encodeVarintData(dAtA, i, uint64(len(m.FailureReason)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintData(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Restoring {
		i--
		if m.Restoring {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Revision != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_Expiration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_Expiration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_Expiration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastWarningEmailSendTo) > 0 {
		for iNdEx := len(m.LastWarningEmailSendTo) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LastWarningEmailSendTo[iNdEx])
			copy(dAtA[i:], m.LastWarningEmailSendTo[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.LastWarningEmailSendTo[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.LastWarningEmailSendAt != nil {
		{
			size, err := m.LastWarningEmailSendAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintData(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.ExpiresAt != nil {
		{
			size, err := m.ExpiresAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Deployment_BackupRestoreSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deployment_BackupRestoreSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deployment_BackupRestoreSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BackupId) > 0 {
		i -= len(m.BackupId)
		copy(dAtA[i:], m.BackupId)
		i = encodeVarintData(dAtA, i, uint64(len(m.BackupId)))
		i--
		dAtA[i] = 0x52
	}
	if m.LastUpdatedAt != nil {
		{
			size, err := m.LastUpdatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Revision != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Revision))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DiskSizes) > 0 {
		dAtA25 := make([]byte, len(m.DiskSizes)*10)
		var j24 int
		for _, num1 := range m.DiskSizes {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintData(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CpuSize) > 0 {
		i -= len(m.CpuSize)
		copy(dAtA[i:], m.CpuSize)
		i = encodeVarintData(dAtA, i, uint64(len(m.CpuSize)))
		i--
		dAtA[i] = 0x32
	}
	if m.MaxDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MaxDiskSize))
		i--
		dAtA[i] = 0x28
	}
	if m.MinDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MinDiskSize))
		i--
		dAtA[i] = 0x20
	}
	if m.MemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.MemorySize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintData(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *NodeSizesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeSizesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeSizesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintData(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintData(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintData(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentModelList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentModelList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentModelList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListDeploymentModelsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDeploymentModelsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDeploymentModelsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CPUSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPUSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintData(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CPUSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CPUSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CPUSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListCPUSizesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCPUSizesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCPUSizesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentCredentialsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentCredentialsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentCredentialsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintData(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintData(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentCredentials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentCredentials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentCredentials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintData(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintData(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Budget != nil {
		{
			size, err := m.Budget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Version) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UpgradeRecommendation != nil {
		{
			size, err := m.UpgradeRecommendation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ReplaceBy != nil {
		{
			size, err := m.ReplaceBy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintData(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplaceVersionBy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplaceVersionBy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplaceVersionBy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintData(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintData(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeVersionRecommendation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeVersionRecommendation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeVersionRecommendation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintData(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintData(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VersionList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VersionList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VersionList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListVersionsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListVersionsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListVersionsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CurrentVersion) > 0 {
		i -= len(m.CurrentVersion)
		copy(dAtA[i:], m.CurrentVersion)
		i = encodeVarintData(dAtA, i, uint64(len(m.CurrentVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrganizationId) > 0 {
		i -= len(m.OrganizationId)
		copy(dAtA[i:], m.OrganizationId)
		i = encodeVarintData(dAtA, i, uint64(len(m.OrganizationId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServersSpecLimitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecLimitsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServersSpecLimitsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintData(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServersSpecLimits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecLimits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServersSpecLimits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeCount != nil {
		{
			size, err := m.NodeCount.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.NodeMemorySize != nil {
		{
			size, err := m.NodeMemorySize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.DbserverDiskSize != nil {
		{
			size, err := m.DbserverDiskSize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.DbserverMemorySize != nil {
		{
			size, err := m.DbserverMemorySize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Dbservers != nil {
		{
			size, err := m.Dbservers.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.CoordinatorMemorySize != nil {
		{
			size, err := m.CoordinatorMemorySize.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Coordinators != nil {
		{
			size, err := m.Coordinators.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServersSpecLimits_Limits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServersSpecLimits_Limits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServersSpecLimits_Limits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllowedValues) > 0 {
		dAtA38 := make([]byte, len(m.AllowedValues)*10)
		var j37 int
		for _, num1 := range m.AllowedValues {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		i -= j37
		copy(dAtA[i:], dAtA38[:j37])
		i = encodeVarintData(dAtA, i, uint64(j37))
		i--
		dAtA[i] = 0x1a
	}
	if m.Max != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Max))
		i--
		dAtA[i] = 0x10
	}
	if m.Min != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Min))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CalculateDeploymentSizeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalculateDeploymentSizeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalculateDeploymentSizeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x92
	}
	if m.NodeDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeDiskSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.NodeCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.NodeSizeId) > 0 {
		i -= len(m.NodeSizeId)
		copy(dAtA[i:], m.NodeSizeId)
		i = encodeVarintData(dAtA, i, uint64(len(m.NodeSizeId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintData(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.DbserverDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DbserverDiskSize))
		i--
		dAtA[i] = 0x68
	}
	if m.DbserverMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DbserverMemorySize))
		i--
		dAtA[i] = 0x60
	}
	if m.Dbservers != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Dbservers))
		i--
		dAtA[i] = 0x58
	}
	if m.CoordinatorMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CoordinatorMemorySize))
		i--
		dAtA[i] = 0x10
	}
	if m.Coordinators != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Coordinators))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentSize) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentSize) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentSize) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DbserverDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DbserverDiskSize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.DbserverMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DbserverMemorySize))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.Dbservers != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Dbservers))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.CoordinatorMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CoordinatorMemorySize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.Coordinators != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Coordinators))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.TotalDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.TotalDiskSize))
		i--
		dAtA[i] = 0x60
	}
	if m.TotalMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.TotalMemorySize))
		i--
		dAtA[i] = 0x58
	}
	if m.AgentDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AgentDiskSize))
		i--
		dAtA[i] = 0x18
	}
	if m.AgentMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AgentMemorySize))
		i--
		dAtA[i] = 0x10
	}
	if m.Agents != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Agents))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentSizeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentSizeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentSizeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x60
	}
	if m.GrowthRate != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.GrowthRate))))
		i--
		dAtA[i] = 0x5d
	}
	if m.AccessUpdatePercentage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AccessUpdatePercentage))))
		i--
		dAtA[i] = 0x55
	}
	if m.AccessCreatePercentage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AccessCreatePercentage))))
		i--
		dAtA[i] = 0x4d
	}
	if m.AccessReadPercentage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AccessReadPercentage))))
		i--
		dAtA[i] = 0x45
	}
	if m.WorkingSetPercentage != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.WorkingSetPercentage))))
		i--
		dAtA[i] = 0x3d
	}
	if m.NumberOfColumns != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NumberOfColumns))
		i--
		dAtA[i] = 0x30
	}
	if m.NumberOfDocuments != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NumberOfDocuments))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FileFormat) > 0 {
		i -= len(m.FileFormat)
		copy(dAtA[i:], m.FileFormat)
		i = encodeVarintData(dAtA, i, uint64(len(m.FileFormat)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintData(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Usecase) > 0 {
		i -= len(m.Usecase)
		copy(dAtA[i:], m.Usecase)
		i = encodeVarintData(dAtA, i, uint64(len(m.Usecase)))
		i--
		dAtA[i] = 0x12
	}
	if m.DatasetSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DatasetSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentSizeRecommendation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentSizeRecommendation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentSizeRecommendation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExceedsPlatform {
		i--
		if m.ExceedsPlatform {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.ExceedsQuota {
		i--
		if m.ExceedsQuota {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.NodeCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x68
	}
	if m.NodeDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeDiskSize))
		i--
		dAtA[i] = 0x60
	}
	if m.NodeMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeMemorySize))
		i--
		dAtA[i] = 0x58
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataVolumeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataVolumeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataVolumeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MeasuredAt != nil {
		{
			size, err := m.MeasuredAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.AvailableInodes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AvailableInodes))
		i--
		dAtA[i] = 0x30
	}
	if m.UsedInodes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.UsedInodes))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalInodes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.TotalInodes))
		i--
		dAtA[i] = 0x20
	}
	if m.AvailableBytes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.AvailableBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.UsedBytes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.UsedBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalBytes != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.TotalBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConnectDriverInstructions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectDriverInstructions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectDriverInstructions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Drivers) > 0 {
		for iNdEx := len(m.Drivers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Drivers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConnectDriverInstructions_DriverInstructions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConnectDriverInstructions_DriverInstructions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConnectDriverInstructions_DriverInstructions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DriverUrl) > 0 {
		i -= len(m.DriverUrl)
		copy(dAtA[i:], m.DriverUrl)
		i = encodeVarintData(dAtA, i, uint64(len(m.DriverUrl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Remarks) > 0 {
		for iNdEx := len(m.Remarks) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Remarks[iNdEx])
			copy(dAtA[i:], m.Remarks[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.Remarks[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Code) > 0 {
		for iNdEx := len(m.Code) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Code[iNdEx])
			copy(dAtA[i:], m.Code[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.Code[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintData(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ImportDataInstructions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImportDataInstructions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImportDataInstructions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ArangoImportTsv) > 0 {
		for iNdEx := len(m.ArangoImportTsv) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ArangoImportTsv[iNdEx])
			copy(dAtA[i:], m.ArangoImportTsv[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.ArangoImportTsv[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ArangoImportCsv) > 0 {
		for iNdEx := len(m.ArangoImportCsv) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ArangoImportCsv[iNdEx])
			copy(dAtA[i:], m.ArangoImportCsv[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.ArangoImportCsv[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ArangoImportJson) > 0 {
		for iNdEx := len(m.ArangoImportJson) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ArangoImportJson[iNdEx])
			copy(dAtA[i:], m.ArangoImportJson[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.ArangoImportJson[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ImportDump) > 0 {
		for iNdEx := len(m.ImportDump) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImportDump[iNdEx])
			copy(dAtA[i:], m.ImportDump[iNdEx])
			i = encodeVarintData(dAtA, i, uint64(len(m.ImportDump[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DbserverDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DbserverDiskSize))
		i--
		dAtA[i] = 0x70
	}
	if m.DbserverMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.DbserverMemorySize))
		i--
		dAtA[i] = 0x68
	}
	if m.Dbservers != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Dbservers))
		i--
		dAtA[i] = 0x60
	}
	if m.CoordinatorMemorySize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.CoordinatorMemorySize))
		i--
		dAtA[i] = 0x58
	}
	if m.Coordinators != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.Coordinators))
		i--
		dAtA[i] = 0x50
	}
	if m.NodeDiskSize != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeDiskSize))
		i--
		dAtA[i] = 0x48
	}
	if m.NodeCount != 0 {
		i = encodeVarintData(dAtA, i, uint64(m.NodeCount))
		i--
		dAtA[i] = 0x40
	}
	if len(m.NodeSizeId) > 0 {
		i -= len(m.NodeSizeId)
		copy(dAtA[i:], m.NodeSizeId)
		i = encodeVarintData(dAtA, i, uint64(len(m.NodeSizeId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintData(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CloudRegionId) > 0 {
		i -= len(m.CloudRegionId)
		copy(dAtA[i:], m.CloudRegionId)
		i = encodeVarintData(dAtA, i, uint64(len(m.CloudRegionId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CloudProviderId) > 0 {
		i -= len(m.CloudProviderId)
		copy(dAtA[i:], m.CloudProviderId)
		i = encodeVarintData(dAtA, i, uint64(len(m.CloudProviderId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SupportPlanId) > 0 {
		i -= len(m.SupportPlanId)
		copy(dAtA[i:], m.SupportPlanId)
		i = encodeVarintData(dAtA, i, uint64(len(m.SupportPlanId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrganizationId) > 0 {
		i -= len(m.OrganizationId)
		copy(dAtA[i:], m.OrganizationId)
		i = encodeVarintData(dAtA, i, uint64(len(m.OrganizationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuditlogPrice != nil {
		{
			size, err := m.AuditlogPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CurrencyId) > 0 {
		i -= len(m.CurrencyId)
		copy(dAtA[i:], m.CurrencyId)
		i = encodeVarintData(dAtA, i, uint64(len(m.CurrencyId)))
		i--
		dAtA[i] = 0x22
	}
	if m.BackupPrice != nil {
		{
			size, err := m.BackupPrice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintData(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NetworkTransferPrices) > 0 {
		for iNdEx := len(m.NetworkTransferPrices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetworkTransferPrices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintData(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.PricePerHour != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PricePerHour))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentPrice_NetworkTransferPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentPrice_NetworkTransferPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentPrice_NetworkTransferPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintData(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EgressPricePerGb != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EgressPricePerGb))))
		i--
		dAtA[i] = 0x15
	}
	if m.IngressPricePerGb != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.IngressPricePerGb))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentPrice_BackupPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentPrice_BackupPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentPrice_BackupPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PricePerGbPerHour != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PricePerGbPerHour))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentPrice_AuditLogPrice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentPrice_AuditLogPrice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentPrice_AuditLogPrice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HttpsPostBodySizePricePerGb != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HttpsPostBodySizePricePerGb))))
		i--
		dAtA[i] = 0x1d
	}
	if m.HttpsPostInvocationPricePer_1000 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HttpsPostInvocationPricePer_1000))))
		i--
		dAtA[i] = 0x15
	}
	if m.PricePerGbPerHour != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PricePerGbPerHour))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentFeatures) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentFeatures) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentFeatures) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Iamprovider {
		i--
		if m.Iamprovider {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeploymentFeaturesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeploymentFeaturesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeploymentFeaturesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NodeSizeId) > 0 {
		i -= len(m.NodeSizeId)
		copy(dAtA[i:], m.NodeSizeId)
		i = encodeVarintData(dAtA, i, uint64(len(m.NodeSizeId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintData(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintData(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintData(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintData(dAtA []byte, offset int, v uint64) int {
	offset -= sovData(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RotateDeploymentServerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTestDatabaseResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateTestDatabaseRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RebalanceDeploymentShardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	l = len(m.SupportPlanId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.CreatedById)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.AcceptedTermsAndConditionsId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Locked {
		n += 2
	}
	if m.IsPaused {
		n += 3
	}
	if m.LastPausedAt != nil {
		l = m.LastPausedAt.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.LastResumedAt != nil {
		l = m.LastResumedAt.Size()
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.PrepaidDeploymentId)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.DisableFoxxAuthentication {
		n += 3
	}
	if m.PrepaidDeploymentStartsAt != nil {
		l = m.PrepaidDeploymentStartsAt.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.PrepaidDeploymentEndsAt != nil {
		l = m.PrepaidDeploymentEndsAt.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.IsPrepaidDeploymentUpdateAvailable {
		n += 3
	}
	if m.PrivateEndpoint {
		n += 3
	}
	l = len(m.Version)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.Certificates != nil {
		l = m.Certificates.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.Servers != nil {
		l = m.Servers.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.ReplaceVersionBy != nil {
		l = m.ReplaceVersionBy.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.UpgradeRecommendation != nil {
		l = m.UpgradeRecommendation.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.Model != nil {
		l = m.Model.Size()
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.CustomImage)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.IamproviderId)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.IpallowlistId)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.Size_ != nil {
		l = m.Size_.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.BackupRestore != nil {
		l = m.BackupRestore.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if len(m.DeploymentRecommendations) > 0 {
		for _, e := range m.DeploymentRecommendations {
			l = e.Size()
			n += 2 + l + sovData(uint64(l))
		}
	}
	if m.IsClone {
		n += 3
	}
	l = len(m.CloneBackupId)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if len(m.NotificationEmailAddresses) > 0 {
		for _, s := range m.NotificationEmailAddresses {
			l = len(s)
			n += 2 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_CertificateSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CaCertificateId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.AlternateDnsNames) > 0 {
		for _, s := range m.AlternateDnsNames {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_ServersSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coordinators != 0 {
		n += 1 + sovData(uint64(m.Coordinators))
	}
	if m.CoordinatorMemorySize != 0 {
		n += 1 + sovData(uint64(m.CoordinatorMemorySize))
	}
	if len(m.CoordinatorArgs) > 0 {
		for _, s := range m.CoordinatorArgs {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.Dbservers != 0 {
		n += 1 + sovData(uint64(m.Dbservers))
	}
	if m.DbserverMemorySize != 0 {
		n += 1 + sovData(uint64(m.DbserverMemorySize))
	}
	if m.DbserverDiskSize != 0 {
		n += 1 + sovData(uint64(m.DbserverDiskSize))
	}
	if len(m.DbserverArgs) > 0 {
		for _, s := range m.DbserverArgs {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.MinimumDbserversCount != 0 {
		n += 1 + sovData(uint64(m.MinimumDbserversCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_ModelSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.NodeSizeId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.NodeCount != 0 {
		n += 1 + sovData(uint64(m.NodeCount))
	}
	if m.NodeDiskSize != 0 {
		n += 1 + sovData(uint64(m.NodeDiskSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_ServerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Ready {
		n += 2
	}
	if m.MemberOfCluster {
		n += 2
	}
	if m.Failed {
		n += 2
	}
	if m.Creating {
		n += 2
	}
	if m.Ok {
		n += 2
	}
	if m.Upgrading {
		n += 2
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.LastStartedAt != nil {
		l = m.LastStartedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.RotationPending {
		n += 2
	}
	if m.Bad {
		n += 2
	}
	if m.CanBeDeleted {
		n += 2
	}
	if m.IsLeader {
		n += 3
	}
	if m.DataVolumeInfo != nil {
		l = m.DataVolumeInfo.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.RecentRestarts != 0 {
		n += 2 + sovData(uint64(m.RecentRestarts))
	}
	if m.LastMemoryUsage != 0 {
		n += 2 + sovData(uint64(m.LastMemoryUsage))
	}
	if m.LastCpuUsage != 0 {
		n += 6
	}
	if m.LastMemoryLimit != 0 {
		n += 2 + sovData(uint64(m.LastMemoryLimit))
	}
	if m.LastCpuLimit != 0 {
		n += 6
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.Created {
		n += 2
	}
	if m.Ready {
		n += 2
	}
	if m.Upgrading {
		n += 2
	}
	if len(m.ServerVersions) > 0 {
		for _, s := range m.ServerVersions {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.Servers) > 0 {
		for _, e := range m.Servers {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.BootstrappedAt != nil {
		l = m.BootstrappedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Bootstrapped {
		n += 2
	}
	l = len(m.EndpointSelfSigned)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.BackupRestoreStatus != nil {
		l = m.BackupRestoreStatus.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.TotalBackupSizeBytes != 0 {
		n += 2 + sovData(uint64(m.TotalBackupSizeBytes))
	}
	if m.BackupUploadInProgress {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_BackupRestoreStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovData(uint64(m.Revision))
	}
	if m.Restoring {
		n += 2
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.FailureReason)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_Expiration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiresAt != nil {
		l = m.ExpiresAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.LastWarningEmailSendAt != nil {
		l = m.LastWarningEmailSendAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.LastWarningEmailSendTo) > 0 {
		for _, s := range m.LastWarningEmailSendTo {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Deployment_BackupRestoreSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Revision != 0 {
		n += 1 + sovData(uint64(m.Revision))
	}
	if m.LastUpdatedAt != nil {
		l = m.LastUpdatedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.BackupId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.MemorySize != 0 {
		n += 1 + sovData(uint64(m.MemorySize))
	}
	if m.MinDiskSize != 0 {
		n += 1 + sovData(uint64(m.MinDiskSize))
	}
	if m.MaxDiskSize != 0 {
		n += 1 + sovData(uint64(m.MaxDiskSize))
	}
	l = len(m.CpuSize)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.DiskSizes) > 0 {
		l = 0
		for _, e := range m.DiskSizes {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NodeSizesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentModelList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDeploymentModelsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CPUSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CPUSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCPUSizesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentCredentialsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentCredentials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.Budget != nil {
		l = m.Budget.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Version) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.ReplaceBy != nil {
		l = m.ReplaceBy.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.UpgradeRecommendation != nil {
		l = m.UpgradeRecommendation.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplaceVersionBy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeVersionRecommendation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VersionList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListVersionsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.OrganizationId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.CurrentVersion)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecLimitsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecLimits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coordinators != nil {
		l = m.Coordinators.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.CoordinatorMemorySize != nil {
		l = m.CoordinatorMemorySize.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.Dbservers != nil {
		l = m.Dbservers.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.DbserverMemorySize != nil {
		l = m.DbserverMemorySize.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.DbserverDiskSize != nil {
		l = m.DbserverDiskSize.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.NodeMemorySize != nil {
		l = m.NodeMemorySize.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.NodeCount != nil {
		l = m.NodeCount.Size()
		n += 2 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ServersSpecLimits_Limits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Min != 0 {
		n += 1 + sovData(uint64(m.Min))
	}
	if m.Max != 0 {
		n += 1 + sovData(uint64(m.Max))
	}
	if len(m.AllowedValues) > 0 {
		l = 0
		for _, e := range m.AllowedValues {
			l += sovData(uint64(e))
		}
		n += 1 + sovData(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CalculateDeploymentSizeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Coordinators != 0 {
		n += 1 + sovData(uint64(m.Coordinators))
	}
	if m.CoordinatorMemorySize != 0 {
		n += 1 + sovData(uint64(m.CoordinatorMemorySize))
	}
	if m.Dbservers != 0 {
		n += 1 + sovData(uint64(m.Dbservers))
	}
	if m.DbserverMemorySize != 0 {
		n += 1 + sovData(uint64(m.DbserverMemorySize))
	}
	if m.DbserverDiskSize != 0 {
		n += 1 + sovData(uint64(m.DbserverDiskSize))
	}
	l = len(m.Model)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.NodeSizeId)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.NodeCount != 0 {
		n += 2 + sovData(uint64(m.NodeCount))
	}
	if m.NodeDiskSize != 0 {
		n += 2 + sovData(uint64(m.NodeDiskSize))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentSize) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Agents != 0 {
		n += 1 + sovData(uint64(m.Agents))
	}
	if m.AgentMemorySize != 0 {
		n += 1 + sovData(uint64(m.AgentMemorySize))
	}
	if m.AgentDiskSize != 0 {
		n += 1 + sovData(uint64(m.AgentDiskSize))
	}
	if m.TotalMemorySize != 0 {
		n += 1 + sovData(uint64(m.TotalMemorySize))
	}
	if m.TotalDiskSize != 0 {
		n += 1 + sovData(uint64(m.TotalDiskSize))
	}
	if m.Coordinators != 0 {
		n += 2 + sovData(uint64(m.Coordinators))
	}
	if m.CoordinatorMemorySize != 0 {
		n += 2 + sovData(uint64(m.CoordinatorMemorySize))
	}
	if m.Dbservers != 0 {
		n += 2 + sovData(uint64(m.Dbservers))
	}
	if m.DbserverMemorySize != 0 {
		n += 2 + sovData(uint64(m.DbserverMemorySize))
	}
	if m.DbserverDiskSize != 0 {
		n += 2 + sovData(uint64(m.DbserverDiskSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentSizeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DatasetSize != 0 {
		n += 1 + sovData(uint64(m.DatasetSize))
	}
	l = len(m.Usecase)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.FileFormat)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.NumberOfDocuments != 0 {
		n += 1 + sovData(uint64(m.NumberOfDocuments))
	}
	if m.NumberOfColumns != 0 {
		n += 1 + sovData(uint64(m.NumberOfColumns))
	}
	if m.WorkingSetPercentage != 0 {
		n += 5
	}
	if m.AccessReadPercentage != 0 {
		n += 5
	}
	if m.AccessCreatePercentage != 0 {
		n += 5
	}
	if m.AccessUpdatePercentage != 0 {
		n += 5
	}
	if m.GrowthRate != 0 {
		n += 5
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovData(uint64(m.ReplicationFactor))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 2 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentSizeRecommendation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.NodeMemorySize != 0 {
		n += 1 + sovData(uint64(m.NodeMemorySize))
	}
	if m.NodeDiskSize != 0 {
		n += 1 + sovData(uint64(m.NodeDiskSize))
	}
	if m.NodeCount != 0 {
		n += 1 + sovData(uint64(m.NodeCount))
	}
	if m.ExceedsQuota {
		n += 3
	}
	if m.ExceedsPlatform {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DataVolumeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalBytes != 0 {
		n += 1 + sovData(uint64(m.TotalBytes))
	}
	if m.UsedBytes != 0 {
		n += 1 + sovData(uint64(m.UsedBytes))
	}
	if m.AvailableBytes != 0 {
		n += 1 + sovData(uint64(m.AvailableBytes))
	}
	if m.TotalInodes != 0 {
		n += 1 + sovData(uint64(m.TotalInodes))
	}
	if m.UsedInodes != 0 {
		n += 1 + sovData(uint64(m.UsedInodes))
	}
	if m.AvailableInodes != 0 {
		n += 1 + sovData(uint64(m.AvailableInodes))
	}
	if m.MeasuredAt != nil {
		l = m.MeasuredAt.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectDriverInstructions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Drivers) > 0 {
		for _, e := range m.Drivers {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConnectDriverInstructions_DriverInstructions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if len(m.Code) > 0 {
		for _, s := range m.Code {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.Remarks) > 0 {
		for _, s := range m.Remarks {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	l = len(m.DriverUrl)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ImportDataInstructions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ImportDump) > 0 {
		for _, s := range m.ImportDump {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.ArangoImportJson) > 0 {
		for _, s := range m.ArangoImportJson {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.ArangoImportCsv) > 0 {
		for _, s := range m.ArangoImportCsv {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if len(m.ArangoImportTsv) > 0 {
		for _, s := range m.ArangoImportTsv {
			l = len(s)
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrganizationId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.SupportPlanId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.CloudProviderId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.CloudRegionId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.NodeSizeId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.NodeCount != 0 {
		n += 1 + sovData(uint64(m.NodeCount))
	}
	if m.NodeDiskSize != 0 {
		n += 1 + sovData(uint64(m.NodeDiskSize))
	}
	if m.Coordinators != 0 {
		n += 1 + sovData(uint64(m.Coordinators))
	}
	if m.CoordinatorMemorySize != 0 {
		n += 1 + sovData(uint64(m.CoordinatorMemorySize))
	}
	if m.Dbservers != 0 {
		n += 1 + sovData(uint64(m.Dbservers))
	}
	if m.DbserverMemorySize != 0 {
		n += 1 + sovData(uint64(m.DbserverMemorySize))
	}
	if m.DbserverDiskSize != 0 {
		n += 1 + sovData(uint64(m.DbserverDiskSize))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PricePerHour != 0 {
		n += 5
	}
	if len(m.NetworkTransferPrices) > 0 {
		for _, e := range m.NetworkTransferPrices {
			l = e.Size()
			n += 1 + l + sovData(uint64(l))
		}
	}
	if m.BackupPrice != nil {
		l = m.BackupPrice.Size()
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.CurrencyId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.AuditlogPrice != nil {
		l = m.AuditlogPrice.Size()
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentPrice_NetworkTransferPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IngressPricePerGb != 0 {
		n += 5
	}
	if m.EgressPricePerGb != 0 {
		n += 5
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentPrice_BackupPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PricePerGbPerHour != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentPrice_AuditLogPrice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PricePerGbPerHour != 0 {
		n += 5
	}
	if m.HttpsPostInvocationPricePer_1000 != 0 {
		n += 5
	}
	if m.HttpsPostBodySizePricePerGb != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentFeatures) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Iamprovider {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeploymentFeaturesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	l = len(m.NodeSizeId)
	if l > 0 {
		n += 1 + l + sovData(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovData(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozData(x uint64) (n int) {
	return sovData(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RotateDeploymentServerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RotateDeploymentServerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RotateDeploymentServerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTestDatabaseResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTestDatabaseResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTestDatabaseResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateTestDatabaseRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateTestDatabaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateTestDatabaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RebalanceDeploymentShardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RebalanceDeploymentShardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RebalanceDeploymentShardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportPlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportPlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedById", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedById = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptedTermsAndConditionsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptedTermsAndConditionsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPaused = bool(v != 0)
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPausedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastPausedAt == nil {
				m.LastPausedAt = &types.Timestamp{}
			}
			if err := m.LastPausedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResumedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastResumedAt == nil {
				m.LastResumedAt = &types.Timestamp{}
			}
			if err := m.LastResumedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepaidDeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisableFoxxAuthentication", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DisableFoxxAuthentication = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentStartsAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepaidDeploymentStartsAt == nil {
				m.PrepaidDeploymentStartsAt = &types.Timestamp{}
			}
			if err := m.PrepaidDeploymentStartsAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentEndsAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrepaidDeploymentEndsAt == nil {
				m.PrepaidDeploymentEndsAt = &types.Timestamp{}
			}
			if err := m.PrepaidDeploymentEndsAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrepaidDeploymentUpdateAvailable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrepaidDeploymentUpdateAvailable = bool(v != 0)
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateEndpoint", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PrivateEndpoint = bool(v != 0)
		case 101:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Certificates == nil {
				m.Certificates = &Deployment_CertificateSpec{}
			}
			if err := m.Certificates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Servers == nil {
				m.Servers = &Deployment_ServersSpec{}
			}
			if err := m.Servers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceVersionBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplaceVersionBy == nil {
				m.ReplaceVersionBy = &ReplaceVersionBy{}
			}
			if err := m.ReplaceVersionBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 105:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeRecommendation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeRecommendation == nil {
				m.UpgradeRecommendation = &UpgradeVersionRecommendation{}
			}
			if err := m.UpgradeRecommendation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 106:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &Deployment_ModelSpec{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 107:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 108:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IamproviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IamproviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 109:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpallowlistId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpallowlistId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &Deployment_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 202:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Size_ == nil {
				m.Size_ = &DeploymentSize{}
			}
			if err := m.Size_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 301:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &Deployment_Expiration{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 401:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupRestore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackupRestore == nil {
				m.BackupRestore = &Deployment_BackupRestoreSpec{}
			}
			if err := m.BackupRestore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 501:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentRecommendations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentRecommendations = append(m.DeploymentRecommendations, &DeploymentSizeRecommendation{})
			if err := m.DeploymentRecommendations[len(m.DeploymentRecommendations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 600:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsClone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsClone = bool(v != 0)
		case 601:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloneBackupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloneBackupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 610:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotificationEmailAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NotificationEmailAddresses = append(m.NotificationEmailAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_CertificateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCertificateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternateDnsNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlternateDnsNames = append(m.AlternateDnsNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_ServersSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			m.Coordinators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coordinators |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			m.CoordinatorMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoordinatorMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoordinatorArgs = append(m.CoordinatorArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			m.Dbservers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dbservers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			m.DbserverMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			m.DbserverDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverArgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbserverArgs = append(m.DbserverArgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumDbserversCount", wireType)
			}
			m.MinimumDbserversCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumDbserversCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_ModelSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSizeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeSizeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDiskSize", wireType)
			}
			m.NodeDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_ServerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemberOfCluster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemberOfCluster = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creating", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Creating = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upgrading", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upgrading = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastStartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastStartedAt == nil {
				m.LastStartedAt = &types.Timestamp{}
			}
			if err := m.LastStartedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RotationPending", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RotationPending = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bad", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bad = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanBeDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanBeDeleted = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLeader", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLeader = bool(v != 0)
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataVolumeInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataVolumeInfo == nil {
				m.DataVolumeInfo = &DataVolumeInfo{}
			}
			if err := m.DataVolumeInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentRestarts", wireType)
			}
			m.RecentRestarts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecentRestarts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMemoryUsage", wireType)
			}
			m.LastMemoryUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMemoryUsage |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpuUsage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LastCpuUsage = float32(math.Float32frombits(v))
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastMemoryLimit", wireType)
			}
			m.LastMemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastMemoryLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.LastCpuLimit = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Created = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upgrading", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Upgrading = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerVersions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerVersions = append(m.ServerVersions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Servers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Servers = append(m.Servers, &Deployment_ServerStatus{})
			if err := m.Servers[len(m.Servers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BootstrappedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BootstrappedAt == nil {
				m.BootstrappedAt = &types.Timestamp{}
			}
			if err := m.BootstrappedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bootstrapped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bootstrapped = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointSelfSigned", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointSelfSigned = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupRestoreStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackupRestoreStatus == nil {
				m.BackupRestoreStatus = &Deployment_BackupRestoreStatus{}
			}
			if err := m.BackupRestoreStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBackupSizeBytes", wireType)
			}
			m.TotalBackupSizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBackupSizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupUploadInProgress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BackupUploadInProgress = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_BackupRestoreStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupRestoreStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupRestoreStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restoring", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Restoring = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_Expiration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expiration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expiration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiresAt == nil {
				m.ExpiresAt = &types.Timestamp{}
			}
			if err := m.ExpiresAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarningEmailSendAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastWarningEmailSendAt == nil {
				m.LastWarningEmailSendAt = &types.Timestamp{}
			}
			if err := m.LastWarningEmailSendAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarningEmailSendTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastWarningEmailSendTo = append(m.LastWarningEmailSendTo, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment_BackupRestoreSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupRestoreSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupRestoreSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			m.Revision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Revision |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdatedAt == nil {
				m.LastUpdatedAt = &types.Timestamp{}
			}
			if err := m.LastUpdatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySize", wireType)
			}
			m.MemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDiskSize", wireType)
			}
			m.MinDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDiskSize", wireType)
			}
			m.MaxDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuSize = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DiskSizes = append(m.DiskSizes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DiskSizes) == 0 {
					m.DiskSizes = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DiskSizes = append(m.DiskSizes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskSizes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &NodeSize{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSizesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSizesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSizesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentModelList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentModelList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentModelList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &DeploymentModel{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDeploymentModelsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDeploymentModelsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDeploymentModelsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &CPUSize{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCPUSizesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCPUSizesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCPUSizesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentCredentialsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentCredentialsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentCredentialsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentCredentials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentCredentials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentCredentials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Deployment{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Budget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Budget == nil {
				m.Budget = &v1.Budget{}
			}
			if err := m.Budget.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReplaceBy == nil {
				m.ReplaceBy = &ReplaceVersionBy{}
			}
			if err := m.ReplaceBy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpgradeRecommendation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpgradeRecommendation == nil {
				m.UpgradeRecommendation = &UpgradeVersionRecommendation{}
			}
			if err := m.UpgradeRecommendation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplaceVersionBy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplaceVersionBy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplaceVersionBy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeVersionRecommendation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeVersionRecommendation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeVersionRecommendation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VersionList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VersionList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VersionList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Version{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListVersionsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListVersionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListVersionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v1.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecLimitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpecLimitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpecLimitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecLimits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServersSpecLimits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServersSpecLimits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Coordinators == nil {
				m.Coordinators = &ServersSpecLimits_Limits{}
			}
			if err := m.Coordinators.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CoordinatorMemorySize == nil {
				m.CoordinatorMemorySize = &ServersSpecLimits_Limits{}
			}
			if err := m.CoordinatorMemorySize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dbservers == nil {
				m.Dbservers = &ServersSpecLimits_Limits{}
			}
			if err := m.Dbservers.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbserverMemorySize == nil {
				m.DbserverMemorySize = &ServersSpecLimits_Limits{}
			}
			if err := m.DbserverMemorySize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DbserverDiskSize == nil {
				m.DbserverDiskSize = &ServersSpecLimits_Limits{}
			}
			if err := m.DbserverDiskSize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeMemorySize", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeMemorySize == nil {
				m.NodeMemorySize = &ServersSpecLimits_Limits{}
			}
			if err := m.NodeMemorySize.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeCount == nil {
				m.NodeCount = &ServersSpecLimits_Limits{}
			}
			if err := m.NodeCount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServersSpecLimits_Limits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Limits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Limits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Min", wireType)
			}
			m.Min = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Min |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Max", wireType)
			}
			m.Max = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Max |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllowedValues = append(m.AllowedValues, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowData
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthData
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthData
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AllowedValues) == 0 {
					m.AllowedValues = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowData
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllowedValues = append(m.AllowedValues, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedValues", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalculateDeploymentSizeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalculateDeploymentSizeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalculateDeploymentSizeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			m.Coordinators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coordinators |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			m.CoordinatorMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoordinatorMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			m.Dbservers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dbservers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			m.DbserverMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			m.DbserverDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSizeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeSizeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDiskSize", wireType)
			}
			m.NodeDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentSize) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentSize: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentSize: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Agents", wireType)
			}
			m.Agents = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Agents |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentMemorySize", wireType)
			}
			m.AgentMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentDiskSize", wireType)
			}
			m.AgentDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AgentDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemorySize", wireType)
			}
			m.TotalMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDiskSize", wireType)
			}
			m.TotalDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			m.Coordinators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coordinators |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			m.CoordinatorMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoordinatorMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			m.Dbservers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dbservers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			m.DbserverMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			m.DbserverDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentSizeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentSizeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentSizeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatasetSize", wireType)
			}
			m.DatasetSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatasetSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usecase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Usecase = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileFormat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfDocuments", wireType)
			}
			m.NumberOfDocuments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfDocuments |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfColumns", wireType)
			}
			m.NumberOfColumns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfColumns |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingSetPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.WorkingSetPercentage = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessReadPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AccessReadPercentage = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessCreatePercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AccessCreatePercentage = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessUpdatePercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AccessUpdatePercentage = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrowthRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.GrowthRate = float32(math.Float32frombits(v))
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentSizeRecommendation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentSizeRecommendation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentSizeRecommendation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &DeploymentSizeRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeMemorySize", wireType)
			}
			m.NodeMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDiskSize", wireType)
			}
			m.NodeDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceedsQuota", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExceedsQuota = bool(v != 0)
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceedsPlatform", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExceedsPlatform = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataVolumeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataVolumeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataVolumeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBytes", wireType)
			}
			m.UsedBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableBytes", wireType)
			}
			m.AvailableBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalInodes", wireType)
			}
			m.TotalInodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalInodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedInodes", wireType)
			}
			m.UsedInodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedInodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableInodes", wireType)
			}
			m.AvailableInodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableInodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasuredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MeasuredAt == nil {
				m.MeasuredAt = &types.Timestamp{}
			}
			if err := m.MeasuredAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectDriverInstructions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectDriverInstructions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectDriverInstructions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Drivers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Drivers = append(m.Drivers, &ConnectDriverInstructions_DriverInstructions{})
			if err := m.Drivers[len(m.Drivers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectDriverInstructions_DriverInstructions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DriverInstructions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DriverInstructions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remarks", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remarks = append(m.Remarks, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DriverUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DriverUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImportDataInstructions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImportDataInstructions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImportDataInstructions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImportDump", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImportDump = append(m.ImportDump, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArangoImportJson", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArangoImportJson = append(m.ArangoImportJson, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArangoImportCsv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArangoImportCsv = append(m.ArangoImportCsv, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArangoImportTsv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArangoImportTsv = append(m.ArangoImportTsv, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportPlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportPlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloudRegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CloudRegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSizeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeSizeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDiskSize", wireType)
			}
			m.NodeDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			m.Coordinators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coordinators |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoordinatorMemorySize", wireType)
			}
			m.CoordinatorMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoordinatorMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dbservers", wireType)
			}
			m.Dbservers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dbservers |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverMemorySize", wireType)
			}
			m.DbserverMemorySize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverMemorySize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbserverDiskSize", wireType)
			}
			m.DbserverDiskSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbserverDiskSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricePerHour", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PricePerHour = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkTransferPrices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkTransferPrices = append(m.NetworkTransferPrices, &DeploymentPrice_NetworkTransferPrice{})
			if err := m.NetworkTransferPrices[len(m.NetworkTransferPrices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BackupPrice == nil {
				m.BackupPrice = &DeploymentPrice_BackupPrice{}
			}
			if err := m.BackupPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrencyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrencyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditlogPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuditlogPrice == nil {
				m.AuditlogPrice = &DeploymentPrice_AuditLogPrice{}
			}
			if err := m.AuditlogPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentPrice_NetworkTransferPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkTransferPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkTransferPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressPricePerGb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.IngressPricePerGb = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EgressPricePerGb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EgressPricePerGb = float32(math.Float32frombits(v))
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentPrice_BackupPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackupPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackupPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricePerGbPerHour", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PricePerGbPerHour = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentPrice_AuditLogPrice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogPrice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogPrice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricePerGbPerHour", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PricePerGbPerHour = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsPostInvocationPricePer_1000", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HttpsPostInvocationPricePer_1000 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpsPostBodySizePricePerGb", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HttpsPostBodySizePricePerGb = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentFeatures) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentFeatures: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentFeatures: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Iamprovider", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Iamprovider = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentFeaturesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowData
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentFeaturesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentFeaturesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSizeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowData
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthData
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthData
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeSizeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipData(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthData
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipData(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowData
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowData
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthData
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthData
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowData
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipData(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthData
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthData = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowData   = fmt.Errorf("proto: integer overflow")
)
