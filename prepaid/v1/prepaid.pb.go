// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: prepaid.proto

package v1

import (
	context "context"
	fmt "fmt"
	v11 "github.com/arangodb-managed/apis/common/v1"
	v1 "github.com/arangodb-managed/apis/data/v1"
	types "github.com/gogo/protobuf/types"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//  A PrepaidDeployment contains all attributes of a future deployment that is already paid for.
type PrepaidDeployment struct {
	// System identifier of the prepaid deployment.
	// This is a read-only value.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// URL of this resource
	// This is a read-only value.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// The name of prepaid deployment, not related to created deployment
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// An optional description for prepaid deployment, not related to created deployment
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Identifier of an organization that owns this prepaid deployment
	OrganizationId string `protobuf:"bytes,5,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	// Identifier of the region in which a deployment is going to be created.
	RegionId string `protobuf:"bytes,6,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	// The creation timestamp of the prepaid deployment
	CreatedAt *types.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// The deletion timestamp of the prepaid deployment
	DeletedAt *types.Timestamp `protobuf:"bytes,8,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
	// Set when this deployment is deleted.
	IsDeleted bool `protobuf:"varint,9,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	// Start of the period for which the PrepaidDeployment was purchased
	StartsAt *types.Timestamp `protobuf:"bytes,10,opt,name=starts_at,json=startsAt,proto3" json:"starts_at,omitempty"`
	// End of the period for which the PrepaidDeployment was purchased
	EndsAt *types.Timestamp `protobuf:"bytes,11,opt,name=ends_at,json=endsAt,proto3" json:"ends_at,omitempty"`
	// Set when current time is betweeen starts_at and ends_at
	// This is a read-only value
	IsActive bool `protobuf:"varint,12,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// Identifier of the support plan selected for this prepaid deployment.
	SupportPlanId string `protobuf:"bytes,13,opt,name=support_plan_id,json=supportPlanId,proto3" json:"support_plan_id,omitempty"`
	// Model specification for created deployment
	Model *v1.Deployment_ModelSpec `protobuf:"bytes,102,opt,name=model,proto3" json:"model,omitempty"`
	// Identifies the addons that will be used on the deployment
	Addons []string `protobuf:"bytes,103,rep,name=addons,proto3" json:"addons,omitempty"`
	// Optional identifier of disk performance to use for this deployment.
	DiskPerformanceId    string                    `protobuf:"bytes,104,opt,name=disk_performance_id,json=diskPerformanceId,proto3" json:"disk_performance_id,omitempty"`
	Status               *PrepaidDeployment_Status `protobuf:"bytes,201,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *PrepaidDeployment) Reset()         { *m = PrepaidDeployment{} }
func (m *PrepaidDeployment) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeployment) ProtoMessage()    {}
func (*PrepaidDeployment) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{0}
}
func (m *PrepaidDeployment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeployment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeployment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeployment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeployment.Merge(m, src)
}
func (m *PrepaidDeployment) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeployment) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeployment.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeployment proto.InternalMessageInfo

func (m *PrepaidDeployment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PrepaidDeployment) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *PrepaidDeployment) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PrepaidDeployment) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PrepaidDeployment) GetOrganizationId() string {
	if m != nil {
		return m.OrganizationId
	}
	return ""
}

func (m *PrepaidDeployment) GetRegionId() string {
	if m != nil {
		return m.RegionId
	}
	return ""
}

func (m *PrepaidDeployment) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PrepaidDeployment) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

func (m *PrepaidDeployment) GetIsDeleted() bool {
	if m != nil {
		return m.IsDeleted
	}
	return false
}

func (m *PrepaidDeployment) GetStartsAt() *types.Timestamp {
	if m != nil {
		return m.StartsAt
	}
	return nil
}

func (m *PrepaidDeployment) GetEndsAt() *types.Timestamp {
	if m != nil {
		return m.EndsAt
	}
	return nil
}

func (m *PrepaidDeployment) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *PrepaidDeployment) GetSupportPlanId() string {
	if m != nil {
		return m.SupportPlanId
	}
	return ""
}

func (m *PrepaidDeployment) GetModel() *v1.Deployment_ModelSpec {
	if m != nil {
		return m.Model
	}
	return nil
}

func (m *PrepaidDeployment) GetAddons() []string {
	if m != nil {
		return m.Addons
	}
	return nil
}

func (m *PrepaidDeployment) GetDiskPerformanceId() string {
	if m != nil {
		return m.DiskPerformanceId
	}
	return ""
}

func (m *PrepaidDeployment) GetStatus() *PrepaidDeployment_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

// Status of the prepaid deployment
// All members of this field are read-only.
type PrepaidDeployment_Status struct {
	// id of created deployment
	// if there is no deployment associated with this prepaid deployment it's empty
	DeploymentId string `protobuf:"bytes,1,opt,name=deployment_id,json=deploymentId,proto3" json:"deployment_id,omitempty"`
	// timestamp when the deployment was created for or attached to PrepaidDeployment
	AttachedAt *types.Timestamp `protobuf:"bytes,2,opt,name=attached_at,json=attachedAt,proto3" json:"attached_at,omitempty"`
	// timestamp when the deployment was detached from PrepaidDeployment
	DetachedAt *types.Timestamp `protobuf:"bytes,3,opt,name=detached_at,json=detachedAt,proto3" json:"detached_at,omitempty"`
	// url of the given deployment
	DeploymentUrl string `protobuf:"bytes,4,opt,name=deployment_url,json=deploymentUrl,proto3" json:"deployment_url,omitempty"`
	// timestamp of the last warning email
	LastWarningEmailSendAt *types.Timestamp `protobuf:"bytes,5,opt,name=last_warning_email_send_at,json=lastWarningEmailSendAt,proto3" json:"last_warning_email_send_at,omitempty"`
	XXX_NoUnkeyedLiteral   struct{}         `json:"-"`
	XXX_unrecognized       []byte           `json:"-"`
	XXX_sizecache          int32            `json:"-"`
}

func (m *PrepaidDeployment_Status) Reset()         { *m = PrepaidDeployment_Status{} }
func (m *PrepaidDeployment_Status) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeployment_Status) ProtoMessage()    {}
func (*PrepaidDeployment_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{0, 0}
}
func (m *PrepaidDeployment_Status) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeployment_Status) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeployment_Status.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeployment_Status) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeployment_Status.Merge(m, src)
}
func (m *PrepaidDeployment_Status) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeployment_Status) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeployment_Status.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeployment_Status proto.InternalMessageInfo

func (m *PrepaidDeployment_Status) GetDeploymentId() string {
	if m != nil {
		return m.DeploymentId
	}
	return ""
}

func (m *PrepaidDeployment_Status) GetAttachedAt() *types.Timestamp {
	if m != nil {
		return m.AttachedAt
	}
	return nil
}

func (m *PrepaidDeployment_Status) GetDetachedAt() *types.Timestamp {
	if m != nil {
		return m.DetachedAt
	}
	return nil
}

func (m *PrepaidDeployment_Status) GetDeploymentUrl() string {
	if m != nil {
		return m.DeploymentUrl
	}
	return ""
}

func (m *PrepaidDeployment_Status) GetLastWarningEmailSendAt() *types.Timestamp {
	if m != nil {
		return m.LastWarningEmailSendAt
	}
	return nil
}

// PrepaidDeploymentList contains a list of PrepaidDeployment items
type PrepaidDeploymentList struct {
	// prepaid deployment items
	Items                []*PrepaidDeployment `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PrepaidDeploymentList) Reset()         { *m = PrepaidDeploymentList{} }
func (m *PrepaidDeploymentList) String() string { return proto.CompactTextString(m) }
func (*PrepaidDeploymentList) ProtoMessage()    {}
func (*PrepaidDeploymentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{1}
}
func (m *PrepaidDeploymentList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepaidDeploymentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepaidDeploymentList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepaidDeploymentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepaidDeploymentList.Merge(m, src)
}
func (m *PrepaidDeploymentList) XXX_Size() int {
	return m.Size()
}
func (m *PrepaidDeploymentList) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepaidDeploymentList.DiscardUnknown(m)
}

var xxx_messageInfo_PrepaidDeploymentList proto.InternalMessageInfo

func (m *PrepaidDeploymentList) GetItems() []*PrepaidDeployment {
	if m != nil {
		return m.Items
	}
	return nil
}

// ListPrepaidDeploymentsRequest is used to request a list of PrepaidDeployments for
// organization with given organization_id
type ListPrepaidDeploymentsRequest struct {
	// identifier of the organization to get a list of prepaid deployments for
	OrganizationId string `protobuf:"bytes,1,opt,name=organization_id,json=organizationId,proto3" json:"organization_id,omitempty"`
	// common listing options
	Options              *v11.ListOptions `protobuf:"bytes,10,opt,name=options,proto3" json:"options,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListPrepaidDeploymentsRequest) Reset()         { *m = ListPrepaidDeploymentsRequest{} }
func (m *ListPrepaidDeploymentsRequest) String() string { return proto.CompactTextString(m) }
func (*ListPrepaidDeploymentsRequest) ProtoMessage()    {}
func (*ListPrepaidDeploymentsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{2}
}
func (m *ListPrepaidDeploymentsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListPrepaidDeploymentsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListPrepaidDeploymentsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListPrepaidDeploymentsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPrepaidDeploymentsRequest.Merge(m, src)
}
func (m *ListPrepaidDeploymentsRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListPrepaidDeploymentsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPrepaidDeploymentsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPrepaidDeploymentsRequest proto.InternalMessageInfo

func (m *ListPrepaidDeploymentsRequest) GetOrganizationId() string {
	if m != nil {
		return m.OrganizationId
	}
	return ""
}

func (m *ListPrepaidDeploymentsRequest) GetOptions() *v11.ListOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// UpdateDeploymentRequest is used to update deployment attached to PrepaidDeployment
// with give prepaid_deployment_id
type UpdateDeploymentRequest struct {
	// Identifier of prepaid deployment
	PrepaidDeploymentId  string   `protobuf:"bytes,1,opt,name=prepaid_deployment_id,json=prepaidDeploymentId,proto3" json:"prepaid_deployment_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateDeploymentRequest) Reset()         { *m = UpdateDeploymentRequest{} }
func (m *UpdateDeploymentRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateDeploymentRequest) ProtoMessage()    {}
func (*UpdateDeploymentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{3}
}
func (m *UpdateDeploymentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDeploymentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDeploymentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDeploymentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDeploymentRequest.Merge(m, src)
}
func (m *UpdateDeploymentRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDeploymentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDeploymentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDeploymentRequest proto.InternalMessageInfo

func (m *UpdateDeploymentRequest) GetPrepaidDeploymentId() string {
	if m != nil {
		return m.PrepaidDeploymentId
	}
	return ""
}

// CloneFromBackupRequest is used to create a new deployment based on PrepaidDeployment
// with prepaid_deployment_id and restore data from Backup with given backup_id
type CloneFromBackupRequest struct {
	// Identifier of prepaid deployment
	PrepaidDeploymentId string `protobuf:"bytes,1,opt,name=prepaid_deployment_id,json=prepaidDeploymentId,proto3" json:"prepaid_deployment_id,omitempty"`
	// Identifier of the backup to restore from
	// Backup specification has to match prepaid_deployment specification in order to succeed
	BackupId             string   `protobuf:"bytes,2,opt,name=backup_id,json=backupId,proto3" json:"backup_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CloneFromBackupRequest) Reset()         { *m = CloneFromBackupRequest{} }
func (m *CloneFromBackupRequest) String() string { return proto.CompactTextString(m) }
func (*CloneFromBackupRequest) ProtoMessage()    {}
func (*CloneFromBackupRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{4}
}
func (m *CloneFromBackupRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloneFromBackupRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloneFromBackupRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloneFromBackupRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloneFromBackupRequest.Merge(m, src)
}
func (m *CloneFromBackupRequest) XXX_Size() int {
	return m.Size()
}
func (m *CloneFromBackupRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CloneFromBackupRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CloneFromBackupRequest proto.InternalMessageInfo

func (m *CloneFromBackupRequest) GetPrepaidDeploymentId() string {
	if m != nil {
		return m.PrepaidDeploymentId
	}
	return ""
}

func (m *CloneFromBackupRequest) GetBackupId() string {
	if m != nil {
		return m.BackupId
	}
	return ""
}

// CreateDeploymentRequest is used to create a new deployment based on PrepaidDeployment
// with given prepaid_deployment_id and attach it to this PrepaidDeployment
type CreateDeploymentRequest struct {
	// Identifier of prepaid deployment to use as a specification and attach the newly created Deployment to
	PrepaidDeploymentId string `protobuf:"bytes,1,opt,name=prepaid_deployment_id,json=prepaidDeploymentId,proto3" json:"prepaid_deployment_id,omitempty"`
	// Identifier of the project that owns the newly created deployment.
	ProjectId string `protobuf:"bytes,2,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// Optional identifier of IP allowlist to use for this deployment.
	IpallowlistId string `protobuf:"bytes,3,opt,name=ipallowlist_id,json=ipallowlistId,proto3" json:"ipallowlist_id,omitempty"`
	// ArangoDB version to use for this deployment.
	Version      string                                   `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Certificates *CreateDeploymentRequest_CertificateSpec `protobuf:"bytes,5,opt,name=certificates,proto3" json:"certificates,omitempty"`
	// This field must be set to the identifier of the current Terms&Conditions
	// when creating a deployment from a prepaid deployment.
	// If the tier of the organization does not require a non-empty Terms&Condition
	// identifier, this field may be left empty.
	AcceptedTermsAndConditionsId string   `protobuf:"bytes,6,opt,name=accepted_terms_and_conditions_id,json=acceptedTermsAndConditionsId,proto3" json:"accepted_terms_and_conditions_id,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *CreateDeploymentRequest) Reset()         { *m = CreateDeploymentRequest{} }
func (m *CreateDeploymentRequest) String() string { return proto.CompactTextString(m) }
func (*CreateDeploymentRequest) ProtoMessage()    {}
func (*CreateDeploymentRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{5}
}
func (m *CreateDeploymentRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDeploymentRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDeploymentRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDeploymentRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDeploymentRequest.Merge(m, src)
}
func (m *CreateDeploymentRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateDeploymentRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDeploymentRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDeploymentRequest proto.InternalMessageInfo

func (m *CreateDeploymentRequest) GetPrepaidDeploymentId() string {
	if m != nil {
		return m.PrepaidDeploymentId
	}
	return ""
}

func (m *CreateDeploymentRequest) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *CreateDeploymentRequest) GetIpallowlistId() string {
	if m != nil {
		return m.IpallowlistId
	}
	return ""
}

func (m *CreateDeploymentRequest) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *CreateDeploymentRequest) GetCertificates() *CreateDeploymentRequest_CertificateSpec {
	if m != nil {
		return m.Certificates
	}
	return nil
}

func (m *CreateDeploymentRequest) GetAcceptedTermsAndConditionsId() string {
	if m != nil {
		return m.AcceptedTermsAndConditionsId
	}
	return ""
}

type CreateDeploymentRequest_CertificateSpec struct {
	// Identifier of the CACertificate used to sign TLS certificates for the deployment.
	// If you change this value after the creation of the deployment a complete
	// rotation of the deployment is required, which will result in some downtime.
	CaCertificateId string `protobuf:"bytes,1,opt,name=ca_certificate_id,json=caCertificateId,proto3" json:"ca_certificate_id,omitempty"`
	// Zero or more DNS names to include in the TLS certificate of the deployment.
	AlternateDnsNames    []string `protobuf:"bytes,2,rep,name=alternate_dns_names,json=alternateDnsNames,proto3" json:"alternate_dns_names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDeploymentRequest_CertificateSpec) Reset() {
	*m = CreateDeploymentRequest_CertificateSpec{}
}
func (m *CreateDeploymentRequest_CertificateSpec) String() string { return proto.CompactTextString(m) }
func (*CreateDeploymentRequest_CertificateSpec) ProtoMessage()    {}
func (*CreateDeploymentRequest_CertificateSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_862bc918d3ba4c11, []int{5, 0}
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDeploymentRequest_CertificateSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDeploymentRequest_CertificateSpec.Merge(m, src)
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_Size() int {
	return m.Size()
}
func (m *CreateDeploymentRequest_CertificateSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDeploymentRequest_CertificateSpec.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDeploymentRequest_CertificateSpec proto.InternalMessageInfo

func (m *CreateDeploymentRequest_CertificateSpec) GetCaCertificateId() string {
	if m != nil {
		return m.CaCertificateId
	}
	return ""
}

func (m *CreateDeploymentRequest_CertificateSpec) GetAlternateDnsNames() []string {
	if m != nil {
		return m.AlternateDnsNames
	}
	return nil
}

func init() {
	proto.RegisterType((*PrepaidDeployment)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeployment")
	proto.RegisterType((*PrepaidDeployment_Status)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeployment.Status")
	proto.RegisterType((*PrepaidDeploymentList)(nil), "arangodb.cloud.prepaid.v1.PrepaidDeploymentList")
	proto.RegisterType((*ListPrepaidDeploymentsRequest)(nil), "arangodb.cloud.prepaid.v1.ListPrepaidDeploymentsRequest")
	proto.RegisterType((*UpdateDeploymentRequest)(nil), "arangodb.cloud.prepaid.v1.UpdateDeploymentRequest")
	proto.RegisterType((*CloneFromBackupRequest)(nil), "arangodb.cloud.prepaid.v1.CloneFromBackupRequest")
	proto.RegisterType((*CreateDeploymentRequest)(nil), "arangodb.cloud.prepaid.v1.CreateDeploymentRequest")
	proto.RegisterType((*CreateDeploymentRequest_CertificateSpec)(nil), "arangodb.cloud.prepaid.v1.CreateDeploymentRequest.CertificateSpec")
}

func init() { proto.RegisterFile("prepaid.proto", fileDescriptor_862bc918d3ba4c11) }

var fileDescriptor_862bc918d3ba4c11 = []byte{
	// 1191 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x4f, 0x6f, 0xdc, 0x44,
	0x14, 0xc7, 0xbb, 0xed, 0x66, 0x77, 0x92, 0x4d, 0x9a, 0x29, 0x4d, 0xdd, 0x6d, 0x13, 0x16, 0x47,
	0xa5, 0x21, 0x50, 0x9b, 0x24, 0x07, 0xa0, 0x15, 0x42, 0x9b, 0xa4, 0xad, 0x0c, 0x29, 0x84, 0x4d,
	0x9b, 0x4a, 0x70, 0xb0, 0x26, 0x9e, 0x89, 0x33, 0xd4, 0x9e, 0x31, 0x9e, 0xd9, 0x2d, 0xa1, 0xca,
	0x85, 0x1b, 0x67, 0x2e, 0x88, 0x0f, 0xc0, 0x17, 0xe1, 0x02, 0x88, 0x43, 0xa5, 0x7e, 0x01, 0x14,
	0xf8, 0x18, 0x1c, 0xd0, 0x8c, 0xbd, 0xb1, 0xd9, 0xec, 0x9f, 0x46, 0x54, 0xe2, 0xb4, 0x9e, 0x37,
	0xbf, 0xf7, 0xde, 0x6f, 0xde, 0xbc, 0xf7, 0xb3, 0x17, 0xd4, 0xe3, 0x84, 0xc4, 0x88, 0x62, 0x3b,
	0x4e, 0xb8, 0xe4, 0xf0, 0x0a, 0x4a, 0x10, 0x0b, 0x38, 0xde, 0xb3, 0xfd, 0x90, 0x77, 0x94, 0x35,
	0xdd, 0xed, 0xae, 0x34, 0xe6, 0x7c, 0x1e, 0x45, 0x9c, 0x39, 0xdd, 0x15, 0x27, 0x7d, 0x4a, 0x5d,
	0x1a, 0x10, 0x23, 0x89, 0x94, 0x55, 0xfd, 0x66, 0xb6, 0xdb, 0x01, 0x95, 0x07, 0x9d, 0x3d, 0xdb,
	0xe7, 0x91, 0x13, 0xf0, 0x10, 0xb1, 0xc0, 0xd1, 0x1b, 0x7b, 0x9d, 0x7d, 0x27, 0x96, 0x87, 0x31,
	0x11, 0x8e, 0xa4, 0x11, 0x11, 0x12, 0x45, 0x71, 0xfe, 0x94, 0x39, 0x5f, 0x0b, 0x38, 0x0f, 0x42,
	0xe2, 0xa0, 0x98, 0x3a, 0x88, 0x31, 0x2e, 0x91, 0xa4, 0x9c, 0x89, 0x74, 0xd7, 0xfa, 0x7b, 0x02,
	0xcc, 0x6e, 0xa7, 0xac, 0x36, 0x49, 0x1c, 0xf2, 0xc3, 0x88, 0x30, 0x09, 0xa7, 0x41, 0x89, 0x62,
	0xd3, 0x68, 0x1a, 0x4b, 0xb5, 0x76, 0x89, 0x62, 0x78, 0x01, 0x94, 0x3b, 0x49, 0x68, 0x96, 0xb4,
	0x41, 0x3d, 0x42, 0x08, 0xce, 0x31, 0x14, 0x11, 0xb3, 0xac, 0x4d, 0xfa, 0x19, 0x36, 0xc1, 0x24,
	0x26, 0xc2, 0x4f, 0x68, 0xac, 0x32, 0x98, 0xe7, 0xf4, 0x56, 0xd1, 0x04, 0x6f, 0x80, 0x19, 0x9e,
	0x04, 0x88, 0xd1, 0x6f, 0x34, 0x09, 0x8f, 0x62, 0xf3, 0xbc, 0x46, 0x4d, 0x17, 0xcd, 0x2e, 0x86,
	0x57, 0x41, 0x2d, 0x21, 0x41, 0x06, 0xa9, 0x68, 0x48, 0x35, 0x35, 0xb8, 0x18, 0xbe, 0x0f, 0x80,
	0x9f, 0x10, 0x24, 0x09, 0xf6, 0x90, 0x34, 0x27, 0x9a, 0xc6, 0xd2, 0xe4, 0x6a, 0xc3, 0x4e, 0x8f,
	0x69, 0xf7, 0x0a, 0x63, 0x3f, 0xe8, 0xd5, 0xa1, 0x5d, 0xcb, 0xd0, 0x2d, 0xa9, 0x5c, 0x31, 0x09,
	0x49, 0xe6, 0x5a, 0x1d, 0xef, 0x9a, 0xa1, 0x5b, 0x12, 0xce, 0x03, 0x40, 0x85, 0x97, 0xad, 0xcd,
	0x5a, 0xd3, 0x58, 0xaa, 0xb6, 0x6b, 0x54, 0x6c, 0xa6, 0x06, 0xf8, 0x2e, 0xa8, 0x09, 0x89, 0x12,
	0x29, 0x54, 0x60, 0x30, 0x36, 0x70, 0x35, 0x05, 0xb7, 0x24, 0x5c, 0x03, 0x13, 0x84, 0x61, 0xed,
	0x36, 0x39, 0xd6, 0xad, 0xa2, 0xa0, 0x2d, 0xa9, 0xea, 0x43, 0x85, 0x87, 0x7c, 0x49, 0xbb, 0xc4,
	0x9c, 0xd2, 0x5c, 0xaa, 0x54, 0xb4, 0xf4, 0x1a, 0xbe, 0x01, 0x66, 0x44, 0x27, 0x8e, 0x79, 0x22,
	0xbd, 0x38, 0x44, 0xba, 0x84, 0x75, 0x5d, 0xc2, 0x7a, 0x66, 0xde, 0x0e, 0x91, 0xaa, 0xe3, 0x3a,
	0x38, 0x1f, 0x71, 0x4c, 0x42, 0x73, 0x5f, 0xe7, 0x7d, 0xdb, 0xee, 0xeb, 0x56, 0xdd, 0x81, 0xdd,
	0x15, 0x3b, 0x6f, 0x0c, 0xfb, 0xbe, 0xc2, 0xef, 0xc4, 0xc4, 0x6f, 0xa7, 0xae, 0x70, 0x0e, 0x54,
	0x10, 0xc6, 0x9c, 0x09, 0x33, 0x68, 0x96, 0x97, 0x6a, 0xed, 0x6c, 0x05, 0x6d, 0x70, 0x11, 0x53,
	0xf1, 0xd8, 0x8b, 0x49, 0xb2, 0xcf, 0x93, 0x08, 0x31, 0x9f, 0x28, 0x1e, 0x07, 0x9a, 0xc7, 0xac,
	0xda, 0xda, 0xce, 0x77, 0x5c, 0x0c, 0xb7, 0x40, 0x45, 0x48, 0x24, 0x3b, 0xc2, 0xfc, 0xd5, 0xd0,
	0x6c, 0xd6, 0xec, 0xa1, 0xb3, 0x63, 0x9f, 0x6a, 0x58, 0x7b, 0x47, 0xfb, 0xb6, 0xb3, 0x18, 0x8d,
	0x9f, 0x4a, 0xa0, 0x92, 0x9a, 0xe0, 0x22, 0xa8, 0xe3, 0x13, 0x9c, 0x77, 0xd2, 0xd5, 0x53, 0xb9,
	0xd1, 0xc5, 0xf0, 0x36, 0x98, 0x44, 0x52, 0x22, 0xff, 0x20, 0xed, 0x8b, 0xd2, 0xd8, 0x7b, 0x00,
	0x3d, 0x78, 0x4b, 0x2a, 0x67, 0x4c, 0x72, 0xe7, 0xf2, 0x78, 0xe7, 0x1e, 0xbc, 0x25, 0xe1, 0x75,
	0x30, 0x5d, 0xa0, 0xa7, 0x86, 0x2c, 0x1d, 0x9b, 0x02, 0xe9, 0x87, 0x49, 0x08, 0x77, 0x41, 0x23,
	0x44, 0x42, 0x7a, 0x4f, 0x50, 0xc2, 0x28, 0x0b, 0x3c, 0x12, 0x21, 0x1a, 0x7a, 0x82, 0x30, 0x9d,
	0xf2, 0xfc, 0xd8, 0x94, 0x73, 0xca, 0xfb, 0x51, 0xea, 0x7c, 0x47, 0xf9, 0xee, 0x10, 0x86, 0x5b,
	0xd2, 0xfa, 0x02, 0x5c, 0x3a, 0x55, 0xcc, 0x2d, 0x2a, 0xa4, 0xea, 0x0d, 0x2a, 0x49, 0x24, 0x4c,
	0xa3, 0x59, 0x1e, 0xd4, 0x1b, 0xa3, 0x6e, 0xa3, 0x9d, 0xba, 0x5a, 0xdf, 0x19, 0x60, 0x5e, 0x05,
	0x3b, 0x05, 0x10, 0x6d, 0xf2, 0x55, 0x87, 0x08, 0x39, 0x48, 0x0f, 0x8c, 0x81, 0x7a, 0xf0, 0x21,
	0x98, 0xe0, 0x5a, 0x42, 0x44, 0x36, 0x5b, 0xd7, 0xfb, 0x09, 0x65, 0x22, 0xda, 0x5d, 0xb1, 0x55,
	0xca, 0x4f, 0x53, 0x70, 0xbb, 0xe7, 0x65, 0xdd, 0x07, 0x97, 0x1f, 0xc6, 0x18, 0x49, 0x52, 0xa0,
	0x99, 0x91, 0x58, 0x05, 0x97, 0xb2, 0xd3, 0x78, 0x83, 0x3a, 0xe5, 0x62, 0xdc, 0x4f, 0xdf, 0xc5,
	0x16, 0x05, 0x73, 0x1b, 0x21, 0x67, 0xe4, 0x6e, 0xc2, 0xa3, 0x75, 0xe4, 0x3f, 0xee, 0xc4, 0xff,
	0x21, 0x9a, 0x9a, 0xe6, 0x3d, 0x1d, 0x44, 0xe1, 0x52, 0x91, 0xad, 0xa6, 0x06, 0x17, 0x5b, 0xbf,
	0x97, 0xc1, 0xe5, 0x0d, 0x2d, 0x60, 0x2f, 0x85, 0xba, 0xd2, 0xb1, 0x38, 0xe1, 0x5f, 0x12, 0x5f,
	0xe6, 0xd9, 0x6a, 0x99, 0xc5, 0xc5, 0xaa, 0x21, 0x69, 0x8c, 0xc2, 0x90, 0x3f, 0x09, 0xa9, 0xd0,
	0x90, 0x54, 0xe2, 0xeb, 0x05, 0xab, 0x8b, 0xa1, 0x09, 0x26, 0xba, 0x24, 0x11, 0xb9, 0xce, 0xf7,
	0x96, 0x70, 0x1f, 0x4c, 0xf9, 0x24, 0x91, 0x74, 0x9f, 0xfa, 0x48, 0x12, 0x91, 0x35, 0xe7, 0xfa,
	0x88, 0x06, 0x1a, 0x72, 0x3a, 0x7b, 0x23, 0x0f, 0xa3, 0x25, 0xe7, 0x5f, 0x71, 0xe1, 0x5d, 0xd0,
	0x44, 0xbe, 0x4f, 0x62, 0xa5, 0xe5, 0x92, 0x24, 0x91, 0xf0, 0x10, 0xc3, 0x9e, 0xcf, 0x19, 0xa6,
	0xfa, 0xca, 0xf3, 0x37, 0xc7, 0xb5, 0x1e, 0xee, 0x81, 0x82, 0xb5, 0x18, 0xde, 0x38, 0x01, 0xb9,
	0xb8, 0x11, 0x81, 0x99, 0xbe, 0x44, 0x70, 0x19, 0xcc, 0xfa, 0xc8, 0x2b, 0x64, 0xcb, 0x4b, 0x3a,
	0xe3, 0xa3, 0x02, 0xda, 0xc5, 0x4a, 0xe8, 0x50, 0x28, 0x49, 0xc2, 0x14, 0x0c, 0x33, 0xe1, 0xa9,
	0x57, 0xa1, 0x30, 0x4b, 0x5a, 0x0d, 0x67, 0x4f, 0xb6, 0x36, 0x99, 0xf8, 0x44, 0x6d, 0xac, 0x3e,
	0xaf, 0x82, 0xe9, 0x6c, 0x20, 0x76, 0x48, 0xd2, 0xa5, 0x3e, 0x81, 0x5f, 0x83, 0xfa, 0x3d, 0x22,
	0x5b, 0xdb, 0xee, 0x6e, 0x56, 0xc2, 0xd7, 0x86, 0x37, 0xf7, 0x9d, 0x28, 0x96, 0x87, 0x8d, 0xd7,
	0x87, 0x03, 0xb2, 0x18, 0xd6, 0xe2, 0xb7, 0xcf, 0xff, 0xfa, 0xbe, 0x34, 0x0f, 0xaf, 0xea, 0x17,
	0x7f, 0x56, 0x6d, 0xf5, 0x5d, 0x81, 0x62, 0x7a, 0xb3, 0x77, 0x57, 0xcf, 0x0c, 0x30, 0x37, 0x78,
	0x42, 0xe1, 0x7b, 0x23, 0x2e, 0x6c, 0xe4, 0x50, 0x37, 0xde, 0x39, 0x8b, 0x56, 0xa8, 0x50, 0xd6,
	0x47, 0x9a, 0xeb, 0xa6, 0xb5, 0xde, 0xcf, 0xb5, 0xa8, 0x02, 0xc2, 0x79, 0xda, 0xa7, 0x15, 0x47,
	0x3d, 0x28, 0x2e, 0xf0, 0xfe, 0xd1, 0x00, 0xaf, 0xde, 0x23, 0xa7, 0xe9, 0xc1, 0xc5, 0xe1, 0x35,
	0x73, 0x37, 0x33, 0xbd, 0x68, 0x9c, 0x49, 0xe7, 0x2c, 0x47, 0xf3, 0x7e, 0x13, 0xde, 0xe8, 0xe7,
	0x7d, 0x9a, 0x97, 0xf3, 0x94, 0xe2, 0x23, 0xf8, 0xb3, 0x01, 0x2e, 0xf4, 0x77, 0x3b, 0x5c, 0x3d,
	0xfb, 0x68, 0x34, 0xac, 0xf1, 0xef, 0x6a, 0xeb, 0x91, 0x66, 0xf7, 0x99, 0xb5, 0xf5, 0x22, 0xec,
	0x06, 0xca, 0xc8, 0x91, 0x93, 0x2f, 0x9d, 0xf4, 0x23, 0xea, 0x96, 0xb1, 0xac, 0x4f, 0xd1, 0x2f,
	0xa6, 0x23, 0x4f, 0x31, 0x44, 0x79, 0xff, 0x8f, 0x53, 0x74, 0x34, 0x15, 0x75, 0x8a, 0xdf, 0x0c,
	0x70, 0x45, 0x6b, 0x78, 0x9e, 0x2c, 0x57, 0x73, 0xb8, 0x32, 0xea, 0x52, 0x06, 0x2a, 0xff, 0x0b,
	0x9d, 0x66, 0x57, 0x9f, 0x66, 0xdb, 0xfa, 0xf8, 0x25, 0xdd, 0x89, 0x62, 0x72, 0xcb, 0x58, 0x5e,
	0xff, 0xe0, 0x97, 0xe3, 0x05, 0xe3, 0xd9, 0xf1, 0x82, 0xf1, 0xc7, 0xf1, 0x82, 0xf1, 0xc3, 0x9f,
	0x0b, 0xaf, 0x7c, 0xfe, 0x56, 0xe1, 0x3f, 0x43, 0x8f, 0xd7, 0xcd, 0x08, 0x31, 0x14, 0x10, 0xac,
	0x92, 0x8b, 0x42, 0xf6, 0xbd, 0x8a, 0xfe, 0x64, 0x58, 0xfb, 0x27, 0x00, 0x00, 0xff, 0xff, 0xf7,
	0xed, 0x9d, 0x81, 0xbf, 0x0c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PrepaidServiceClient is the client API for PrepaidService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PrepaidServiceClient interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(ctx context.Context, in *v11.Empty, opts ...grpc.CallOption) (*v11.Version, error)
	// Fetch all prepaid deployments for organization.
	// Required permissions:
	// - prepaid.prepaiddeployment.list on the organization identified by given organization ID
	ListPrepaidDeployments(ctx context.Context, in *ListPrepaidDeploymentsRequest, opts ...grpc.CallOption) (*PrepaidDeploymentList, error)
	// Fetch a deployment by its id.
	// Required permissions:
	// - prepaid.prepaiddeployment.get on the deployment identified by the given ID
	GetPrepaidDeployment(ctx context.Context, in *v11.IDOptions, opts ...grpc.CallOption) (*PrepaidDeployment, error)
	// Creates a new deployment from a prepaid deployment and attached the newly created deployment to the prepaid deployment.
	// Required permissions:
	// - data.deployment.create on the project in which the deployment is going to be created
	// - prepaid.prepaiddeployment.get on the deployment identified by the given prepaid_deployment_id
	CreateDeployment(ctx context.Context, in *CreateDeploymentRequest, opts ...grpc.CallOption) (*v1.Deployment, error)
	// Update the deployment by prepaid deployment's id
	// Required permissions:
	// - data.deployment.update on the deployment attached to the prepaid deployment
	// - prepaid.prepaiddeployment.get on the deployment identified by the given prepaid_deployment_id
	UpdateDeployment(ctx context.Context, in *UpdateDeploymentRequest, opts ...grpc.CallOption) (*v1.Deployment, error)
	// Creates a cloned deployment from a backup and attaches it to the prepaid deployment. This takes the deployment specification from the prepaid deployment, which must match the specification mentioned in the backup.
	// Required permissions:
	// - prepaid.prepaiddeployment.get on the prepaid deployment identified by the given prepaid_deployment_id
	// - replication.deployment.clone-from-backup
	CloneDeploymentFromBackup(ctx context.Context, in *CloneFromBackupRequest, opts ...grpc.CallOption) (*v1.Deployment, error)
}

type prepaidServiceClient struct {
	cc *grpc.ClientConn
}

func NewPrepaidServiceClient(cc *grpc.ClientConn) PrepaidServiceClient {
	return &prepaidServiceClient{cc}
}

func (c *prepaidServiceClient) GetAPIVersion(ctx context.Context, in *v11.Empty, opts ...grpc.CallOption) (*v11.Version, error) {
	out := new(v11.Version)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/GetAPIVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) ListPrepaidDeployments(ctx context.Context, in *ListPrepaidDeploymentsRequest, opts ...grpc.CallOption) (*PrepaidDeploymentList, error) {
	out := new(PrepaidDeploymentList)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/ListPrepaidDeployments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) GetPrepaidDeployment(ctx context.Context, in *v11.IDOptions, opts ...grpc.CallOption) (*PrepaidDeployment, error) {
	out := new(PrepaidDeployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/GetPrepaidDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) CreateDeployment(ctx context.Context, in *CreateDeploymentRequest, opts ...grpc.CallOption) (*v1.Deployment, error) {
	out := new(v1.Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/CreateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) UpdateDeployment(ctx context.Context, in *UpdateDeploymentRequest, opts ...grpc.CallOption) (*v1.Deployment, error) {
	out := new(v1.Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/UpdateDeployment", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *prepaidServiceClient) CloneDeploymentFromBackup(ctx context.Context, in *CloneFromBackupRequest, opts ...grpc.CallOption) (*v1.Deployment, error) {
	out := new(v1.Deployment)
	err := c.cc.Invoke(ctx, "/arangodb.cloud.prepaid.v1.PrepaidService/CloneDeploymentFromBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PrepaidServiceServer is the server API for PrepaidService service.
type PrepaidServiceServer interface {
	// Get the current API version of this service.
	// Required permissions:
	// - None
	GetAPIVersion(context.Context, *v11.Empty) (*v11.Version, error)
	// Fetch all prepaid deployments for organization.
	// Required permissions:
	// - prepaid.prepaiddeployment.list on the organization identified by given organization ID
	ListPrepaidDeployments(context.Context, *ListPrepaidDeploymentsRequest) (*PrepaidDeploymentList, error)
	// Fetch a deployment by its id.
	// Required permissions:
	// - prepaid.prepaiddeployment.get on the deployment identified by the given ID
	GetPrepaidDeployment(context.Context, *v11.IDOptions) (*PrepaidDeployment, error)
	// Creates a new deployment from a prepaid deployment and attached the newly created deployment to the prepaid deployment.
	// Required permissions:
	// - data.deployment.create on the project in which the deployment is going to be created
	// - prepaid.prepaiddeployment.get on the deployment identified by the given prepaid_deployment_id
	CreateDeployment(context.Context, *CreateDeploymentRequest) (*v1.Deployment, error)
	// Update the deployment by prepaid deployment's id
	// Required permissions:
	// - data.deployment.update on the deployment attached to the prepaid deployment
	// - prepaid.prepaiddeployment.get on the deployment identified by the given prepaid_deployment_id
	UpdateDeployment(context.Context, *UpdateDeploymentRequest) (*v1.Deployment, error)
	// Creates a cloned deployment from a backup and attaches it to the prepaid deployment. This takes the deployment specification from the prepaid deployment, which must match the specification mentioned in the backup.
	// Required permissions:
	// - prepaid.prepaiddeployment.get on the prepaid deployment identified by the given prepaid_deployment_id
	// - replication.deployment.clone-from-backup
	CloneDeploymentFromBackup(context.Context, *CloneFromBackupRequest) (*v1.Deployment, error)
}

// UnimplementedPrepaidServiceServer can be embedded to have forward compatible implementations.
type UnimplementedPrepaidServiceServer struct {
}

func (*UnimplementedPrepaidServiceServer) GetAPIVersion(ctx context.Context, req *v11.Empty) (*v11.Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAPIVersion not implemented")
}
func (*UnimplementedPrepaidServiceServer) ListPrepaidDeployments(ctx context.Context, req *ListPrepaidDeploymentsRequest) (*PrepaidDeploymentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPrepaidDeployments not implemented")
}
func (*UnimplementedPrepaidServiceServer) GetPrepaidDeployment(ctx context.Context, req *v11.IDOptions) (*PrepaidDeployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrepaidDeployment not implemented")
}
func (*UnimplementedPrepaidServiceServer) CreateDeployment(ctx context.Context, req *CreateDeploymentRequest) (*v1.Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDeployment not implemented")
}
func (*UnimplementedPrepaidServiceServer) UpdateDeployment(ctx context.Context, req *UpdateDeploymentRequest) (*v1.Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDeployment not implemented")
}
func (*UnimplementedPrepaidServiceServer) CloneDeploymentFromBackup(ctx context.Context, req *CloneFromBackupRequest) (*v1.Deployment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloneDeploymentFromBackup not implemented")
}

func RegisterPrepaidServiceServer(s *grpc.Server, srv PrepaidServiceServer) {
	s.RegisterService(&_PrepaidService_serviceDesc, srv)
}

func _PrepaidService_GetAPIVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).GetAPIVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/GetAPIVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).GetAPIVersion(ctx, req.(*v11.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_ListPrepaidDeployments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrepaidDeploymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).ListPrepaidDeployments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/ListPrepaidDeployments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).ListPrepaidDeployments(ctx, req.(*ListPrepaidDeploymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_GetPrepaidDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v11.IDOptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).GetPrepaidDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/GetPrepaidDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).GetPrepaidDeployment(ctx, req.(*v11.IDOptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_CreateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).CreateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/CreateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).CreateDeployment(ctx, req.(*CreateDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_UpdateDeployment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDeploymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).UpdateDeployment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/UpdateDeployment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).UpdateDeployment(ctx, req.(*UpdateDeploymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrepaidService_CloneDeploymentFromBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloneFromBackupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrepaidServiceServer).CloneDeploymentFromBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arangodb.cloud.prepaid.v1.PrepaidService/CloneDeploymentFromBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrepaidServiceServer).CloneDeploymentFromBackup(ctx, req.(*CloneFromBackupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PrepaidService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arangodb.cloud.prepaid.v1.PrepaidService",
	HandlerType: (*PrepaidServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAPIVersion",
			Handler:    _PrepaidService_GetAPIVersion_Handler,
		},
		{
			MethodName: "ListPrepaidDeployments",
			Handler:    _PrepaidService_ListPrepaidDeployments_Handler,
		},
		{
			MethodName: "GetPrepaidDeployment",
			Handler:    _PrepaidService_GetPrepaidDeployment_Handler,
		},
		{
			MethodName: "CreateDeployment",
			Handler:    _PrepaidService_CreateDeployment_Handler,
		},
		{
			MethodName: "UpdateDeployment",
			Handler:    _PrepaidService_UpdateDeployment_Handler,
		},
		{
			MethodName: "CloneDeploymentFromBackup",
			Handler:    _PrepaidService_CloneDeploymentFromBackup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "prepaid.proto",
}

func (m *PrepaidDeployment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeployment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeployment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xc
		i--
		dAtA[i] = 0xca
	}
	if len(m.DiskPerformanceId) > 0 {
		i -= len(m.DiskPerformanceId)
		copy(dAtA[i:], m.DiskPerformanceId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.DiskPerformanceId)))
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xc2
	}
	if len(m.Addons) > 0 {
		for iNdEx := len(m.Addons) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Addons[iNdEx])
			copy(dAtA[i:], m.Addons[iNdEx])
			i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Addons[iNdEx])))
			i--
			dAtA[i] = 0x6
			i--
			dAtA[i] = 0xba
		}
	}
	if m.Model != nil {
		{
			size, err := m.Model.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6
		i--
		dAtA[i] = 0xb2
	}
	if len(m.SupportPlanId) > 0 {
		i -= len(m.SupportPlanId)
		copy(dAtA[i:], m.SupportPlanId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.SupportPlanId)))
		i--
		dAtA[i] = 0x6a
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.EndsAt != nil {
		{
			size, err := m.EndsAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.StartsAt != nil {
		{
			size, err := m.StartsAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.IsDeleted {
		i--
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DeletedAt != nil {
		{
			size, err := m.DeletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.RegionId) > 0 {
		i -= len(m.RegionId)
		copy(dAtA[i:], m.RegionId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.RegionId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OrganizationId) > 0 {
		i -= len(m.OrganizationId)
		copy(dAtA[i:], m.OrganizationId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.OrganizationId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepaidDeployment_Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeployment_Status) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeployment_Status) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastWarningEmailSendAt != nil {
		{
			size, err := m.LastWarningEmailSendAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DeploymentUrl) > 0 {
		i -= len(m.DeploymentUrl)
		copy(dAtA[i:], m.DeploymentUrl)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.DeploymentUrl)))
		i--
		dAtA[i] = 0x22
	}
	if m.DetachedAt != nil {
		{
			size, err := m.DetachedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AttachedAt != nil {
		{
			size, err := m.AttachedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeploymentId) > 0 {
		i -= len(m.DeploymentId)
		copy(dAtA[i:], m.DeploymentId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.DeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PrepaidDeploymentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepaidDeploymentList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepaidDeploymentList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPrepaid(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ListPrepaidDeploymentsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPrepaidDeploymentsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListPrepaidDeploymentsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Options != nil {
		{
			size, err := m.Options.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.OrganizationId) > 0 {
		i -= len(m.OrganizationId)
		copy(dAtA[i:], m.OrganizationId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.OrganizationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDeploymentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDeploymentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDeploymentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PrepaidDeploymentId) > 0 {
		i -= len(m.PrepaidDeploymentId)
		copy(dAtA[i:], m.PrepaidDeploymentId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.PrepaidDeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloneFromBackupRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloneFromBackupRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloneFromBackupRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.BackupId) > 0 {
		i -= len(m.BackupId)
		copy(dAtA[i:], m.BackupId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.BackupId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrepaidDeploymentId) > 0 {
		i -= len(m.PrepaidDeploymentId)
		copy(dAtA[i:], m.PrepaidDeploymentId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.PrepaidDeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateDeploymentRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDeploymentRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDeploymentRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AcceptedTermsAndConditionsId) > 0 {
		i -= len(m.AcceptedTermsAndConditionsId)
		copy(dAtA[i:], m.AcceptedTermsAndConditionsId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.AcceptedTermsAndConditionsId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Certificates != nil {
		{
			size, err := m.Certificates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPrepaid(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IpallowlistId) > 0 {
		i -= len(m.IpallowlistId)
		copy(dAtA[i:], m.IpallowlistId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.IpallowlistId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrepaidDeploymentId) > 0 {
		i -= len(m.PrepaidDeploymentId)
		copy(dAtA[i:], m.PrepaidDeploymentId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.PrepaidDeploymentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateDeploymentRequest_CertificateSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDeploymentRequest_CertificateSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDeploymentRequest_CertificateSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AlternateDnsNames) > 0 {
		for iNdEx := len(m.AlternateDnsNames) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AlternateDnsNames[iNdEx])
			copy(dAtA[i:], m.AlternateDnsNames[iNdEx])
			i = encodeVarintPrepaid(dAtA, i, uint64(len(m.AlternateDnsNames[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CaCertificateId) > 0 {
		i -= len(m.CaCertificateId)
		copy(dAtA[i:], m.CaCertificateId)
		i = encodeVarintPrepaid(dAtA, i, uint64(len(m.CaCertificateId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPrepaid(dAtA []byte, offset int, v uint64) int {
	offset -= sovPrepaid(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PrepaidDeployment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.OrganizationId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.RegionId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	if m.StartsAt != nil {
		l = m.StartsAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.EndsAt != nil {
		l = m.EndsAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	l = len(m.SupportPlanId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.Model != nil {
		l = m.Model.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if len(m.Addons) > 0 {
		for _, s := range m.Addons {
			l = len(s)
			n += 2 + l + sovPrepaid(uint64(l))
		}
	}
	l = len(m.DiskPerformanceId)
	if l > 0 {
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 2 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepaidDeployment_Status) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeploymentId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.AttachedAt != nil {
		l = m.AttachedAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.DetachedAt != nil {
		l = m.DetachedAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.DeploymentUrl)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.LastWarningEmailSendAt != nil {
		l = m.LastWarningEmailSendAt.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrepaidDeploymentList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovPrepaid(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListPrepaidDeploymentsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrganizationId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateDeploymentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrepaidDeploymentId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CloneFromBackupRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrepaidDeploymentId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.BackupId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDeploymentRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PrepaidDeploymentId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.IpallowlistId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.Certificates != nil {
		l = m.Certificates.Size()
		n += 1 + l + sovPrepaid(uint64(l))
	}
	l = len(m.AcceptedTermsAndConditionsId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDeploymentRequest_CertificateSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CaCertificateId)
	if l > 0 {
		n += 1 + l + sovPrepaid(uint64(l))
	}
	if len(m.AlternateDnsNames) > 0 {
		for _, s := range m.AlternateDnsNames {
			l = len(s)
			n += 1 + l + sovPrepaid(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPrepaid(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPrepaid(x uint64) (n int) {
	return sovPrepaid(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PrepaidDeployment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepaidDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepaidDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartsAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartsAt == nil {
				m.StartsAt = &types.Timestamp{}
			}
			if err := m.StartsAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndsAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndsAt == nil {
				m.EndsAt = &types.Timestamp{}
			}
			if err := m.EndsAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportPlanId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportPlanId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 102:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Model == nil {
				m.Model = &v1.Deployment_ModelSpec{}
			}
			if err := m.Model.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 103:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addons", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addons = append(m.Addons, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 104:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskPerformanceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskPerformanceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 201:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PrepaidDeployment_Status{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepaidDeployment_Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttachedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttachedAt == nil {
				m.AttachedAt = &types.Timestamp{}
			}
			if err := m.AttachedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetachedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetachedAt == nil {
				m.DetachedAt = &types.Timestamp{}
			}
			if err := m.DetachedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastWarningEmailSendAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastWarningEmailSendAt == nil {
				m.LastWarningEmailSendAt = &types.Timestamp{}
			}
			if err := m.LastWarningEmailSendAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepaidDeploymentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepaidDeploymentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepaidDeploymentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &PrepaidDeployment{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPrepaidDeploymentsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPrepaidDeploymentsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPrepaidDeploymentsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &v11.ListOptions{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDeploymentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDeploymentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDeploymentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepaidDeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloneFromBackupRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloneFromBackupRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloneFromBackupRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepaidDeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDeploymentRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDeploymentRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDeploymentRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepaidDeploymentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepaidDeploymentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpallowlistId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpallowlistId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Certificates == nil {
				m.Certificates = &CreateDeploymentRequest_CertificateSpec{}
			}
			if err := m.Certificates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptedTermsAndConditionsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptedTermsAndConditionsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDeploymentRequest_CertificateSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertificateSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertificateSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCertificateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCertificateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlternateDnsNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPrepaid
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPrepaid
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlternateDnsNames = append(m.AlternateDnsNames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPrepaid(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPrepaid
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPrepaid(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPrepaid
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPrepaid
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPrepaid
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPrepaid
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPrepaid
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPrepaid        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPrepaid          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPrepaid = fmt.Errorf("proto: unexpected end of group")
)
